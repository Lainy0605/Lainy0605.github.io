<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>羊羊日记其一</title>
    <url>/2022/12/22/COVID19DiaryOne/</url>
    <content><![CDATA[<p>今天大约已经是进入羊圈的第四天。</p>
<h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h1><p>阳的第一天，嗓子有干涩的感觉，但不痛，发烧也只是象征性地温度涨了涨。本来以为奥密克戎不过如此，谁料竟是象征性地客气一下，来了手先礼后兵</p>
<h1 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h1><p>第二天腰就被偷袭，疼得我猝不及防，那种隐隐作痛的感觉，描述起来就是能够清楚的感觉到两边腰传来阵阵痛感，但却说不出到底是哪处，喉咙也开始轻微痛</p>
<h1 id="Day-3"><a href="#Day-3" class="headerlink" title="Day 3"></a>Day 3</h1><p>开始轻微的流鼻涕还鼻塞，喉咙继续痛痛痛，腰不痛了四肢开始痛</p>
<h1 id="Day-4"><a href="#Day-4" class="headerlink" title="Day 4"></a>Day 4</h1><p>到了今天，也就是阳历四天，最疼疼疼的腰已经不疼了，与此同时也喜提了一个红红的鼻子，没错就是小丑^o^的那个红鼻。因为狂流鼻涕，就需要一直拿纸擤鼻涕。愈流、愈擤、愈红、愈痛，说起来鼻子想必早就习惯这样的事情，毕竟平常感冒鼻子也会遭受这样的苦难</p>
<h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>这次羊和平常感冒最大的不同之处，就个人经历来说是腰遭受了从未有过的折磨。网上传言的小刀剌嗓子其实和平常感冒的咽痛如出一辙，甚至不及感冒，发烧也只是徒有其名而无其实。不知明天症状如何，是否会被打脸😴</p>
<p><em>ps：目前还未嗑过药，全靠免疫力了</em></p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>羊羊日记</tag>
      </tags>
  </entry>
  <entry>
    <title>羊羊日记其二</title>
    <url>/2022/12/28/COVID19DiaryTwo/</url>
    <content><![CDATA[<h1 id="Day-5"><a href="#Day-5" class="headerlink" title="Day 5"></a>Day 5</h1><p>其他症状都无，唯独开始咳嗽</p>
<h1 id="Day-6"><a href="#Day-6" class="headerlink" title="Day 6"></a>Day 6</h1><p>咳咳咳咳</p>
<h1 id="Day-7"><a href="#Day-7" class="headerlink" title="Day 7"></a>Day 7</h1><p>咳咳咳咳咳死了。</p>
<p>网上说咳嗽是一个打扫战场的过程，这只怕是打扫的有亿点点久</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>羊羊日记</tag>
      </tags>
  </entry>
  <entry>
    <title>2022年度报告</title>
    <url>/2023/01/03/annualReviewFor2022/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>年度报告</tag>
      </tags>
  </entry>
  <entry>
    <title>关于node的一些报错</title>
    <url>/2022/12/28/nodeError/</url>
    <content><![CDATA[<h1 id="MySQL认证失败"><a href="#MySQL认证失败" class="headerlink" title="MySQL认证失败"></a>MySQL认证失败</h1><ul>
<li><p>报错内容</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;code&quot;</span>:<span class="string">&quot;ER_NOT_SUPPORTED_AUTH_MODE&quot;</span>,<span class="string">&quot;errno&quot;</span>:<span class="number">1251</span>,<span class="string">&quot;sqlMessage&quot;</span>:<span class="string">&quot;Client does not support authentication protocol requested by server; consider upgrading MySQL client&quot;</span>,<span class="string">&quot;sqlState&quot;</span>:<span class="string">&quot;08004&quot;</span>,<span class="string">&quot;fatal&quot;</span>:<span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>报错原因</p>
<ul>
<li>mysql8.0默认密码认证方案是‘caching_sha2_password’，而目前node默认的密码认证方案是’mysql_native_password’，所以无法认证成功</li>
</ul>
</li>
<li><p>解决方案</p>
<ol>
<li><p>终端启动mysql</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改密码认证方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; alter user &#x27;root&#x27;@&#x27;localhost&#x27; identified with mysql_native_password by &#x27;这里填root用户密码&#x27;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; flush privileges;</span><br></pre></td></tr></table></figure>
</li>
<li><p>退出mysql</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; exit;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h1 id="session报错undefined"><a href="#session报错undefined" class="headerlink" title="session报错undefined"></a>session报错undefined</h1><ul>
<li><p>报错原因：先发送了res再设置的req的session</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/captcha&#x27;</span>,<span class="keyword">function</span> (<span class="params">req,res</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> code = <span class="title function_">captcha</span>();</span><br><span class="line">    res.<span class="title function_">type</span>(<span class="string">&quot;svg&quot;</span>).<span class="title function_">send</span>(code.<span class="property">data</span>);</span><br><span class="line">    req.<span class="property">session</span>.<span class="property">captcha</span> = code.<span class="property">text</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>解决方案：交换顺序</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/captcha&#x27;</span>,<span class="keyword">function</span> (<span class="params">req,res</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> code = <span class="title function_">captcha</span>();</span><br><span class="line">    req.<span class="property">session</span>.<span class="property">captcha</span> = code.<span class="property">text</span>;</span><br><span class="line">    res.<span class="title function_">type</span>(<span class="string">&quot;svg&quot;</span>).<span class="title function_">send</span>(code.<span class="property">data</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="MySQL连接失败"><a href="#MySQL连接失败" class="headerlink" title="MySQL连接失败"></a>MySQL连接失败</h1><ul>
<li><p>报错内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Error: connect ECONNREFUSED ::<span class="number">1</span>:<span class="number">3306</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>报错原因</p>
<ul>
<li>localhost没有和127.0.0.1映射</li>
</ul>
</li>
<li><p>解决方案</p>
<ol>
<li><p>将localhost映射为127.0.0.1，具体方法略</p>
</li>
<li><p>将mysql配置中host更改为127.0.0.1</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> mysql <span class="keyword">from</span> <span class="string">&#x27;mysql&#x27;</span></span><br><span class="line"><span class="keyword">let</span> connection = mysql.<span class="title function_">createConnection</span>(&#123;</span><br><span class="line">    host     : <span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">    port     :  <span class="number">3306</span>,</span><br><span class="line">    user     : <span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">    password : <span class="string">&#x27;030605&#x27;</span>,</span><br><span class="line">    database : <span class="string">&#x27;schema_userInfo&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line">connection.<span class="title function_">connect</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connection</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h1 id="dirname报错undefined"><a href="#dirname报错undefined" class="headerlink" title="__dirname报错undefined"></a>__dirname报错undefined</h1><ul>
<li><p>报错内容</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">ReferenceError</span>: __filename is not defined <span class="keyword">in</span> <span class="variable constant_">ES</span> <span class="variable language_">module</span> scope</span><br></pre></td></tr></table></figure>
</li>
<li><p>报错原因</p>
<ul>
<li>在node中使用ES Modules规范时，以下全局对象和变量将不可用<ul>
<li>require</li>
<li>module.exports</li>
<li>exports</li>
<li>__filename</li>
<li>__dirname</li>
<li>NODE_PATH</li>
</ul>
</li>
<li>具体原因可以查看<a href="https://juejin.cn/post/7036744678749765640">这篇博客</a></li>
</ul>
</li>
<li><p>解决方案</p>
<ul>
<li><p>如果要在ES Modules规范中使用__dirname</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// import.meta.url 返回模块的绝对的 `file:` URL。</span></span><br><span class="line"><span class="comment">// url模块中fileURLToPath()函数，返回完全解析的特定于平台的 Node.js 文件路径</span></span><br><span class="line"><span class="comment">// path模块中dirname()函数，返回路径的目录路径</span></span><br><span class="line"><span class="keyword">import</span> &#123; fileURLToPath &#125; <span class="keyword">from</span> <span class="string">&#x27;url&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; dirname &#125; <span class="keyword">from</span> <span class="string">&#x27;path&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> __filename = <span class="title function_">fileURLToPath</span>(<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">url</span>);</span><br><span class="line"><span class="keyword">const</span> __dirname = <span class="title function_">dirname</span>(__filename);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="重复设置请求头"><a href="#重复设置请求头" class="headerlink" title="重复设置请求头"></a>重复设置请求头</h1><ul>
<li><p>报错内容</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Error</span> [<span class="variable constant_">ERR_HTTP_HEADERS_SENT</span>]: <span class="title class_">Cannot</span> set headers after they are sent to the client</span><br></pre></td></tr></table></figure>
</li>
<li><p>报错原因</p>
<ul>
<li>res.send()调用了多次</li>
</ul>
</li>
<li><p>解决方案</p>
<ul>
<li>res.send()后就return</li>
<li>检查是否是异步的问题导致res.send()调用多次</li>
</ul>
</li>
</ul>
<h1 id="Uncaught-SyntaxError-Cannot-use-import-statement-outside-a-module"><a href="#Uncaught-SyntaxError-Cannot-use-import-statement-outside-a-module" class="headerlink" title="Uncaught SyntaxError Cannot use import statement outside a module"></a>Uncaught SyntaxError Cannot use import statement outside a module</h1><ul>
<li><p>报错内容</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Uncaught</span> <span class="title class_">SyntaxError</span> <span class="title class_">Cannot</span> use <span class="keyword">import</span> statement outside a <span class="variable language_">module</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>报错原因</p>
<ul>
<li>使用了es6的语法， 浏览器默认将它作为js解析会出现问题</li>
</ul>
</li>
<li><p>解决方案</p>
<ul>
<li><p><code>script</code>标签默认为<code>type=&quot;text/javascript&quot;</code>，需要改为<code>type=&quot;module&quot;</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;public/js/index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>js</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>一些启动台图标的问题</title>
    <url>/2023/01/16/tipsForMacOS/</url>
    <content><![CDATA[<h1 id="删除启动台的无效图标"><a href="#删除启动台的无效图标" class="headerlink" title="删除启动台的无效图标"></a>删除启动台的无效图标</h1><p>问题描述：安装adobe产品的过程中启动台会添加一大堆图标，卸载后发现启动台会有无效图标残留</p>
<p>解决方法：terminal中输入以下指令，其中的APPNAME是想要删除的图标的名字</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">sqlite3 <span class="variable">$(find /private/var/folders -name com.apple.dock.launchpad 2&gt;/dev/null)</span>/db/db \ <span class="string">&quot;DELETE FROM apps WHERE title=&#x27;APPNAME&#x27;;&quot;</span>&amp;&amp;killall Dock</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title>需求与商业模式创新复习</title>
    <url>/2023/02/15/demandAndBusinessModelInnovation/</url>
    <content><![CDATA[<h1 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h1><h2 id="什么是软件"><a href="#什么是软件" class="headerlink" title="什么是软件"></a>什么是软件</h2><ul>
<li>从组成成分的角度看软件（“写的对”）<ul>
<li>代码+文档</li>
</ul>
</li>
<li>从问题求解的角度看软件（“写对的”）<ul>
<li>作为一种复杂的信息制品，软件是对客观事物的深度抽象与建模，且同时包含了对复杂客观世界的<strong>问题空间</strong>与<strong>解空间</strong>的具体描述</li>
</ul>
</li>
</ul>
<h2 id="问题域与解系统"><a href="#问题域与解系统" class="headerlink" title="问题域与解系统"></a>问题域与解系统</h2><ul>
<li><p>从<strong>问题域背景</strong>出发，结合<strong>涉众主观意愿</strong>，设定系统<strong>目标</strong>，制定开发<strong>任务</strong>，细分系统<strong>交互</strong></p>
</li>
<li><p>软件系统解决问题的基础：模拟与共享</p>
<ul>
<li>软件系统中的某些部分对问题域中的某些部分具有模拟特性</li>
<li>这些通过映射建立的共同知识，就是问题域和解系统之间的共享现象</li>
<li>最后将解系统的模型操纵与计算结果用于指导现实世界的问题解决</li>
</ul>
</li>
</ul>
<h2 id="需求的两个维度"><a href="#需求的两个维度" class="headerlink" title="需求的两个维度"></a>需求的两个维度</h2><ul>
<li>需求（问题域端）<ul>
<li>直接需求、间接需求</li>
<li>不切实际的期望</li>
<li>![image-20230131155234455](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230131155234455.png)</li>
</ul>
</li>
<li>需求规格说明（解系统端）<ul>
<li>数据：现实世界的模型</li>
<li>功能：对模型的操作，将结果反馈回现实世界，辅助解决问题   </li>
<li>![image-20230131155304159](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230131155304159.png)</li>
</ul>
</li>
</ul>
<h2 id="需求的四个基本概念"><a href="#需求的四个基本概念" class="headerlink" title="需求的四个基本概念"></a>需求的四个基本概念</h2><ul>
<li>问题域、需求、解系统、需求规格说明</li>
</ul>
<p>![image-20230131152939051](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230131152939051.png)</p>
<h2 id="需求的定义"><a href="#需求的定义" class="headerlink" title="需求的定义"></a>需求的定义</h2><ul>
<li>IEEE<ol>
<li>用户为了解决问题或达到某些目标所需要的条件或能力</li>
<li>系统或系统部件为了满足合同、标准、规范或其他正式文档所规定的要求而需要具备的条件或能力</li>
<li>对1或2中的一个条件或能力的一种文档化表述</li>
</ol>
</li>
</ul>
<h2 id="计算器的问题域和解系统各是什么"><a href="#计算器的问题域和解系统各是什么" class="headerlink" title="计算器的问题域和解系统各是什么"></a>计算器的问题域和解系统各是什么</h2><ul>
<li>问题域一般不包括计算机世界的概念，要从明确的应用领域和人性（情感诉求、日常生活等）出发</li>
<li>解系统一般也不是模糊的“宏观”系统目标，而是明确的问题域背景+问题+目标+任务+交互（+设计、实现、测试、部署等其他制品）</li>
<li>纯计算器（没有模拟与共享）可认为是解系统的一个组件、不同类型的计算器（编程语言）有其假设的场景，才有问题域</li>
</ul>
<h1 id="商业模式画布"><a href="#商业模式画布" class="headerlink" title="商业模式画布"></a>商业模式画布</h1><h2 id="商业模式模型"><a href="#商业模式模型" class="headerlink" title="商业模式模型"></a>商业模式模型</h2><ul>
<li>为何需要从商业模式开始：人人互联成本趋零导致的潜在用户群体变化以及已有业务的重组</li>
<li>目标1：人人都能理解，容易达成共识</li>
<li>目标2：易于建模和操作</li>
<li>目标3：依然具有分析复杂情况的能力</li>
</ul>
<p>![image-20230131161642857](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230131161642857.png)</p>
<h2 id="情感端"><a href="#情感端" class="headerlink" title="情感端"></a>情感端</h2><h3 id="客户细分Customer-Segments"><a href="#客户细分Customer-Segments" class="headerlink" title="客户细分Customer Segments"></a>客户细分Customer Segments</h3><ul>
<li><p>一家企业想要获得的和期望服务的不同目标人群和机构</p>
<ul>
<li>细分条件<ul>
<li>需求催生新供给</li>
<li>需要新分销渠道和客户关系类型</li>
<li>产生的利润率不同</li>
<li>愿意为某方面的特殊改进买单</li>
</ul>
</li>
<li>需要谨慎处理客户的细分与取舍</li>
</ul>
</li>
<li><p>划分方式举例</p>
<ul>
<li>大众市场<ul>
<li>消费电子、大型零售商</li>
</ul>
</li>
<li>小众市场<ul>
<li>产业链上的供应商-采购商</li>
</ul>
</li>
<li>求同存异的客户群体<ul>
<li>各类产品线、诺基亚</li>
</ul>
</li>
<li>多元化客户群体<ul>
<li>3M公司，做胶水、口罩</li>
<li>三星</li>
<li>亚马逊&#x2F;阿里</li>
</ul>
</li>
<li>多边平台&#x2F;市场<ul>
<li>大型互联网平台，例如B站、淘宝</li>
</ul>
</li>
</ul>
</li>
<li><p>CS的进一步讨论——尽可能拓宽客户群体</p>
<ul>
<li>华为的成长与客户细分类型（围绕主营业务不断拓宽）<ul>
<li>程控交换机</li>
<li>通讯服务设备、各类业务软件、通信终端、光伏逆变、芯片设计、智能车组件</li>
<li>手机：运营商定制机、P、Mate、荣耀（V、S、Magic）、Nova、X</li>
<li>espace（办公软件）、鸿蒙、华为云</li>
<li>2022：“三年不做车”——重要的车机提供方与联名商</li>
</ul>
</li>
<li>英雄联盟手游的客户细分（客户的细分与取舍）<ul>
<li>王者荣耀难当出海大任</li>
<li>细分：lol宇宙观与竞技赛事背景下的“轻度”玩家</li>
<li>取：海外玩家、女性玩家、云玩家</li>
<li>舍：端游重度玩家、但通过赛事、世界观等内容进行融合（大乱斗、云顶之弈、Valorant、lol世界）、向文化社区转向</li>
<li>2022：英雄联盟电竞经理-选手卡周边（愈发靠拢传统体育）</li>
</ul>
</li>
<li><strong>客户群体拓宽背后的共性——共享内核的价值主张网络</strong></li>
</ul>
</li>
</ul>
<h3 id="价值主张Value-Proposition"><a href="#价值主张Value-Proposition" class="headerlink" title="价值主张Value Proposition"></a>价值主张Value Proposition</h3><ul>
<li><p>为某一客户群体提供能为其创造价值的产品和服务</p>
<ul>
<li>解决客户的问题或满足其需求，<strong>使其选择一家而放弃另一家</strong></li>
<li>一家公司为特定客户群体提供的利益集合或组合</li>
<li>创新性的、革命性的产品或服务 VS 既有产品或服务+新特点或属性</li>
</ul>
</li>
<li><p>有益于价值创造的因素罗列（部分）</p>
<ul>
<li>创新newness：满足客户未曾察觉全新需求，可以是非技术的创新</li>
<li>性能performance：PC机与显卡（摩尔定律，xp与vista，win7与win8）、智能手机</li>
<li>定制customization：大规模定制（众筹，联名款）与客户参与创造（MIUI，UGC，用户社区）</li>
<li>一站式服务getting the job done：飞机引擎维护、咨询公司、BOT工程（总包-交钥匙）</li>
<li>设计design：时尚（施华洛世奇）、消费电子产品（苹果、索尼手机、锤子手机）</li>
<li>品牌&#x2F;地位brand&#x2F;status：奢侈品（机械手表、名牌包）、潮牌（球鞋、Hip- Hop）、游戏等级</li>
<li>价格price：廉价航空、小米、免费经济</li>
<li>缩减成本cost reduction：服务外包（编程、房产销售）</li>
<li>风险控制risk reduction：保险、额外保障服务</li>
<li>可获得性accessibility：共享经济、共同基金（股票与货币基金）</li>
<li>便利性&#x2F;实用性convenience&#x2F;usability：苹果音乐商店、云计算（网盘、服务器、游戏）</li>
</ul>
</li>
<li><p>分类</p>
<ul>
<li>让事情更简单（痛点）：价格、缩减成本、便利性&#x2F;实用性</li>
<li>让事情更复杂（收益）：定制、设计、品牌&#x2F;地位、可获得性</li>
<li>让事情透明（痛点）：风险控制、一站式服务</li>
</ul>
</li>
<li><p>VP的进一步讨论</p>
<ul>
<li>一个产品的VP通常是相互重叠且交错的（价值网络）<ul>
<li>孤独的美食家五郎，他作为一个“个体户”，提供哪些VP？</li>
<li>定制、设计与品牌地位，一站式服务与风险控制，缩减成本、可获得性与便利性等</li>
</ul>
</li>
<li>初创团队如何设计自己的VP<ul>
<li>为了生存，初创团队需以“轻成本”的方式运营，可以多考虑引入“简单”与“透明”式的产品，维持“轻成本”运营<ul>
<li>信息类产品：微信公众号、（短）视频平台</li>
<li>实物类产品：各类生产线的复用（定制JK裙、元气森林）</li>
</ul>
</li>
<li>一般而言，VP以“收益”型为主<ul>
<li>“低价”的VP需要：某领域内的高效率、高覆盖、强竞争</li>
<li>初创团队需要较高定价以形成发展所需的利润空间<ul>
<li>产品成长、渠道开拓、小品牌导致的高价格要素等均使得初创团队的花费更高</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="渠道通路CHannels"><a href="#渠道通路CHannels" class="headerlink" title="渠道通路CHannels"></a>渠道通路CHannels</h3><ul>
<li>一家企业如何同它的客户群体达成沟通并建立联系，以向对方传递自身的价值主张<ul>
<li>企业与客户交互体系：交流、分销、销售渠道（+售后），是用户的交互触点</li>
<li>作用：了解产品与服务、评估价值主张；购买产品与服务、传递价值主张；提供售后支持</li>
</ul>
</li>
<li>渠道的五个阶段与运营方式<ul>
<li><strong>知名度-评价-购买-传递-售后</strong>（三包、评论）<ul>
<li>思考：在教超买个面包当夜宵</li>
</ul>
</li>
<li>一个渠道可包含一个或全部五个阶段</li>
<li>一个组织可选用自有渠道、合作方渠道或混用，以追求获益与成本的平衡以及最佳的客户体验<ul>
<li>自身强渠道：蓝绿大厂线下店面、品牌贴牌与认证授权（日本马桶圈与电饭锅、日化、米家），<strong>能主动引发流量的互联网平台</strong></li>
<li>合作方渠道：各大电商平台（农村电商汇通达），贝业新兄弟，品牌水暖空调门店，小红书（种草拔草社区），视频推广（恰饭视频，B站）</li>
<li>混用：移动运营商直营与加盟店，天猫上的苏宁易购官方店（仓储、物流、售后），网易严选</li>
</ul>
</li>
</ul>
</li>
<li>CH的进一步讨论<ul>
<li><p>渠道通路的重要性</p>
<ul>
<li>商业的本质，人人互联成本为零的最大发力点</li>
<li>与产品设计的关系微妙：渠道对同类产品竞争起核心作用；过度重视容易引发反噬（品质与信任的失配）</li>
<li>产品设计运维一体化：CH承载VP与CS的组合关系，用不断推出的新产品进行营销-强化&#x2F;更新VP，加强&#x2F;拓展CS对系列产品服务的认知。 </li>
<li><strong>（完全）基于渠道的品牌：南极人、三只松鼠——品牌认知与电商渠道</strong></li>
<li>（免费）公开渠道：微信公众号、朋友圈、小程序</li>
</ul>
</li>
<li><p>直播带货：最新涌现的渠道通路</p>
<ul>
<li>手机淘宝-淘宝直播：阿里系电商在移动互联时代渡劫的关键</li>
<li>特点：<strong>模拟线下体验</strong>；信任敏感高；“低价”-“出新”<ul>
<li>线下零售新热点：低价折扣店-类似直播带货（信任：主播-已知品牌）</li>
</ul>
</li>
<li>2021淘宝“双十一”直播：李佳琦106.5亿（佣金20.0亿，触发所得税税率上限45%），薇娅82.5亿（第三名9.3亿，第四名1.6亿）</li>
</ul>
</li>
<li><p>2015年4月，雷军表示：“小米是电商” </p>
<ul>
<li>小米10之前，小米的VP和CS组合、以及红米的出现导致小米本身不赚钱（但有流量-200w圆角与“xiaomi”），小米手机可视作米家生态的“渠道”<ul>
<li>小米4于2014.7月底首发，2021年上半年宣布造车</li>
</ul>
</li>
<li>小米手机+米家生态 &#x3D; 新时代中国“宜家”？<ul>
<li>小米手机定位在调整：“米冲高、关键年“ V.S. “谁还敢买小米旗舰”</li>
<li>MIUI失控的原因：松散组织、加速迭代、需求（可追踪性）失控</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="客户关系-Customer-Relationship"><a href="#客户关系-Customer-Relationship" class="headerlink" title="客户关系 Customer Relationship"></a>客户关系 Customer Relationship</h3><ul>
<li>一家企业针对某一个客户群体所建立的客户关系的类型<ul>
<li>靠人员维护（专属一对一财富管家）VS 自动化设备（24小时自助）</li>
<li>动机：开发新客户、留住原客户、增加销售量或客单价（携程杀熟、杀苹果用户）</li>
</ul>
</li>
<li>客户关系类型<ul>
<li>私人服务personal assistance：商场导购、柜台服务与电渠、销售员</li>
<li>专属私人服务dedicated personal assistance：私人银行服务、华为电信设备、健身&#x2F;培训“私教”</li>
<li>自助服务self-service：话费流量充值、银行普通业务（ATM与大厅内自助服务）</li>
<li>自动化服务automated services：各类平台推荐系统、网站导航设计（活动、凑单、无货推荐、红色与橙色的加入购物车、立即购买）</li>
<li>社区communities：花粉俱乐部、小米之家、小红书、各类网友社区</li>
<li>客户共同创造co-creation：MIUI、UGC（土豆、B站、抖音）、各种评论（电影书籍-豆瓣、旅游住宿-airbnb、普通商品-自发安利与评论区），采纳用户反馈的社区（产品调查问卷、游戏平衡运营）</li>
</ul>
</li>
<li>分类<ul>
<li>成本导向：自助服务、自动化服务</li>
<li>价值导向：私人服务、专属私人服务、客户共同创造</li>
<li>兼顾：社区（社交裂变、私域流量）</li>
</ul>
</li>
</ul>
<h3 id="收入来源-Revenue-Streams"><a href="#收入来源-Revenue-Streams" class="headerlink" title="收入来源 Revenue Streams"></a>收入来源 Revenue Streams</h3><ul>
<li>企业从每一个客户群体获得的现金收益（扣除成本的利益）<ul>
<li>探索用户真正愿意付费的点</li>
<li>两类收益来源：一次性交易收入、持续收入（进一步提供产品服务或售后支持）</li>
<li>定价机制<ul>
<li>固定（基于静态变量）：目录价、基于产品特性（“青春版”，“畅享版”）、基于客户群（教育版）、基于数量</li>
<li>浮动（基于动态变量）：谈判&#x2F;议价、收益管理（库存与发生购买的时间，如生鲜、熟食、酒店、航班等）、实时市场价格、拍卖</li>
</ul>
</li>
</ul>
</li>
<li>收入来源的方式<ul>
<li>资产销售asset sale：实物产品所有权转让、消费者拥有处置的全部权利</li>
<li>使用费usage fee：电信、宾馆、快递、付费网游点卡、公共交通车票</li>
<li>会员费subsrciption fee：健身卡、付费网游月卡、公共交通月票、音乐会员</li>
<li>租赁lending&#x2F;renting&#x2F;leasing：共享单车&#x2F;汽车&#x2F;充电宝，特定资产在特定时间的使用权转移并获益</li>
<li>许可使用费licensing：专利授权、版权（图片、音乐、字体），加盟或特许经营</li>
<li>经纪人佣金brokerage fees：信用卡（交易手续费）、支付平台（交易与提现手续费）、中介</li>
<li>广告费advertising：传媒、品牌策划、软件业与服务业；广告费增长乏力、分蛋糕的太多<ul>
<li>“购买”未来的消费预期-从“形象宣传”到“实际体验”再到“品牌认同”</li>
</ul>
</li>
</ul>
</li>
<li>RS的进一步讨论<ul>
<li>三级价格歧视（差异定价）<ul>
<li>按人（杀价、拍卖、杀熟）</li>
<li>按量（批发、团购、套餐、优惠券、峰谷阶梯定价）</li>
<li>按类（可选择的差异化服务：氪金、VIP、加急、视频会员、精装与典藏、机票折扣、社交裂变和私域流量）</li>
<li>2021年8月27日，网信办《互联网信息服务算法推荐管理规定（征求意见稿）》<ul>
<li>不得根据消费者的偏好，交易习惯等特征，利用算法在交易价格等交易条件上实行不合理的差别待遇等违法行为</li>
<li>2020.10.1出台《在线旅游经营服务管理暂行规定》；2021.11.1实行《个人信息保护法》</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>“双十一盖楼、砍一刀&amp;百亿补贴、私域流量”<ul>
<li>买家盖楼：用个人的精力与社会关系证明你对折扣的“渴望”</li>
<li>卖家入场：通过适度折扣充分发掘消费欲望与潜力，将投入精力与消费行为绑定<ul>
<li>私域流量：适度折扣锁定域内用户后续消费需要-瑞幸、麦当劳、便利蜂</li>
</ul>
</li>
<li>当前最强营销手段：PDD百亿补贴（“人货场”理论）<ul>
<li>人：价格敏感的高渴望群体（学生-B站）；货：有趣好玩但不急需的大牌（品牌消费电子、产品）；场：PDD自身聚集的流量与对应的定价权（成-苹果，败-特斯拉）</li>
</ul>
</li>
<li>永远的真理：“不买立省百分百！”-货、场最终都是为人服务<ul>
<li>标准：（商品）可持续提供（关键）价值&amp;可负担</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="理性端"><a href="#理性端" class="headerlink" title="理性端"></a>理性端</h2><h3 id="核心资源-Key-Resources"><a href="#核心资源-Key-Resources" class="headerlink" title="核心资源 Key Resources"></a>核心资源 Key Resources</h3><ul>
<li>保证一个商业模式顺利运行所需的最重要的资产<ul>
<li>用于：价值主张的创造与提供、开拓市场、维护客户关系并获益</li>
<li>可以“自主拥有”或者“寻求合作”<ul>
<li>“核心”意味着稀缺与不可替代，需要花费巨大的成本维系</li>
<li>“拥有”意味着额外的管理、折旧和风险，“合作”意味着让出的利润空间与颠覆式的生存危机-从“核心”向外扩展：拥有-合作</li>
</ul>
</li>
</ul>
</li>
<li>类型<ul>
<li>实物资源physical：生产设备、房屋、车辆、机器、系统、销售点管理系统、分销渠道（腾讯：流量的“低吸高抛”）</li>
<li>知识性资源intellectual：品牌（可口可乐）、专利（高通与华为）、知识产权与体系（微软、SAP、安卓&#x2F;苹果）</li>
<li>人力资源human：普遍存在，对于创新性和知识密集产业最重要（如IT业），出色的营销团队<ul>
<li>劳动力高价的来源-对个人创造力的依赖&#x2F;“赛道稳定程度”：芯片制造与芯片设计，IT开发&#x2F;算法&#x2F;金融，公司与科研</li>
</ul>
</li>
<li>金融资源financial：<ul>
<li>内部：花呗、车贷、互联网金融 - “润滑”消费与经营，电商标配</li>
<li>外部：风险投资、资本市场（国资）- 助力创新企业快速成长</li>
</ul>
</li>
</ul>
</li>
<li>KR的进一步讨论<ul>
<li>大厂的“屯人”竞争<ul>
<li>2022年以前：挖友商墙角 + 高薪囤积实习生、应届生</li>
<li>表面：大厂“公务员化”；实际：圈养+考核+输送人才<ul>
<li>如何应对：持续知识体系构建下的“肉食者鄙” - 初步能够观察互联网市场的持续变化 + “适当追求赛道风险” - 选择对个人创造力依赖强的业务领域 + “无限进步” - 面向个人长期持续进步（能够应对未知）的学习与工作</li>
</ul>
</li>
</ul>
</li>
<li>风投的利弊<ul>
<li>商业模式初步可行前提下的扶植验证与大规模复制<ul>
<li>互联网+时代创新的关键要素（钱+人+资源+渠道）</li>
<li>流派：赛道 vs. 赛车 vs. 赛手</li>
</ul>
</li>
<li>追求结果性的结果：要么赢，要么毁灭<ul>
<li>天性重“复制”、重“退出”（接盘或上市）导致的“信托化”、“泡沫化”</li>
<li>容易诱发：拔苗助长 + 无序竞争 + 垄断兼并 + 压制创新</li>
<li>“元宇宙”和Web3.0的某种必然性：多项风投技术投资在逻辑上的延伸</li>
</ul>
</li>
<li>这一轮“互联网寒冬”的重要诱因 - 美元回流与美股的脱钩风险<ul>
<li>调整后的各家互联网大厂经营情况并不弱 - 疫情红利与暂停烧钱</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="关键业务-Key-Activities"><a href="#关键业务-Key-Activities" class="headerlink" title="关键业务 Key Activities"></a>关键业务 Key Activities</h3><ul>
<li>保障其商业模式正常运行所需做的最重要的事情<ul>
<li>价值主张、获得市场、客户关系与收益</li>
<li>与价值主张强相关，价值主张的具象化</li>
<li>构建护城河：商业模式创新 - 构建不可替代的关键业务 - 支撑服务升级 - 基础设施投资 - 底层技术突破 - 拥有&#x2F;强化核心资源<ul>
<li>（免交易费换流量）双十一 - 弹性计算 + 阿里云 +OceanBase + 平头哥</li>
<li>盒马“鲜.美.生.活“ - 关键业务 - 核心资源？</li>
</ul>
</li>
</ul>
</li>
<li>类型<ul>
<li>生产production：包含分销网络、渠道等</li>
<li>解决方案problem solving：知识管理与持续的培训</li>
<li>平台&#x2F;网络platform&#x2F;network：XX网、Visa卡、操作系统、应用商店、游戏平台</li>
</ul>
</li>
</ul>
<h3 id="重要合作-Key-Partnership"><a href="#重要合作-Key-Partnership" class="headerlink" title="重要合作 Key Partnership"></a>重要合作 Key Partnership</h3><ul>
<li><p>一个商业模式顺利运行所需的供应商和合作伙伴网络</p>
<ul>
<li>非竞争者之间的战略联盟*<del>康采恩（不同业务之间的利益共同体）</del>*<ul>
<li>微信生态 vs. 苹果生态、Fortnite vs. App Store + Google Play</li>
</ul>
</li>
<li>竞争者之间的战略合作*<del>卡特尔（同产业控制产品产量和价格）</del>*<ul>
<li>红蓝快乐水、微信支付与支付宝、米国两党制</li>
</ul>
</li>
<li>新业务的合资公司*<del>托拉斯（多个巨头通过合资公司组成的利益共同体）</del>*<ul>
<li>大厂“生态”：3q大战之后的腾讯联盟 vs. 阿里直系</li>
</ul>
</li>
<li>稳定供应关系的供应商和采购商*<del>辛迪加（同产业垄断上有供应和下游销售）</del>*<ul>
<li>产业园、苹果认证供应商、闭环的互联网影视平台（传统影视产业：制作、发行、院线）</li>
</ul>
</li>
</ul>
</li>
<li><p>合作动机</p>
<ul>
<li><p>优化与规模效应 - 提供业务效率：降低成本，外包或共享基础设施</p>
</li>
<li><p>特殊资源及活动的获得 - 获得核心资源：高技术产品、销售团队、特许商品、渠道</p>
</li>
<li><p>降低风险和不确定性 - 降低业务风险：某领域内的战略联盟（蓝光，5G）、*<del>台湾省与韩国的面板联盟</del><em>京东方的崛起</em><del>（09-10家电下乡，韩国污点证人）</del>*</p>
</li>
<li><p>“千播”大战的结局：熊猫等倒下、斗鱼虎牙合并失败、企鹅电竞解散</p>
<ul>
<li>传统“文广新”内容的公有制属性不能变</li>
<li>以游戏为核心的直播平台幕后BOSS？ - 热门游戏版本所有者</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="成本结构-Cost-Structrue"><a href="#成本结构-Cost-Structrue" class="headerlink" title="成本结构 Cost Structrue"></a>成本结构 Cost Structrue</h3><ul>
<li>运营一个商业模式所发生的全部成本<ul>
<li>确定核心资源、关键业务和重要合作之后，成本核算将相对容易</li>
<li>也有以低成本结构为核心的商业模式（廉航、红米、Zara）</li>
</ul>
</li>
<li>导向<ul>
<li>成本导向cost-driven：成本最小化，创造并维持极尽精简的成本结构</li>
<li>价值导向value-driven：高端的价值主张与高度的个性化服务</li>
</ul>
</li>
<li>特点<ul>
<li>固定成本：管理员工工资、租金、生产设备</li>
<li>可变成本：加工工人工资，加班费，广告推广费，水电，原材料消耗</li>
<li>规模经济：大宗采购，大规模生产摊薄的固定成本</li>
<li>范围经济：渠道的复用（摊薄部分可变成本）</li>
<li>小米台灯为什么那么便宜？<ul>
<li>范围经济+规模经济的双向红利 - 如何做到：米家生态</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="重视模块之间的联系（以及联系的联系）"><a href="#重视模块之间的联系（以及联系的联系）" class="headerlink" title="重视模块之间的联系（以及联系的联系）"></a>重视模块之间的联系（以及联系的联系）</h2><ul>
<li>纵向联系（从上到下）<ul>
<li>客户关系-&gt;渠道通路-&gt;收入来源</li>
<li>关键业务-&gt;关键资源-&gt;成本支出</li>
</ul>
</li>
<li>跨越的联系<ul>
<li>客户关系选择与成本支出导向（定制化、个人化 - 价值导向 vs 自动化、大众化 - 成本导向）</li>
<li>除了价值主张与关键业务，关注建设渠道通路所需的核心资源与重要合作</li>
<li>细分的客户群体是否认同上游的重要合作方与引入的外部关键资源？</li>
</ul>
</li>
<li>联系的联系<ul>
<li>平台：多个“价值主张-客户细分”对的组合才能构成完整的收入来源<ul>
<li>吸引用户的主张与用户愿意付费的主张</li>
<li>促进多种不同用户群体的交易：补贴谁？收费谁？</li>
<li>如何运维平台并促进不同用户群体加入</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="完整商业模式举例：从iPod-x2F-iTunes商业模式到“网易云”"><a href="#完整商业模式举例：从iPod-x2F-iTunes商业模式到“网易云”" class="headerlink" title="完整商业模式举例：从iPod&#x2F;iTunes商业模式到“网易云”"></a>完整商业模式举例：从iPod&#x2F;iTunes商业模式到“网易云”</h2><p>![image-20230210202117005](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230210202117005.png)</p>
<ul>
<li><p>让画布动起来</p>
<ul>
<li><p>掌握商业模式画布之后的课程设置</p>
<ul>
<li><p>利用画布分析若干常见的商业模式类型 — 拆分&amp;开放</p>
</li>
<li><p>对新构建或已有的商业模式进行评估，并制定相应的战略</p>
</li>
<li><p>分析互联网时代的代表性商业模式类型 - 多边平台，免费，<strong>长尾</strong></p>
</li>
<li><p>利用画布构建或改进新的商业模式</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="商业模式类型"><a href="#商业模式类型" class="headerlink" title="商业模式类型"></a>商业模式类型</h1><ul>
<li><p>（讨论）建筑风格的意义在于捕获建筑设计的理念，将其作为典型的、可重复使用的描述</p>
</li>
<li><p>本课程关注的五类商业模式</p>
<ul>
<li>分拆商业模式（Unbundled）</li>
<li>长尾商业模式（Long-tail）</li>
<li>开放的商业模式（Open）</li>
<li>多边商业模式（Multisided）</li>
<li>免费商业模式（Free）</li>
</ul>
</li>
</ul>
<h2 id="分拆商业模式：商业版的“关注分离”"><a href="#分拆商业模式：商业版的“关注分离”" class="headerlink" title="分拆商业模式：商业版的“关注分离”"></a>分拆商业模式：商业版的“关注分离”</h2><ul>
<li><p>企业内部的三类规则：经济、竞争与文化</p>
<ul>
<li>由此可以区分三种活动：客户关系管理、新产品开发、基础设施管理</li>
<li>活动对应三种价值信条：亲近顾客、产品领先、运营卓越</li>
</ul>
</li>
<li><p>三类活动驱动因素不同，彼此之间冲突，企业内部消长（难共赢）</p>
<ul>
<li>解决方案：分拆！各自独立</li>
<li>![image-20230210203240215](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230210203240215.png)</li>
</ul>
</li>
<li><p>书上的例子![image-20230210203532124](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230210203532124.png)</p>
</li>
<li><p>补充例子：可口可乐</p>
<ul>
<li>新产品 - 适应无糖趋势<ul>
<li>茶、运动饮料、纯悦纯净水、罐装Costa咖啡（英国上市，减糖）、纤维 + 可乐（原产日本）、咖啡可乐（原产巴西）、爽椰派雪碧、无糖芬达</li>
</ul>
</li>
<li>客户关系 - 品牌矩阵与营销<ul>
<li>大量收购各国知名饮料品牌（尼日利亚Chi，收购汇源失败，约500+产品）</li>
<li>从diet coke到zero：配方基本不变，摆脱女性专属形象</li>
<li>外包装营销：与你的“女神&#x2F;闺蜜”共享 - 电视剧名台词 - 小瓶、时尚罐与小罐</li>
</ul>
</li>
<li>基础运营 - 调节风险与收益<ul>
<li>外包灌装 - 收购灌装厂 - 再次外包灌装（国内为太古和中粮）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="长尾商业模式"><a href="#长尾商业模式" class="headerlink" title="长尾商业模式"></a>长尾商业模式</h2><ul>
<li>进一步的、极致的客户细分<ul>
<li>支撑原理：长尾商业模式</li>
</ul>
</li>
<li>专注于多种类产品销售<ul>
<li>提供相当多种类的小众产品，每类卖出量相对很少，但汇总的销售收入可以与传统模式销售媲美<ul>
<li>在高效的互联网渠道加持下，专注于某领域的部分单品销售也能构成长尾</li>
</ul>
</li>
</ul>
</li>
<li>例子：图书出版、乐高数字在线</li>
</ul>
<h2 id="多边平台商业模式"><a href="#多边平台商业模式" class="headerlink" title="多边平台商业模式"></a>多边平台商业模式</h2><ul>
<li>价值主张一般体现在如下三方面<ul>
<li>吸引用户、群体配对、利用平台交易渠道降低交易成本</li>
</ul>
</li>
<li>客户群体相互依存，无法独立</li>
<li>核心资源是平台、成本主要来自于平台的维护和开发<ul>
<li>三项关键活动：平台管理、服务实现、平台升级</li>
<li>轻资产 vs. 重资产</li>
</ul>
</li>
<li>多个收益流，补贴正确的客户群是定价决策的关键<ul>
<li>如何设计收益流补贴？如何定价</li>
</ul>
</li>
</ul>
<p>![image-20230214115903077](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230214115903077.png)</p>
<h2 id="免费的商业模式"><a href="#免费的商业模式" class="headerlink" title="免费的商业模式"></a>免费的商业模式</h2><ul>
<li>三种可行的免费商业模式<ul>
<li>共同点：至少一个群体将得到免费的商品</li>
<li>广告模式：基于多边平台的免费商品</li>
<li>免费增值：免费的基本服务，可选的增值服务</li>
<li>诱饵&amp;陷阱：以免费或很便宜的初始价格吸引客户，并引导其重复购买</li>
</ul>
</li>
</ul>
<h3 id="基于广告的免费商业模式总结"><a href="#基于广告的免费商业模式总结" class="headerlink" title="基于广告的免费商业模式总结"></a>基于广告的免费商业模式总结</h3><ul>
<li>好的产品和服务以及高流量会吸引广告商，进而补贴产品和服务<ul>
<li>要考虑广告费能90p否支撑起产品服务质量</li>
<li>吞噬广告费的产品太多，流量红利已见底</li>
</ul>
</li>
<li>成本：平台的开发和维护，以及可能的获客与维系成本</li>
</ul>
<p>![image-20230214115843181](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230214115843181.png)</p>
<h3 id="免费增值的免费商业模式"><a href="#免费增值的免费商业模式" class="headerlink" title="免费增值的免费商业模式"></a>免费增值的免费商业模式</h3><ul>
<li>平台是最重要的资产，产生三部分成本<ul>
<li>客观的固定成本、免费账户的低边际成本服务、增值账户成本</li>
</ul>
</li>
<li>客户关系自动且低成本，免费用户向增值用户转化率是重要指标</li>
<li>平台发展新趋势<ul>
<li>需要高水平、差异化的产品与服务（为免费增值提供空间）</li>
<li>反面例子：庆余年与腾讯VIP<ul>
<li>已被放弃，是平台低效的体现</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>![image-20230214115831391](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230214115831391.png)</p>
<h3 id="诱饵-amp-陷阱模式总结"><a href="#诱饵-amp-陷阱模式总结" class="headerlink" title="诱饵&amp;陷阱模式总结"></a>诱饵&amp;陷阱模式总结</h3><ul>
<li>产品与后续产品之间要有紧密连接，从而使得极小收益的初始购买为后续高收益产品或服务的重复购买创造可能</li>
<li>关注后续产品交付，需要强大品牌支撑</li>
<li>重要成本结构<ul>
<li>初始产品补贴与后续产品的成本</li>
</ul>
</li>
<li>慢慢融入平台与免费增值<ul>
<li>新套餐体验 + 自动续费</li>
<li>各类社交裂变式促销（“盖楼”）</li>
<li>游戏本体 + DLC或平衡性无关道具</li>
<li>“又肝又氪”的游戏营销活动</li>
</ul>
</li>
</ul>
<p>![image-20230214115821387](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230214115821387.png)</p>
<h2 id="开放的商业模式"><a href="#开放的商业模式" class="headerlink" title="开放的商业模式"></a>开放的商业模式</h2><ul>
<li>补充：格力电器<ul>
<li>由外到内<ul>
<li>2014年以前，引入并组装丹麦的丹佛斯磁悬浮压缩机</li>
</ul>
</li>
<li>由内到外<ul>
<li>2019年11月向丹麦知名水泵生产商格兰富提供新型无稀土磁阻电机领域3哥系列的专利技术</li>
</ul>
</li>
<li>连接器<ul>
<li>1997年开始设立格力科技进步奖</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="互联网场景"><a href="#互联网场景" class="headerlink" title="互联网场景"></a>互联网场景</h2><ul>
<li><p>补充讨论：信息技术如何改变世界 - 构造场景</p>
<ul>
<li>人类社会的整体视角 - 人人互联的“小小世界”<ul>
<li>“六度分离”现象的背后 - 任何一种人人互动都会形成网络&#x2F;群体，群体的局部行为会导致全局性的结果</li>
<li>移动互联网 - 低成本互联下的“更小世界”</li>
<li>单个网民视角 - 通过<strong>场景</strong>连接到不同群体</li>
</ul>
</li>
<li>场景的定义</li>
<li>场景的连接<ul>
<li>基于场景的（构建产品）思维方式</li>
</ul>
</li>
</ul>
</li>
<li><p>补充讨论：被互联网定义的“新”场景</p>
<ul>
<li>以人为中心的体验细节 - （不同时段的）在线视听、公开社交（真人秀）、线下打造线上种草的网红地、知识获取&amp;分享&amp;玩梗（一显示自己的小团体&#x2F;独特爱好标签）、不同到货时间的购物体验</li>
<li>广泛的连接方式 - 扫一扫（二维码、实物）与商品、私域流量（社区、群聊、朋友圈）与各类活动、O2O、微信与其他APP</li>
<li>价值交换与新生活方式 - 红包&amp;打赏、各种智能设备</li>
<li>场景构成 - 时间、地点、人物、事件、链接方式</li>
<li>事实上，场景本身没有新旧之分，其差异在于能否（通过移动互联网）使场景参与者沟通诠释出新的价值与情感<ul>
<li>结合客户洞察描绘出独特、具体的场景</li>
<li>在这些场景中用户决定选择特定产品而放弃其他产品</li>
</ul>
</li>
</ul>
</li>
<li><p>补充讨论：互联网+软件天然的垄断趋势与后发软件的应对</p>
<ul>
<li>后发软件（产品）的机会何在？<ul>
<li>更加细分、贴合的用户体验 - 形成独特的亚文化、亚群体</li>
<li>结合核心资源、关键业务的深入打造</li>
<li>向新技术、新领域、新应用的创新尝试（“新”是指与典型互联网企业、行业相比，往往是有利可图的“老”行业）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="商业模式设计"><a href="#商业模式设计" class="headerlink" title="商业模式设计"></a>商业模式设计</h1><h2 id="客户洞察"><a href="#客户洞察" class="headerlink" title="客户洞察"></a>客户洞察</h2><ul>
<li><strong>看</strong>：描述该客户在她所处的环境中所看到的东西</li>
<li><strong>听</strong>：描述环境如何影响到这个客户</li>
<li><strong>想&amp;感受</strong>：尝试勾勒你的客户思维的过程</li>
<li><strong>说&amp;做</strong>：想象客户可能的言辞，或公共场合的行为</li>
<li><strong>痛点</strong>：已遭受的挫折、正遇到的阻碍、怕承担的风险</li>
<li><strong>收益</strong>：预期成就、成功衡量标准、实现目标所采用的策略</li>
</ul>
<p>![image-20230214133628911](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230214133628911.png)</p>
<ul>
<li>洞察力是设计思维的关键来源之一<ul>
<li>重视人的行为，而不是judge</li>
</ul>
</li>
<li>客户洞察的核心：换位思考</li>
</ul>
<h2 id="构思"><a href="#构思" class="headerlink" title="构思"></a>构思</h2><ul>
<li><p>一个能够产生大量商业模式创意，并成功识别出其中最佳创意的流程被称为<strong>构思</strong></p>
</li>
<li><p>构思的两个步骤：生成大量创意 -&gt; 对创意进行整合并挑选</p>
</li>
<li><p>提出新创意的两个出发点</p>
<ul>
<li>从画布中寻找创新的焦点</li>
<li>不断提出“如果……会怎样”的问题</li>
</ul>
</li>
<li><p>商业模式创新的焦点</p>
<ul>
<li>资源驱动<ul>
<li>资源驱动的创新来源于组织现有的基础设施或合作伙伴资源。企业由此出发延伸或改变商业模式</li>
</ul>
</li>
<li>供给驱动<ul>
<li>供给驱动的创新会创造全新的价值主张，并影响商业模式的其他模块</li>
</ul>
</li>
<li>客户驱动<ul>
<li>客户驱动的创新是基于客户需求、可获得性或者便利性的提升。和其他类型的创新一样，这种创新也会影响到商业模式的各个模块</li>
</ul>
</li>
<li>财务驱动</li>
<li>多点驱动</li>
</ul>
</li>
<li><p>构思的流程与团队建设</p>
<ol>
<li>团队组建</li>
<li>钻研</li>
<li>开拓</li>
<li>甄选标准</li>
<li>构建模型</li>
</ol>
</li>
<li><p>头脑风暴的原则</p>
<ul>
<li>保持聚焦</li>
<li>执行规则</li>
<li>视觉化思考</li>
<li>准备</li>
</ul>
</li>
</ul>
<h2 id="视觉化思考"><a href="#视觉化思考" class="headerlink" title="视觉化思考"></a>视觉化思考</h2><h2 id="模型构建"><a href="#模型构建" class="headerlink" title="模型构建"></a>模型构建</h2><h2 id="讲故事"><a href="#讲故事" class="headerlink" title="讲故事"></a>讲故事</h2><ul>
<li>两种视角<ul>
<li>公司视角<ol>
<li>观察到的新商业模式所解决的客户问题</li>
<li>新商业模式如何比旧模式更好的利用资源、业务和伙伴关系（降本增效、开源节流）</li>
<li>员工承载了组织内部工作与商业模式，以及转向新模式的原因</li>
</ol>
</li>
<li>客户视角<ol>
<li>客户面临的挑战与必须完成的工作，以及组织如何为其创造价值</li>
<li>描述她得到的东西、这些东西如何融入她的生活、以及她愿意为哪些东西付费</li>
<li>可以添加一些戏剧性和情感因素，描述你的组织如何让她的生活更简单</li>
<li>故事需要真实可信，避免油腔滑调或居高临下的口吻</li>
</ol>
</li>
</ul>
</li>
<li><strong>讲故事的目的是为了引人入胜、栩栩如生地介绍一个新商业模式</strong></li>
<li>讲故事的方法<ul>
<li>图片和旁白</li>
<li>视频</li>
<li>角色扮演</li>
<li>文字和图片</li>
<li>连环图画</li>
</ul>
</li>
</ul>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><ul>
<li>两种场景<ul>
<li>不同的客户结构<ul>
<li>由场景决定选择哪款产品而放弃其他产品</li>
</ul>
</li>
<li>未来可能的竞争环境</li>
</ul>
</li>
<li>场景六个阶段<ul>
<li>了解与评估</li>
<li>购买与传递</li>
<li>交互</li>
<li>售后</li>
<li>评价与复购</li>
</ul>
</li>
</ul>
<h1 id="商业模式战略"><a href="#商业模式战略" class="headerlink" title="商业模式战略"></a>商业模式战略</h1><h2 id="商业模式环境"><a href="#商业模式环境" class="headerlink" title="商业模式环境"></a>商业模式环境</h2><p>![image-20230214164902810](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230214164902810.png)</p>
<h3 id="市场影响力"><a href="#市场影响力" class="headerlink" title="市场影响力"></a>市场影响力</h3><ol>
<li>市场问题：从客户和供给的角度识别出驱动和改变你的市场的关键问题</li>
<li>市场分类：识别主要的市场群体，描述他们的兴趣点，尝试发现新的群体</li>
<li>需求和诉求：列举市场需求并分析这些需求被满足的程度</li>
<li>切换成本：客户转投竞争对手，哪些方面需要改变</li>
<li>收入影响力：识别与收入吸引力和定价能力相关的因素</li>
</ol>
<h3 id="行业影响力"><a href="#行业影响力" class="headerlink" title="行业影响力"></a>行业影响力</h3><ol>
<li>（现有的）竞争对手：识别现有竞争对手和他们的相对优势</li>
<li>新进入者（挑战者）：新出现的玩家以及他们商业模式的不同</li>
<li>替代产品和服务：（包括其他市场和行业在内的）替代产品和服务</li>
<li>供应商与价值链上的其他厂商：当前价值链上的关键玩家与新兴玩家</li>
<li>利益相关者：那些人会影响你的组织和商业模式</li>
</ol>
<h3 id="关键趋势"><a href="#关键趋势" class="headerlink" title="关键趋势"></a>关键趋势</h3><ol>
<li>技术趋势：威胁和推动发展当前商业模式的技术趋势</li>
<li>行业管理趋势：影响（你的）商业模式的管理规定和管理趋势</li>
<li>社会和文化趋势：可能影响（你的）商业模式的社会趋势</li>
<li>社会经济趋势：总结和你的商业模式有关的主要社会经济趋势<ul>
<li>短视频人均用户时长120分钟<ul>
<li>手机使用方式：碎片 &gt; 沉浸</li>
<li><strong>用户追求个人效率的提升 - 日常生活的进一步“外包”</strong></li>
</ul>
</li>
<li>整体经济周期处于萧条期，疫情放开后应该好转</li>
</ul>
</li>
</ol>
<h3 id="宏观经济影响"><a href="#宏观经济影响" class="headerlink" title="宏观经济影响"></a>宏观经济影响</h3><ol>
<li>全球市场情况：从宏观经济角度总结当前整体情况<ul>
<li>全球经济增速放缓</li>
</ul>
</li>
<li>资本市场：与你的资本需求相关的当前资本市场情况</li>
<li>大宗商品和其他资源：关注你的商业模式所需的资源价格与趋势<ul>
<li>人力成本不断上升</li>
</ul>
</li>
<li>经济基础设施：你的业务市场的经济基础设施<ul>
<li>5g + 特高压 + 轨道交通 + 充电桩 + AI + 大数据中心 + 工业互联网 + 元宇宙</li>
</ul>
</li>
</ol>
<h2 id="评估商业模式"><a href="#评估商业模式" class="headerlink" title="评估商业模式"></a>评估商业模式</h2><ul>
<li>商业模式环境 - 由外到内的影响</li>
<li>评估商业模式 - 由内到外</li>
</ul>
<h3 id="总体评估"><a href="#总体评估" class="headerlink" title="总体评估"></a>总体评估</h3><p>![image-20230214172225202](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230214172225202.png)</p>
<p><img src="https://gitee.com/duan-jifeng/code-imgs/raw/master/202211092202311.png" alt="img" loading="lazy"></p>
<h3 id="SWOT"><a href="#SWOT" class="headerlink" title="SWOT"></a>SWOT</h3><p>![image-20230214172656061](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230214172656061.png)</p>
<ul>
<li>优势&amp;劣势<ul>
<li>![image-20230214172904638](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230214172904638.png)</li>
<li>![image-20230214172932968](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230214172932968.png)</li>
<li>![image-20230214172941658](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230214172941658.png)</li>
<li>![image-20230214172950955](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230214172950955.png)</li>
</ul>
</li>
<li>威胁<ul>
<li><img src="/Users/effy/Downloads/IMG_3015.JPG" alt="IMG_3015" style="zoom: 25%;"  loading="lazy"/></li>
<li><img src="/Users/effy/Downloads/IMG_3016.JPG" alt="IMG_3015" loading="lazy"></li>
</ul>
</li>
<li>机会<ul>
<li><img src="/Users/effy/Downloads/IMG_3017.JPG" alt="IMG_3017" style="zoom:25%;"  loading="lazy"/></li>
<li><img src="/Users/effy/Downloads/IMG_3018.JPG" alt="IMG_3018" style="zoom:25%;"  loading="lazy"/></li>
</ul>
</li>
</ul>
<h2 id="蓝海战略"><a href="#蓝海战略" class="headerlink" title="蓝海战略"></a>蓝海战略</h2><ul>
<li><p>商业模式视角下的蓝海战略</p>
<ul>
<li>蓝海战略：通过根本性的差异化来创造全新的行业，而不是模仿现有商业模式在当前行业中竞争<ul>
<li>价值创新：不是在传统的绩效指标下超越对手，而是创造新的、未充分竞争的市场空间</li>
<li>画布的可视化效果为蓝海战略带来“全局化”的视角</li>
<li>通常还与开拓未被开发的客户群体相结合</li>
</ul>
</li>
<li>蓝海战略的“四项行动架构”（增加价值，减少成本）<ul>
<li>行业中哪些理所当然的要素应被删除</li>
<li>哪些要素应被大幅消减至行业标准以下</li>
<li>哪些要素应改被大幅调整到行业标准之上</li>
<li>哪些行业中从未提供的要素是应改被创造出来的</li>
</ul>
</li>
</ul>
</li>
<li><p>![image-20230211211323781](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230211211323781.png)</p>
</li>
<li><p>太阳马戏团</p>
<ul>
<li>![image-20230211205110080](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230211205110080.png)</li>
</ul>
</li>
<li><p>![image-20230211205542226](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230211205542226.png)</p>
</li>
<li><p>辩证地对待蓝海战略：必要性与风险</p>
<ul>
<li>蓝海战略的必要性：逃离“王慧文四杀”</li>
<li>（错误的）蓝海战略的风险：空心化、外部潮流与形势变更<ul>
<li>人类兴趣三年一小变五年一大变（过于探索客户-偏离）</li>
<li>（供应链）经济全球化带来的蝴蝶效应（过于探索成本-外包异常）</li>
<li>在一个有限的时间段内，产品与服务过于聚焦某个明星品类（过于探索客户与价值主张）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="商业模式管理"><a href="#商业模式管理" class="headerlink" title="商业模式管理"></a>商业模式管理</h2><ul>
<li>组织的艰巨任务：如何在实施和管理新商业模式的同时维持现有的商业模式<ul>
<li>将新商业模式剥离成一个独立的实体，或者成立独立的业务单元，或维持现状</li>
<li>拆分商业模式：基础服务、客户关系、新业务</li>
</ul>
</li>
<li>衡量是否拆分的双变量<ul>
<li>两种模式冲突的严重程度</li>
<li>战略上的相似性</li>
</ul>
</li>
<li>例子1：Swatch手表<ul>
<li>垂直整合：生产、研发、供货和HR集中管理，每一个品牌单独管理自己的产品、设计与营销</li>
</ul>
</li>
<li>例子2：雀巢公司的咖啡商业模式组合<ul>
<li>分拆：（由基础设施决定）Nescafe、Dolce Gusto、Nespresso三种产品在价值主张、客户关系、渠道通路、市场细分上完全不同</li>
</ul>
</li>
<li>例子3：戴姆勒的分阶段商业模式创新<ul>
<li>汽车公司开展共享汽车业务</li>
<li>阶段1：戴姆勒创新部门设计商业模式</li>
<li>阶段2：戴姆勒创新部门实地验证概念</li>
<li>阶段3：根据新商业模式与传统核心业务之间的关系决定采取何种组织结构（整合或剥离）</li>
</ul>
</li>
</ul>
<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><h2 id="需求工程的基本活动"><a href="#需求工程的基本活动" class="headerlink" title="需求工程的基本活动"></a>需求工程的基本活动</h2><ol>
<li>需求获取：系统原始需要<ul>
<li>研究应用环境，分析系统涉众，了解已有问题，建立系统目标，获取业务细节，生成用户需求</li>
</ul>
</li>
<li>需求分析：保证需求完整性与一致性（贯穿整个过程）<ul>
<li>将目标、功能与约束映射为系统行为，建立系统模型并分析（信息的细化与隐藏联系、假设的显示化），识别并修复不一致缺陷，发现并弥补遗漏的需求</li>
</ul>
</li>
<li>需求规约：将分析过的需求与系统行为明确并文档化<ul>
<li>自然语言+模型预言（UML）</li>
</ul>
</li>
<li>需求验证：保证需求分析的正确性、一致性、完整性<ul>
<li>最终产物为所有涉众一致同意的需求规约，是后续开发的基础</li>
</ul>
</li>
<li>需求管理：持续（时间、开发活动）管理需求基线<ul>
<li>跟踪后续阶段中的需求实现与变更，确保正确的理解与实现</li>
</ul>
</li>
</ol>
<ul>
<li>需求工程过程的并发和迭代性</li>
<li>实践方法的应用<ul>
<li>个人才智-&gt;实践方法-&gt;知识体系</li>
<li>需求工程师需要为组织或项目选择、定制和应用一些有效的实践方法</li>
</ul>
</li>
</ul>
<h2 id="确定项目前景和范围"><a href="#确定项目前景和范围" class="headerlink" title="确定项目前景和范围"></a>确定项目前景和范围</h2><ul>
<li>确定项目的前景与范围，就是确定项目的问题、目标、特性<ul>
<li>（业务需求）问题：组织的战略目标、利益分配、政策规划、业务流程等高层问题</li>
<li>目标：问题的反面，用户的期望</li>
<li>系统特性</li>
</ul>
</li>
</ul>
<h3 id="目标模型"><a href="#目标模型" class="headerlink" title="目标模型"></a>目标模型</h3><ul>
<li><p>目标的层次</p>
<ul>
<li>高层次：战略性的、全局的、业务相关，抽象的</li>
<li>低层次：技术性的、局部的、产品设计相关，具体的</li>
</ul>
</li>
<li><p>目标的分类</p>
<ul>
<li><p>软目标（云朵）和硬目标（矩形）</p>
<ul>
<li><p>能否利用技术手段确认是否满足</p>
</li>
<li><img src="/Users/effy/Library/Application Support/typora-user-images/image-20230214230840134.png" alt="image-20230214230840134" style="zoom: 50%;"  loading="lazy"/>
</li>
<li><img src="/Users/effy/Library/Application Support/typora-user-images/image-20230214230902387.png" alt="image-20230214230902387" style="zoom: 50%;"  loading="lazy"/></li>
</ul>
</li>
<li><p>目标规格的基本模式</p>
<ul>
<li>实现（Achieve）</li>
<li>终止（Cease）</li>
<li>保持（Maintain）</li>
<li>避免（Avoid）</li>
<li>优化（Optimize）：最大化（Maximize）和最小化（Minimize）</li>
</ul>
</li>
</ul>
</li>
<li><p>目标的关系</p>
<ol>
<li>目标精化<ol>
<li>AND精化关系：一系列子目标{G1,G2,…,Gn}的完成有助于目标G的完成。此时任意两子目标Gi和Gj之间是互补的</li>
<li>完备（Complete）AND精化关系：一系列子目标{G1,G2,…,Gn}的完成能够直接保证G的完成</li>
<li>OR精化关系：任一子目标Gi都是目标G替代方案。此时，任意两子目标Gi与Gj之间是互相替代的</li>
</ol>
</li>
<li>目标阻碍<ul>
<li>子目标O的达成会使得高层目标G失败</li>
<li><img src="/Users/effy/Library/Application Support/typora-user-images/image-20230214231901239.png" alt="image-20230214231901239" style="zoom: 33%;"  loading="lazy"/></li>
</ul>
</li>
<li>目标之间的支持（support）与冲突（conflict）<ol>
<li>Support链接表示一个目标对其他目标的支持作用<ol>
<li>支持关系可以被处理为OR精化关系</li>
</ol>
</li>
<li>Conflict链接表示一个目标的实现对其他目标的实现有阻碍作用</li>
</ol>
</li>
</ol>
</li>
<li><p>目标与主体关系</p>
<ul>
<li>Assignment链接表示为实现目标而需要参与主体<ul>
<li>OR Assignment：多个主体中的一个来完成</li>
<li>AND Assignment：多个主体一起共同完成</li>
<li>![image-20230214232747515](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230214232747515.png)</li>
</ul>
</li>
</ul>
</li>
<li><p>目标与操作关系</p>
<ul>
<li>AND Operationalization<ul>
<li>![image-20230214232947645](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230214232947645.png)</li>
</ul>
</li>
<li>OR Operationalization</li>
</ul>
</li>
<li><p>面向目标方法的处理过程</p>
<ul>
<li>高层目标的获取</li>
<li>低层目标的获取</li>
<li>目标分析：精化与分解<ul>
<li>![image-20230214233701914](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230214233701914.png)</li>
</ul>
</li>
<li>目标实现<ol>
<li>将最底层目标分配给主体（人+系统）<ul>
<li>![image-20230214233622194](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230214233622194.png)</li>
</ul>
</li>
<li>设计实现最底层目标的操作<ul>
<li>![image-20230214233920740](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230214233920740.png)</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="涉众分析"><a href="#涉众分析" class="headerlink" title="涉众分析"></a>涉众分析</h2><ul>
<li><p>涉众识别——主体（圆）依赖模型ADM（Actor Dependency Model）</p>
<ul>
<li>目标依赖（椭圆）：依赖者希望被依赖者满足一个条件，但不会规定怎么样满足该条件</li>
<li>软目标依赖（葫芦）：一类特殊类型的目标依赖，其条件是无法量化描述的</li>
<li>任务依赖（六边形）</li>
<li>资源依赖（正方形）</li>
<li>![image-20230215092536135](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230215092536135.png)</li>
</ul>
</li>
<li><p>涉众评估——Power-Interest模型</p>
<ul>
<li><p>基于特征化解举例：亲子兴趣班</p>
<ul>
<li><p>大人与小朋友一起参与：环境设定者（客户）-&gt; 参与者（用户）</p>
</li>
<li><p>良好的产品体验打造亲子品牌：被影响者（潜在用户&#x2F;客户） -&gt; 参与者</p>
</li>
</ul>
</li>
<li><p>![image-20230215093100042](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230215093100042.png)</p>
</li>
</ul>
</li>
<li><p>涉众共赢——Stakeholder&#x2F;Issue关系图</p>
<ul>
<li>列出系统的所有涉众类别，明确描述他们的兴趣和对系统的期望；</li>
<li>从涉众们的兴趣和期望中发现背后涉及的共同问题（Issue）；</li>
<li>建立涉众类别和问题的关联，如果某个涉众类别对一个Issue存在兴趣，那么该涉众类别和这个Issue就存在关联关系；</li>
<li>对每一个Stakeholder-Issue关系，标明该关系上面所被寄予的期望； </li>
<li>![image-20230215093855841](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230215093855841.png)</li>
</ul>
</li>
</ul>
<h2 id="需求获取方法"><a href="#需求获取方法" class="headerlink" title="需求获取方法"></a>需求获取方法</h2><h3 id="面谈"><a href="#面谈" class="headerlink" title="面谈"></a>面谈</h3><ul>
<li>问题类型<ul>
<li>开放式问题</li>
<li>封闭式问题</li>
</ul>
</li>
<li>问题设计<ul>
<li>前期<ul>
<li>以开放式问题为主</li>
<li>决策层与专家为主</li>
<li>遵循 问题-&gt;目标-&gt;解决方案路线</li>
<li>分析基本的涉众特点</li>
</ul>
</li>
<li>后期<ul>
<li>封闭式问题为主</li>
<li>抓住主体与线索<ul>
<li>如：任务分解、流程图、界面示意</li>
</ul>
</li>
<li>问题针对性</li>
<li>事先准备面谈记录材料</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>![image-20230215094755495](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230215094755495.png)</p>
<h3 id="观察"><a href="#观察" class="headerlink" title="观察"></a>观察</h3><ul>
<li>面谈：用户其实什么都知道，我们需要和他进行有效的沟通；原型：用户和我们都有一些不确定的地方，需要一些原型类的东西帮助我们理解，去消除不确定性；观察：有一些情况、场景、功能是通过面谈和原型方法所不能挖掘的，用户无法主动完成信息的告知</li>
</ul>
<h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><h3 id="概念类图"><a href="#概念类图" class="headerlink" title="概念类图"></a>概念类图</h3><p>![image-20230215100454732](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230215100454732.png)</p>
<h3 id="顺序图"><a href="#顺序图" class="headerlink" title="顺序图"></a>顺序图</h3><p>![image-20230215100527717](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230215100527717.png)</p>
<p>![image-20230215100652004](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230215100652004.png)</p>
<p>![image-20230215100706045](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230215100706045.png)</p>
<h3 id="状态图"><a href="#状态图" class="headerlink" title="状态图"></a>状态图</h3><p>![image-20230215100851111](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230215100851111.png)</p>
<p>![image-20230215101049893](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230215101049893.png)</p>
<h2 id="需求验证与管理"><a href="#需求验证与管理" class="headerlink" title="需求验证与管理"></a>需求验证与管理</h2><h3 id="需求验证"><a href="#需求验证" class="headerlink" title="需求验证"></a>需求验证</h3><ul>
<li><p>需求验证方法</p>
<ul>
<li><p>评审</p>
<ul>
<li>由作者之外的其他人来检查产品问题的方法</li>
<li>是主要的静态分析手段</li>
<li>原则上，每一条需求都应该进行评审</li>
</ul>
</li>
<li><p>原型与模拟</p>
<ul>
<li>涉及到复杂的动态行为时</li>
<li>成本较高</li>
</ul>
</li>
<li><p>开发测试用例</p>
<ul>
<li>![image-20230215101726913](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230215101726913.png)</li>
<li>![image-20230215101714730](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230215101714730.png)</li>
</ul>
</li>
<li><p>用户手册编制</p>
</li>
<li><p>利用跟踪关系</p>
</li>
<li><p>自动化分析</p>
</li>
</ul>
</li>
</ul>
<h3 id="需求管理"><a href="#需求管理" class="headerlink" title="需求管理"></a>需求管理</h3><ul>
<li>任务<ul>
<li>交流涉众需要什么；</li>
<li>将需求应用、实施到解决方案；</li>
<li>驱动设计和实现工作；</li>
<li>控制变更；</li>
<li>将需求分配到子系统；</li>
<li>测试和验证最终产品；</li>
<li>控制迭代式开发中的变化；</li>
<li>辅助项目管理</li>
</ul>
</li>
<li>活动<ul>
<li>![image-20230215101920674](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230215101920674.png)</li>
</ul>
</li>
</ul>
<h3 id="需求变更控制"><a href="#需求变更控制" class="headerlink" title="需求变更控制"></a>需求变更控制</h3><ul>
<li>过程<ul>
<li>![image-20230215102036878](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230215102036878.png)</li>
</ul>
</li>
<li>组织——变更控制委员会（CCB）<ul>
<li><strong>项目或程序管理部门；</strong></li>
<li><strong>产品管理或者需求分析部门；</strong></li>
<li>开发部门；</li>
<li><strong>测试或者质量保障部门；</strong></li>
<li>市场或客户代表；</li>
<li>编写用户文档的部门；</li>
<li>技术支持或帮助部门；</li>
<li><strong>配置管理部门。</strong></li>
</ul>
</li>
<li>注意事项<ol>
<li>认识到变更的必要性，并为之制定计划</li>
<li>维护需求基线，审计变更记录</li>
<li>管理范围蔓延</li>
<li>灵活应对变更请求</li>
<li>使用辅助工具</li>
</ol>
</li>
</ul>
<h1 id="考试重点"><a href="#考试重点" class="headerlink" title="考试重点"></a>考试重点</h1><h2 id="商业模式部分期末考核（50分）"><a href="#商业模式部分期末考核（50分）" class="headerlink" title="商业模式部分期末考核（50分）"></a>商业模式部分期末考核（50分）</h2><ul>
<li><p>商业模式画布绘制+需求类型（20分）</p>
</li>
<li><p>商业模式类型讨论（10分）</p>
<ul>
<li>五种类型都有可能，优先考察与互联网最相关的三个</li>
</ul>
</li>
<li><p>商业模式设计（10分）</p>
<ul>
<li>六种设计手段选一个考核</li>
</ul>
</li>
<li><p>商业模式评估（10分）</p>
<ul>
<li>四种评估手段选一个考核（复杂的手段会被适当地提示和约减）</li>
</ul>
</li>
</ul>
<h2 id="需求部分期末考核（50分）"><a href="#需求部分期末考核（50分）" class="headerlink" title="需求部分期末考核（50分）"></a>需求部分期末考核（50分）</h2><ul>
<li><p>需求获取（30分）</p>
<ul>
<li>需求获取上半段（20分）<ul>
<li>确定项目前景与范围（10分） - 目标模型</li>
<li>涉众分析（10分） - 涉众识别之ADM模型、涉众评估之Power-Interest模型、涉众共赢之Stakeholder-Issue模型</li>
</ul>
</li>
<li>需求获取下半段（10分）<ul>
<li>面谈、原型、观察三大获取手段的联系与区别，面谈问题的设计<ul>
<li>面谈：用户其实什么都知道，我们需要和他进行有效的沟通；原型：用户和我们都有一些不确定的地方，需要一些原型类的东西帮助我们理解，去消除不确定性；观察：有一些情况、场景、功能是通过面谈和原型方法所不能挖掘的，用户无法主动完成信息的告知</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>需求分析（10分）</p>
<ul>
<li>需求分析基本任务（没有能考的）</li>
<li>基于UML软件建模的需求细化 - 概念类图、顺序图、状态图</li>
</ul>
</li>
<li><p>需求验证与管理（10分）</p>
<ul>
<li>需求验证基本活动<ul>
<li>验证的六个手段（除自动化分析）</li>
</ul>
</li>
<li>需求管理任务与活动，需求变更控制过程、组织与注意事项</li>
</ul>
</li>
<li><p>TIPS</p>
<ul>
<li><p>考长尾模式</p>
</li>
<li><p>概念类图和领域模型一样</p>
</li>
</ul>
</li>
</ul>
<h1 id="往年试卷"><a href="#往年试卷" class="headerlink" title="往年试卷"></a>往年试卷</h1><h2 id="2021"><a href="#2021" class="headerlink" title="2021"></a>2021</h2><p>背景材料是蔚来电动车。</p>
<ol>
<li>分析的蔚来电动车商业模式，并画出商业模式画布，写出约束三大来源+本系统的一条约束需求（内容标号，不要直接写在画布里，20分）</li>
<li>对比传统车和用户，分析蔚来电动车体现何种商业模式，该商业模式有什么特点（10分）</li>
<li>App内商城的题面，对客户的讲故事和场景有什么区别？给出一个场景，并阐述为什么适用（10分）</li>
<li>对蔚来电动车的商业模式进行环境评估（不需要打分，概要评估即可，10分）</li>
<li>结合蔚来电动车的车友社区，进行目标分析（尽可能多地使用目标分析的元素，10分）</li>
<li>使用stakeHolder&#x2F;issue模型进行共赢分析（10分）</li>
<li>面谈问题的两大类型，和一个传统燃油车用户面谈，探讨服务和？让这些客户选择电动车，构思一个问题列表（10分）</li>
<li>简述需求管理的三种方法和管理变更的五大原则（10分）</li>
<li>蔚来电动车有一系列的升级（类似）规则，根据规则画出状态图（10分）</li>
</ol>
<h2 id="2020"><a href="#2020" class="headerlink" title="2020"></a>2020</h2><p>规模越来越⼤、投资⼈很多很富、有⾏业⼤佬、⾯向上班族和⼩区居⺠、店⾯⼀线城市在商圈⼆线城市，在社区、提供热⻝、提供个性化产品、与知名 IP 和品牌联动、有数据系统⾃助结账和经营策略制定等</p>
<ol>
<li><p>（ 20 分）根据材料画商业模式画布及各部分元素。写出⼀个“约束”需求</p>
</li>
<li><p>（ 10 分）属于哪个商业模式？这个模式有什么要点？再结合材料谈谈</p>
</li>
<li><p>（ 10 分）从公司和客户的⻆度分别讲⼀个故事</p>
</li>
<li><p>（ 10 分）SWOT 评估包括哪些要点？结合材料和画布⾥的每个元素，简要分析，不需打分</p>
</li>
<li><p>（ 10 分）想要在 2021 年⼤规模扩张，画出⽬标模型</p>
</li>
<li><p>（ 10 分）有店员因为数学不好⽽离职，⽼店⻓认为计算机不能代替⼈类决策；通过实验证明数据模型更有效；⽼店⻓培养新店⻓；减少店员数量，增加店员收⼊。结合材料，⽤ stakeholderissue模型进⾏涉众共赢分析</p>
</li>
<li><p>（ 10 分）想搞社区团购，有个⼈懂，并且还会直播带货。需求获取有哪三个⽅法？结合材料谈如何需求获取</p>
</li>
<li><p>（ 10 分）让你做⼩程序和 APP ，需求管理包括哪些要点？结合着谈谈</p>
</li>
<li><p>（ 10 分）买优惠券包、查看优惠券、优惠券包退款、优惠券包过期换积分。画出⽤例的系统顺序图</p>
</li>
</ol>
<h2 id="2019"><a href="#2019" class="headerlink" title="2019"></a>2019</h2><p>背景材料是新浪微博。</p>
<ol>
<li>分析微博的商业模式，并画出商业模式画布（内容标号，不要直接写在画布里，20分）</li>
<li>分析微博如何体现多边平台商业模式的特点，并指出微博存在的问题（10分）</li>
<li>对微博的普通用户进行客户洞察，主要特点是想要进行社交和追踪时事热点（10分）</li>
<li>对微博的商业模式进行SWOT评估（不需要打分，概要评估即可，10分）</li>
<li>结合微博存在的问题，进行目标分析（尽可能多地使用目标分析的元素，10分）</li>
<li>使用power-interest和power-attitude模型，阐述如何化解微博的涉众风险（10分）</li>
<li>假设你想要开发直播带货，结合三种需求获取方法，简述你将如何进行需求获取（10分）</li>
<li>简述需求管理的三种方法和流程（10分）</li>
<li>微博有一系列的封号规则，根据规则画出状态图（10分）</li>
</ol>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>需求与商业模式创新</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL</title>
    <url>/2023/03/07/somethingAboutDB/</url>
    <content><![CDATA[<h1 id="drop、delete和truncate区别"><a href="#drop、delete和truncate区别" class="headerlink" title="drop、delete和truncate区别"></a>drop、delete和truncate区别</h1><ol>
<li><p>用法不同</p>
<ul>
<li>drop（丢弃数据）：drop table 表名，直接删除整张表，在删除表的时候使用</li>
<li>truncate（清空数据）：truncate table 表名，只删除表中的数据，再插入数据的时候自增长id从1开始，在清空表中数据的时候使用</li>
<li>delete（删除数据）：delete from 表名 where 列名&#x3D;值，删除某一行的数据，如果不加where子句和truncate table 表名作用类似</li>
</ul>
<p>truncate和不带where子句的delete、以及drop都会删除表内的数据，但是truncate和delete只删除数据不删除表的定义，执行drop语句，此表的定义和结构也会删除，即drop之后对应的表不存在。</p>
</li>
</ol>
<h1 id="SQL语句分类"><a href="#SQL语句分类" class="headerlink" title="SQL语句分类"></a>SQL语句分类</h1><h2 id="数据定义语言（DDL）"><a href="#数据定义语言（DDL）" class="headerlink" title="数据定义语言（DDL）"></a>数据定义语言（DDL）</h2><p>数据定义语言（Data Definition Language，DDL）是SQL语言集中负责数据结构定义与数据库对象定义的语言。</p>
<p>DDL的主要功能是定义数据库对象，其核心指令包括CREATE、ALTER、DROP</p>
<h2 id="数据操纵语言（DML）"><a href="#数据操纵语言（DML）" class="headerlink" title="数据操纵语言（DML）"></a>数据操纵语言（DML）</h2><h2 id="事务控制语言（TCL）"><a href="#事务控制语言（TCL）" class="headerlink" title="事务控制语言（TCL）"></a>事务控制语言（TCL）</h2><h2 id="数据控制语言（DCL）"><a href="#数据控制语言（DCL）" class="headerlink" title="数据控制语言（DCL）"></a>数据控制语言（DCL）</h2>]]></content>
      <categories>
        <category>八股</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合的常用方法</title>
    <url>/2023/03/09/JavaCollection/</url>
    <content><![CDATA[<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/collection/java-collection-hierarchy.png" loading="lazy"></p>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//save without order</span></span><br><span class="line">HashMap&lt;Integer,String&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//put a new key-value entry if not existing before;</span></span><br><span class="line"><span class="comment">//replace the old value if existing such a key;</span></span><br><span class="line"><span class="comment">//return the old value or null if not existing</span></span><br><span class="line">hashMap.put(<span class="number">1</span>,<span class="string">&quot;my value is 1&quot;</span>);</span><br><span class="line"><span class="comment">//put a new entry only if there was no such key before</span></span><br><span class="line">hashMap.putIfAbsent(<span class="number">1</span>,<span class="string">&quot;my value is 1&quot;</span>);</span><br><span class="line">hashMap.remove(<span class="number">1</span>); <span class="comment">//remove the entry whose key is 1</span></span><br><span class="line">hashMap.remove(<span class="number">1</span>,<span class="string">&quot;my value is 2&quot;</span>); <span class="comment">//remove the entry whose key is 1 and value is &quot;my value is 2&quot;</span></span><br><span class="line">hashMap.get(<span class="number">1</span>); <span class="comment">//return the value whose key is 1</span></span><br><span class="line">hashMap.containsKey(<span class="number">1</span>);</span><br><span class="line">hashMap.containsValue(<span class="string">&quot;whose value is 2&quot;</span>);</span><br><span class="line">hashMap.forEach((key1, value1) -&gt; &#123;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//save with order</span></span><br><span class="line">TreeMap&lt;Integer,String&gt; treeMap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;((a,b)-&gt;&#123;</span><br><span class="line">      <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//save without order</span></span><br><span class="line">HashSet&lt;Integer&gt; integerSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"><span class="type">boolean</span> <span class="variable">addReturn</span> <span class="operator">=</span>  integerSet.add(<span class="number">1</span>); <span class="comment">// true if set doesn&#x27;t contain target</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">containReturn</span> <span class="operator">=</span>  integerSet.contains(<span class="number">3</span>); <span class="comment">// true if set contains target</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">removeReturn</span> <span class="operator">=</span> integerSet.remove(<span class="number">4</span>);  <span class="comment">// true if set contains target</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEmptyReturn</span> <span class="operator">=</span>  integerSet.isEmpty();   <span class="comment">// true if set is empty</span></span><br><span class="line"><span class="comment">//save with order, and you can define your specific comparator using lambda expression</span></span><br><span class="line">TreeSet&lt;Integer&gt; integerTreeSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;((a,b)-&gt;&#123;</span><br><span class="line">     <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedList&lt;Integer&gt; linkedList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="type">Integer</span> <span class="variable">temp</span> <span class="operator">=</span> linkedList.indexOf(<span class="number">2</span>); <span class="comment">//return the index of target object if exists else return false</span></span><br><span class="line">linkedList.remove((Object) <span class="number">2</span>); <span class="comment">//remove the object 2</span></span><br><span class="line">linkedList.remove(<span class="number">2</span>);<span class="comment">//remove the element whose index is 2</span></span><br><span class="line"><span class="comment">//Queue operations: add from tail and get from head, FIFO</span></span><br><span class="line">linkedList.offer(<span class="number">1</span>);    <span class="comment">// add target from tail</span></span><br><span class="line">temp = linkedList.peek(); <span class="comment">//simply return the head element of the list</span></span><br><span class="line">temp = linkedList.poll(); <span class="comment">//return the head element of the list and remove it</span></span><br><span class="line"><span class="comment">//Deque operations: add and get from both ends</span></span><br><span class="line">linkedList.offerFirst(<span class="number">1</span>); <span class="comment">//add from first</span></span><br><span class="line">linkedList.offerLast(<span class="number">2</span>);  <span class="comment">//add from last</span></span><br><span class="line">temp = linkedList.peekFirst();  <span class="comment">//peek from first</span></span><br><span class="line">temp = linkedList.peekLast();   <span class="comment">//peek from last</span></span><br><span class="line">temp = linkedList.pollFirst();  <span class="comment">//poll from first</span></span><br><span class="line">temp = linkedList.pollLast();   <span class="comment">//poll from last</span></span><br><span class="line">Collections.sort(linkedList);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Stack operations:add and get from the same end, LIFO</span></span><br><span class="line">Stack&lt;Integer&gt; intStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">intStack.push(<span class="number">1</span>);   <span class="comment">//push the target onto the stack</span></span><br><span class="line">intStack.push(<span class="number">2</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> intStack.pop();  <span class="comment">//return the element at the top of the stack and remove that element</span></span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> intStack.peek(); <span class="comment">//return the element at the top of the stack</span></span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> intStack.search(<span class="number">2</span>);   <span class="comment">//return the index of target object if it&#x27;s in the stack else return -1</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEmpty</span> <span class="operator">=</span> intStack.isEmpty(); <span class="comment">//return true if stack is empty else return false</span></span><br></pre></td></tr></table></figure>

<h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//this is a max heap</span></span><br><span class="line">PriorityQueue&lt;Integer&gt; priorityQueue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b)-&gt;&#123;</span><br><span class="line">      <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;);</span><br><span class="line">priorityQueue.offer(<span class="number">1</span>); <span class="comment">//insert the target</span></span><br><span class="line">priorityQueue.peek(); <span class="comment">//return the max/min element decided by its type</span></span><br><span class="line">priorityQueue.poll(); <span class="comment">//return the max/min element and remove it</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java的Array和List之间的转换</title>
    <url>/2023/03/10/array2List/</url>
    <content><![CDATA[<h1 id="List2Array"><a href="#List2Array" class="headerlink" title="List2Array"></a>List2Array</h1><h2 id="使用for循环"><a href="#使用for循环" class="headerlink" title="使用for循环"></a>使用for循环</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;bb&quot;</span>,<span class="string">&quot;cc&quot;</span>));</span><br><span class="line">String [] array = <span class="keyword">new</span> <span class="title class_">String</span>[list.size()];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    array[i] = list.get(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用toArray方法"><a href="#使用toArray方法" class="headerlink" title="使用toArray方法"></a>使用toArray方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;bb&quot;</span>,<span class="string">&quot;cc&quot;</span>));</span><br><span class="line"> String [] array = list.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>

<ul>
<li>传入的参数<code>new String[0]</code>仅用于传递array参数类型是什么，因此长度可以为0</li>
<li>如果不传入参数，则转化后的array类型为<code>Object[]</code></li>
</ul>
<h1 id="Array2List"><a href="#Array2List" class="headerlink" title="Array2List"></a>Array2List</h1><h2 id="使用for方法"><a href="#使用for方法" class="headerlink" title="使用for方法"></a>使用for方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String [] array = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;bb&quot;</span>,<span class="string">&quot;cc&quot;</span>&#125;;</span><br><span class="line"> List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">   list.add(array[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用asList方法"><a href="#使用asList方法" class="headerlink" title="使用asList方法"></a>使用asList方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> String [] array = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;bb&quot;</span>,<span class="string">&quot;cc&quot;</span>&#125;;</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(array));</span><br></pre></td></tr></table></figure>

<ul>
<li><p>需要注意<code>Arrays.asList</code>返回的<code>list</code>是大小固定的，是定义在<code>java.util.Arrays</code>中的一个私有静态类，不同于常用的<code>java.util.ArrayList</code>类</p>
</li>
<li><p>阅读其源码发现该私有静态类并并没有<code>add</code>和<code>remove</code>方法，因此不支持增删元素，只支持<code>get</code>和<code>set</code>改查元素</p>
</li>
</ul>
<h2 id="使用Collections-addAll方法"><a href="#使用Collections-addAll方法" class="headerlink" title="使用Collections.addAll方法"></a>使用Collections.addAll方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String [] array = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;bb&quot;</span>,<span class="string">&quot;cc&quot;</span>&#125;;</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(array.length);</span><br><span class="line">Collections.addAll(list,array);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程(2)</title>
    <url>/2023/03/08/JavaConcurrent2/</url>
    <content><![CDATA[<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><h2 id="ThreadLocal有什么用"><a href="#ThreadLocal有什么用" class="headerlink" title="ThreadLocal有什么用"></a>ThreadLocal有什么用</h2><ul>
<li>实现每个线程都有自己的专属本地变量，让每个线程绑定自己的值</li>
</ul>
<h2 id="如何使用ThreadLocal"><a href="#如何使用ThreadLocal" class="headerlink" title="如何使用ThreadLocal"></a>如何使用ThreadLocal</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">            threadLocal.set(<span class="string">&quot;This is in main thread&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread Name: &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;---&quot;</span> + threadLocal.get());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Thread A</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                    threadLocal.set(<span class="string">&quot;This is in A thread&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread Name: &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;---&quot;</span> + threadLocal.get());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Thread B</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                threadLocal.set(<span class="string">&quot;This is in B thread&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread Name: &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;---&quot;</span> + threadLocal.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Thread C</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                threadLocal.set(<span class="string">&quot;This is in C thread&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread Name: &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;---&quot;</span> + threadLocal.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ThreadLocal原理"><a href="#ThreadLocal原理" class="headerlink" title="ThreadLocal原理"></a>ThreadLocal原理</h2><ul>
<li><code>Thread</code>类的源码<ul>
<li>持有<code>threadLocals</code>和<code>inheritableThreadLocals</code>两个变量，它们是<code>ThreadLocalMap</code>类型的</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">  <span class="comment">//用于维护该线程的threadLocal</span></span><br><span class="line">	ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">inheritableThreadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ThreadLocal</code>类的<code>set()</code>方法<ul>
<li>可以看出<code>ThreadLocal</code>类其实是对<code>ThreadLocalMap</code>的封装，传入的值最终会放在<code>Thread</code>类里的<code>threadLocals</code>这个变量里</li>
<li><code>threadLocals</code>这个变量是<code>ThreadLocalMap</code>类型的，其中<code>ThreadLocalMap</code>又是<code>ThreadLocal</code>类的一个静态类（这里比较绕）</li>
<li>最终<code>Thread</code>类的<code>threadLocals</code>里存放的是以<code>&lt;ThreadLocal, Object&gt;</code>的键值对</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span>&#123;</span><br><span class="line">  <span class="comment">//获取当前线程</span></span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">  <span class="comment">//获取当前线程的threadlocals变量</span></span><br><span class="line">  <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">  <span class="keyword">if</span>(map != <span class="literal">null</span>)</span><br><span class="line">    map.set(<span class="built_in">this</span>,value); <span class="comment">//存放进去，这里的this就是这个ThreadLocal对象</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    createMap(t,value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>一个线程可以有多个<code>ThreadLocal</code>实例，声明多个<code>ThreadLocal</code>变量即可，它们都存放在<code>Tread</code>类的<code>threadLocals</code>变量里，并以<code>ThreadLocal</code>的实例为键名取出对应的副本值</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>ThreadLocal</code>实现了对私有变量的封装，我们可以不用直接对<code>Thread</code>的<code>ThreadLocalMap</code>进行操作，而只需像对待共享变量一样操作私有变量即可，因为封装在<code>ThreadLocal</code>里的方法会帮我们从对应的<code>Thread</code>类的<code>threadLocals</code>变量里获取或更改这个变量的值，其中<code>threadLocals</code>变量是<code>ThreadLocalMap</code>类型的，存放的是<code>&lt;ThreadLocal, Object&gt;</code>的键值对，<code>ThreadLocal</code>的实例以自身为键名访问线程的<code>treadLocals</code>变量以获得该私有变量在该线程下的副本值</p>
<h2 id="ThreadLocal内存泄漏问题是怎么导致的"><a href="#ThreadLocal内存泄漏问题是怎么导致的" class="headerlink" title="ThreadLocal内存泄漏问题是怎么导致的"></a>ThreadLocal内存泄漏问题是怎么导致的</h2><ul>
<li><code>ThreadLocalMap</code>中使用的key值为<code>ThreadLocal</code>的弱引用，而value是强引用</li>
<li>如果<code>ThreadLocal</code>没有外部强引用的情况下，在垃圾回收的时候，key会被清理掉而value不会</li>
<li><code>ThreadLocalMap</code>中会出现key为null的Entry，如果我们不做任何措施的话，value就无法被GC回收，因此会产生内存泄漏</li>
<li><code>ThreadLocalMap</code>实现中考虑了该情况，在调用<code>set</code>、<code>get</code>、<code>remove</code>方法时会清理掉key为null的记录，但是用了玩<code>ThreadLocal</code>方法后最好手动调用<code>remove</code>方法</li>
</ul>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="什么是线程池"><a href="#什么是线程池" class="headerlink" title="什么是线程池"></a>什么是线程池</h2><p>线程池是管理一系列线程的资源池。当有任务要处理时，直接从线程池获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务</p>
<h2 id="为什么要用线程池"><a href="#为什么要用线程池" class="headerlink" title="为什么要用线程池"></a>为什么要用线程池</h2><ul>
<li><p>池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率</p>
</li>
<li><p>线程池提供了一种限制和管理资源（包括执行一个任务）的方式，每个线程池还维护一些基本统计信息</p>
</li>
<li><p>使用线程池的好处：</p>
<ul>
<li><p>降低资源消耗</p>
</li>
<li><p>提高响应速度</p>
</li>
<li><p>提高线程的可管理性</p>
</li>
<li><p>提供更多更强大的功能</p>
</li>
</ul>
</li>
</ul>
<h2 id="如何创建线程池"><a href="#如何创建线程池" class="headerlink" title="如何创建线程池"></a>如何创建线程池</h2><ol>
<li>通过<code>ThreadPoolExecutor</code>构造函数来创建（推荐）</li>
<li>通过Java内置<code>Executor</code>框架的工具类<code>Executors</code>来创建（不推荐）<ul>
<li><strong><code>FixedThreadPool</code></strong> ： 该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li>
<li><strong><code>SingleThreadExecutor</code>：</strong> 该方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li>
<li><strong><code>CachedThreadPool</code>：</strong> 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</li>
<li><strong><code>ScheduledThreadPool</code></strong> ：该返回一个用来在给定的延迟后运行任务或者定期执行任务的线程池</li>
</ul>
</li>
</ol>
<h2 id="为什么不推荐使用内置线程池"><a href="#为什么不推荐使用内置线程池" class="headerlink" title="为什么不推荐使用内置线程池"></a>为什么不推荐使用内置线程池</h2><p>《阿里巴巴Java开发手册》中不允许使用<code>Executors</code>创建，而是通过<code>ThreadPoolExecutor</code>构造函数的方式，这样让<strong>写的同学更加明确线程池的运行规则，规避资源耗尽的风险</strong></p>
<p><code>Executors</code>返回的线程池对象的弊端如下：</p>
<ul>
<li><strong><code>FixedThreadPool</code> 和 <code>SingleThreadExecutor</code></strong> ： 使用的是无界的 <code>LinkedBlockingQueue</code>，任务队列最大长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li>
<li><strong><code>CachedThreadPool</code></strong> ：使用的是同步队列 <code>SynchronousQueue</code>, 允许创建的线程数量为 <code>Integer.MAX_VALUE</code> ，可能会创建大量线程，从而导致 OOM。</li>
<li><strong><code>ScheduledThreadPool</code> 和 <code>SingleThreadScheduledExecutor</code></strong> : 使用的无界的延迟阻塞队列<code>DelayedWorkQueue</code>，任务队列最大长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li>
</ul>
<h2 id="线程池常见参数有哪些"><a href="#线程池常见参数有哪些" class="headerlink" title="线程池常见参数有哪些"></a>线程池常见参数有哪些</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用给定的初始参数创建一个新的ThreadPoolExecutor。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,//线程池的核心线程数量</span></span><br><span class="line"><span class="params">                              <span class="type">int</span> maximumPoolSize,//线程池的最大线程数</span></span><br><span class="line"><span class="params">                              <span class="type">long</span> keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span></span><br><span class="line"><span class="params">                              TimeUnit unit,//时间单位</span></span><br><span class="line"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,//任务队列，用来储存等待执行任务的队列</span></span><br><span class="line"><span class="params">                              ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可</span></span><br><span class="line"><span class="params">                              RejectedExecutionHandler handler//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span></span><br><span class="line"><span class="params">                               )</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">            keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        <span class="keyword">if</span> (workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">        <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">        <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">        <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">        <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">        <span class="built_in">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>3个最重要的参数<ul>
<li>corePoolSize：任务队列未达到队列容量时，最大可以同时运行的线程数量</li>
<li>maximumPoolSize：任务队列达到队列容量时，当前可以同时运行的线程数量变为最大线程数</li>
<li>workQueue：新任务来的时候先判断当前运行的线程数量是否达到核心线程数，如果达到则新任务会被存放在队列中</li>
</ul>
</li>
<li>其他常见参数<ul>
<li>keepAliveTime：线程池中的线程数量大于corePoolSize的时候，如果没有新的任务提交，核心线程外的线程不会被立即销毁，待等待时间超过该参数后才会被回收销毁</li>
<li>unit：keepAliveTime参数的时间单位</li>
<li>threadFactory：executor创建新县城的时候用到</li>
<li>handler：饱和策略</li>
</ul>
</li>
</ul>
<h2 id="线程池的饱和策略有哪些"><a href="#线程池的饱和策略有哪些" class="headerlink" title="线程池的饱和策略有哪些"></a>线程池的饱和策略有哪些</h2><p><img src="https://p0.meituan.net/travelcube/9ffb64cc4c64c0cb8d38dac01c89c905178456.png" loading="lazy"></p>
<h2 id="线程池常用的阻塞队列有哪些"><a href="#线程池常用的阻塞队列有哪些" class="headerlink" title="线程池常用的阻塞队列有哪些"></a>线程池常用的阻塞队列有哪些</h2><p>新任务到达时会先判断当前运行的线程数量是否达到核心线程数，如果达到则新任务会被存放在队列中</p>
<p>不同的线程池会选用不同的阻塞队列</p>
<ul>
<li>容量为Intger.MAX_VALUE的LinkedBlockingQueue（无界队列）：FixedThreadPool和SingleThreadExector。由于队列永远不会被放满，因此FixesThreadPool最多只能创建核心线程数的线程</li>
<li>SychronousQueue(同步队列)：CachedThreadPool。SynchronousQueue没有容量，不存储新元素，目的是保证对于提交的任务，如果有空闲线程，则使用空闲线程来处理，否则就新建一个线程来处理任务，也就是说CachedThreadPool的最大线程数是Integer.MAX_VALUE，可以理解为线程数是可以无限扩展的，可能会创建大量线程，从而导致OOM</li>
<li>DelayedWorkQueue（延迟阻塞队列）：ScheduledThreadPool和SIngleThreadScheduledExecutor。DelayedWorkQueue的内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是堆的数据结构，可以保证每次出队的任务是当前队列中执行时间最靠前的。DelayedWorkQueue添加元素满了之后会自动扩容到原来容量的1&#x2F;2，即永远不会阻塞，最大扩容可达Integer.MAX_VALUE，所以最多只能创建核心线程数的线程</li>
</ul>
<p><img src="https://p0.meituan.net/travelcube/725a3db5114d95675f2098c12dc331c3316963.png" loading="lazy"></p>
<h2 id="线程池处理任务的流程"><a href="#线程池处理任务的流程" class="headerlink" title="线程池处理任务的流程"></a>线程池处理任务的流程</h2><p><img src="https://p0.meituan.net/travelcube/31bad766983e212431077ca8da92762050214.png" loading="lazy"></p>
<h2 id="如何给线程池命名"><a href="#如何给线程池命名" class="headerlink" title="如何给线程池命名"></a>如何给线程池命名</h2><p>给线程池命名有利于定位问题</p>
<ol>
<li><p>利用guava的ThreadFactoryBuilder</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ThreadFactory</span> <span class="variable">threadFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadFactoryBuilder</span>().setNameFormat(threadNamePrefix + <span class="string">&quot;-%d&quot;</span>).setDaemon(<span class="literal">true</span>).build();</span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(corePoolSize,maximumPoolSize,KeepAliveTime,TimeUnit.MINUTES,workQueue,threadFactory);</span><br></pre></td></tr></table></figure>
</li>
<li><p>自己实现ThreadFactory</p>
</li>
</ol>
<h2 id="如何设定线程池的大小"><a href="#如何设定线程池的大小" class="headerlink" title="如何设定线程池的大小"></a>如何设定线程池的大小</h2><p>判断是CPU密集型任务（N+1）还是I&#x2F;O密集型任务（2N）</p>
<p>线程数计算方法：N（CPU核数）* （线程运行总时间&#x2F;ST（线程计算时间））</p>
<h2 id="如何动态修改线程池的参数"><a href="#如何动态修改线程池的参数" class="headerlink" title="如何动态修改线程池的参数"></a>如何动态修改线程池的参数</h2><p>配置三个核心参数：</p>
<ul>
<li><p>corePoolSize：调用setCorePoolSize()方法</p>
<p><img src="https://p0.meituan.net/travelcube/9379fe1666818237f842138812bf63bd85645.png" loading="lazy"></p>
</li>
<li><p>maximumPoolSize：调用setMaximumPoolSize()方法</p>
</li>
<li><p>workQueue：美团通过自定义一个ResizableCapacityLinkedBlockIngQueue的队列，主要是为了把LinkedBlockingQueue的capacity字段的final关键字去掉</p>
</li>
</ul>
<h2 id="线程池被创建后里面有线程吗？"><a href="#线程池被创建后里面有线程吗？" class="headerlink" title="线程池被创建后里面有线程吗？"></a>线程池被创建后里面有线程吗？</h2><p>线程池被创建后如果没有任务过来，里面是不会有线程的</p>
<p>如果需要预热的话可以调用下面两个方法：</p>
<ul>
<li><p><code>prestartAllCoreThreads</code>：全部启动	</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/lnCqjsQ6QHfBqOxop3hDOhKCOm6v4MXYvdzS6VCjKicoib5eGJgeW9wPEnt9Zk1YEspKYaVPI5ZEqlibCWQ7Rofdw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" loading="lazy"></p>
</li>
<li><p><code>preastartCoreThread</code>：仅启动一个</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/lnCqjsQ6QHfBqOxop3hDOhKCOm6v4MXYQUPFNiaw7bjF5RsHSkAib2HE9vlNq2R6dN4U5OicOcLJ29ZvotUm3jdGA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" loading="lazy"></p>
</li>
</ul>
<h2 id="核心线程会被回收吗"><a href="#核心线程会被回收吗" class="headerlink" title="核心线程会被回收吗"></a>核心线程会被回收吗</h2><p>核心线程默认是不会被回收的，如果需要回收核心线程数，需要调用：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/lnCqjsQ6QHfBqOxop3hDOhKCOm6v4MXYVTBfSHpeUKaRL64ZwrN6sAMMsPD3XvILspTG405TMIgPtTiaV84fexQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" loading="lazy"></p>
<p>其中<code>allowCoreThreadTimeOut</code>该值默认为false</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/lnCqjsQ6QHfBqOxop3hDOhKCOm6v4MXYOedP5u7d1L7oQpsvCq73M9hII5zoZmEnxZpHgK396mytTY4qEkiaibaw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" loading="lazy"></p>
<h1 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h1><h2 id="Future类有什么用"><a href="#Future类有什么用" class="headerlink" title="Future类有什么用"></a>Future类有什么用</h2><p>当主线程执行某一耗时任务时，可以将该耗时任务交给一个子线程去异步执行，主线程可以继续执行后续的任务，再通过<code>Future</code>类获取到耗时任务的执行结果，使得程序的执行效率获得明显提高</p>
<p>这是多线程中的一种设计模式，即<strong>Future模式</strong>，核心思想是<strong>异步调用</strong></p>
<p>Java中<code>Future</code>类只是一个泛型接口，位于<code>java.util.concurrent</code>包下，定义了5个方法，包括4个功能</p>
<ul>
<li>取消任务</li>
<li>判断任务是否被取消</li>
<li>判断任务是否已经执行完成</li>
<li>获取任务执行结果</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Future</span>&lt;V&gt;&#123;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span>;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">isCancelled</span><span class="params">()</span>;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span>;</span><br><span class="line">  V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line">  V <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException,TimeoutException</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Callable和Future有什么关系"><a href="#Callable和Future有什么关系" class="headerlink" title="Callable和Future有什么关系"></a>Callable和Future有什么关系</h2><h2 id="CompletableFuture类有什么用"><a href="#CompletableFuture类有什么用" class="headerlink" title="CompletableFuture类有什么用"></a>CompletableFuture类有什么用</h2><p><code>CompletableFuture</code>提供函数式编程、异步任务编排组合（可以将多个异步任务串联起来，组成一个完整的链式调用）等能力</p>
<p>人话：CompletableFuture支持添加回掉函数，即子线程执行完成后自行调用后续回掉函数，而不需要像Future类需要主线程去询问其是否执行完</p>
<p><code>CompletableFuture</code>同时实现了<code>Future</code>和<code>CompletionStage</code>接口</p>
<p>CompletionStage接口描述了一个异步计算的阶段，很多计算可以分成多个阶段或步骤，此时可以通过它将所有步骤组合起来，形成异步计算的流水线</p>
<h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><h2 id="AQS是什么"><a href="#AQS是什么" class="headerlink" title="AQS是什么"></a>AQS是什么</h2><p>AQS的全称为AbstarctQueuedSynchronizer，即抽象队列同步器</p>
<p>AQS是一个抽象类，主要用于构建锁和同步器</p>
<h2 id="Semaphore有什么用"><a href="#Semaphore有什么用" class="headerlink" title="Semaphore有什么用"></a>Semaphore有什么用</h2><p><code>synchronized</code>和<code>ReentrantLock</code>都是一次只允许一个线程访问某个资源，而<code>Semaphore</code>可以用来控制同时访问特定资源的线程数量</p>
<p><code>Semaphore</code>有公平模式（FIFO）和非公平模式（抢占式的）</p>
<h2 id="Semaphore的原理是什么"><a href="#Semaphore的原理是什么" class="headerlink" title="Semaphore的原理是什么"></a>Semaphore的原理是什么</h2><p><code>Semaphore</code>是共享锁的一种实现，它默认构造AQS的<code>state</code>值为<code>permits</code></p>
<p>调用semaphore.acquire()，线程尝试获取许可证，如果state-1&gt;&#x3D;0，则表示可以获取，使用CAS操作修改state&#x3D;state-1；如果state-1&lt;0，则获取失败，此时创建一个Node节点加入阻塞队列，挂起当前线程</p>
<p>调用semaphore.release()，线程尝试释放许可证，使用CAS操作修改state&#x3D;state+1。成功释放后会唤醒阻塞队列中的一个线程，被唤醒的线程会重新尝试修改state的值state&#x3D;state-1，如果state&gt;&#x3D;0则获取成功，否则重新进入阻塞队列，挂起线程</p>
<h2 id="CountDownLatch有什么用"><a href="#CountDownLatch有什么用" class="headerlink" title="CountDownLatch有什么用"></a>CountDownLatch有什么用</h2><p><code>CountDownLatch</code>允许<code>count</code>个线程阻塞在一个地方，直至这<code>count</code>个线程都执行完成。</p>
<p><code>CountDownLatch</code>是<strong>一次性的</strong>，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，即当<code>CountDownLatch</code>使用完毕后，<strong>它不能再次被使用</strong></p>
<h2 id="CountDownLatch的原理是什么"><a href="#CountDownLatch的原理是什么" class="headerlink" title="CountDownLatch的原理是什么"></a>CountDownLatch的原理是什么</h2><ol>
<li>线程使用<code>CountDown()</code>方法时，使用了<code>tryReleaseShared</code>方法以CAS的操作来减少<code>state</code>，直至<code>state</code>为0</li>
<li>当调用<code>await()</code>方法时，如果<code>state</code>不为0，说明所有的任务还没有执行完毕，<code>await()</code>方法就会一直阻塞，即<code>await()</code>方法后的语句不会被执行</li>
<li><code>CountDownLatch</code>会自旋CAS判断<code>state==0</code>，如果<code>state==0</code>就会释放所有等待的线程，<code>await()</code>方法之后的语句得到执行</li>
</ol>
<h2 id="CyclicBarrier有什么用"><a href="#CyclicBarrier有什么用" class="headerlink" title="CyclicBarrier有什么用"></a>CyclicBarrier有什么用</h2><p><code>CyclicBarrier</code>，即可循环使用(Cyclic)的屏障(Barrier)让一组线程到达一个屏障时被阻塞，直到最后一个线程到达屏障，屏障才会开门，所有被屏障拦截的线程才会继续执行</p>
<h2 id="CyclicBarrier的原理是什么"><a href="#CyclicBarrier的原理是什么" class="headerlink" title="CyclicBarrier的原理是什么"></a>CyclicBarrier的原理是什么</h2><ol>
<li>CyclicBarrier以一个count变量作为计数器，count的初始值为parties属性的初始化值</li>
<li>每当一个线程到屏障这里，就将计数器减一</li>
<li>如果count的值为0，表示这是这一代最后一个线程到达屏障</li>
<li>然后尝试执行构造方法中输入的任务</li>
</ol>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol>
<li><a href="https://zhuanlan.zhihu.com/p/158033837">https://zhuanlan.zhihu.com/p/158033837</a></li>
<li><a href="https://javaguide.cn/java/concurrent/java-concurrent-questions-03.html#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E6%B1%A0">https://javaguide.cn/java/concurrent/java-concurrent-questions-03.html#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E6%B1%A0</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=Mzg3NjU3NTkwMQ==&mid=2247505103&idx=1&sn=a041dbec689cec4f1bbc99220baa7219&source=41#wechat_redirect">https://mp.weixin.qq.com/s?__biz=Mzg3NjU3NTkwMQ==&amp;mid=2247505103&amp;idx=1&amp;sn=a041dbec689cec4f1bbc99220baa7219&amp;source=41#wechat_redirect</a></li>
<li>《Java并发编程的艺术》</li>
</ol>
]]></content>
      <categories>
        <category>八股</category>
      </categories>
      <tags>
        <tag>Java并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程(1)</title>
    <url>/2023/03/08/JavaConcurrrent1/</url>
    <content><![CDATA[<blockquote>
<p>本文主要摘自JavaGuide面试指南，笔者根据自身的实际情况进行了一定的删改。原文链接：<a href="https://javaguide.cn/java/concurrent/java-concurrent-questions-02.html">https://javaguide.cn/java/concurrent/java-concurrent-questions-02.html</a></p>
</blockquote>
<h1 id="为什么要使用多线程？"><a href="#为什么要使用多线程？" class="headerlink" title="为什么要使用多线程？"></a>为什么要使用多线程？</h1><ul>
<li>线程可以看作是轻量级的进程，是程序执行的最小单位，线程间的切换和调度成本远远小于进程</li>
<li>多线程可以提高进程利用单核&#x2F;多核CPU效率，提高系统整体的并发能力以及性能</li>
</ul>
<h1 id="多线程可能带来的问题？"><a href="#多线程可能带来的问题？" class="headerlink" title="多线程可能带来的问题？"></a>多线程可能带来的问题？</h1><p>并发编程并不总能提高程序运行速度，而且并发编程可能会遇到很多问题，比如：内存泄漏、死锁、线程不安全等</p>
<h1 id="说说线程的生命周期和状态？"><a href="#说说线程的生命周期和状态？" class="headerlink" title="说说线程的生命周期和状态？"></a>说说线程的生命周期和状态？</h1><ul>
<li>NEW：初始状态，线程被创建出来但没有被调用<code>start()</code></li>
<li>RUNNABLE：运行状态，线程被调用了<code>start()</code></li>
<li>BLOCKED：阻塞状态，需要等待锁释放</li>
<li>WAITING：等待状态，表示该线程需要等待其他线程的通知</li>
<li>TIME_WAITING：超时等待状态，在指定时间后回到RUNNABLE状态</li>
<li>TERMINATED：终止状态，表示该线程已经运行完毕</li>
</ul>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/concurrent/640.png" loading="lazy"></p>
<h1 id="什么是上下文切换？其流程是什么"><a href="#什么是上下文切换？其流程是什么" class="headerlink" title="什么是上下文切换？其流程是什么"></a>什么是上下文切换？其流程是什么</h1><p>上下文：线程在执行过程中自己的运行条件和状态，比如程序计数器、栈信息等</p>
<p>上下文切换：保存当前线程的上下文，留待线程下次占用CPU时恢复现场，并加载下一个将要占用CPU的线程上下文</p>
<p>以下情况会发生线程切换：</p>
<ul>
<li>主动让出CPU，比如调用了<code>sleep()</code>，<code>wait()</code>等</li>
<li>时间片用完</li>
<li>调用了阻塞类型的系统中断</li>
</ul>
<h1 id="什么是线程死锁？如何避免死锁？"><a href="#什么是线程死锁？如何避免死锁？" class="headerlink" title="什么是线程死锁？如何避免死锁？"></a>什么是线程死锁？如何避免死锁？</h1><p>线程死锁：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放</p>
<h2 id="产生死锁的四个必要条件"><a href="#产生死锁的四个必要条件" class="headerlink" title="产生死锁的四个必要条件"></a>产生死锁的四个必要条件</h2><ul>
<li>互斥条件：一个资源任意时刻只有一个线程占用</li>
<li>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放</li>
<li>不可剥夺条件：线程已获得的资源在未使用完之前不能被其他线程强行剥夺</li>
<li>循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系</li>
</ul>
<h2 id="如何预防死锁"><a href="#如何预防死锁" class="headerlink" title="如何预防死锁"></a>如何预防死锁</h2><p>破坏死锁的产生的必要条件：</p>
<ul>
<li>破坏请求与保持条件：一次性申请所有的资源</li>
<li>破坏不可剥夺条件：线程如果申请不到其他资源时，可以主动释放其占有的资源</li>
<li>破坏循环等待条件：按某一顺序申请资源，释放时反序释放</li>
</ul>
<h2 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁"></a>如何避免死锁</h2><p>在资源分配时，借助于算法（如银行家算法）对资源分配进行计算评估，使其进入安全状态。</p>
<p>安全状态：系统按照某种线程推进顺序来为每个线程分配所需资源，每个线程都可顺利完成，则为安全状态，该推进顺序为一个安全序列。</p>
<h1 id="sleep-方法和wait-方法的对比？"><a href="#sleep-方法和wait-方法的对比？" class="headerlink" title="sleep()方法和wait()方法的对比？"></a>sleep()方法和wait()方法的对比？</h1><p>相同：两者都可以暂停线程的执行</p>
<p>区别：</p>
<ul>
<li><code>sleep()</code>方法没有释放锁，而<code>wait()</code>方法释放了锁</li>
<li><code>wait()</code>通常用于线程间交互&#x2F;通信，<code>sleep()</code>通常被用于暂停执行</li>
<li><code>wait()</code>方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的<code>notify()</code>或者<code>notifyAll()</code>方法；sleep()方法执行完成后，线程会自动苏醒，或者使用<code>wait(long timeout)</code>超时后线程会自动苏醒</li>
<li><code>sleep()</code>是Thread类的静态本地方法，<code>wait()</code>则是Object类的本地方法</li>
</ul>
<h2 id="为什么wait-方法不定义在Thread中？"><a href="#为什么wait-方法不定义在Thread中？" class="headerlink" title="为什么wait()方法不定义在Thread中？"></a>为什么wait()方法不定义在Thread中？</h2><p><code>wait()</code>是让获得对象锁的线程实现等待，实现进程间的同步，会自动释放当前线程占有的对象锁。每个对象(Object)都拥有对象锁，既然要释放当前线程占有的对象锁并让其进入WAITING状态，因此需要操作对应的对象(Object)而非当前的线程(Thread)</p>
<h2 id="为什么sleep-方法定义在Thread中"><a href="#为什么sleep-方法定义在Thread中" class="headerlink" title="为什么sleep()方法定义在Thread中"></a>为什么sleep()方法定义在Thread中</h2><p><code>sleep()</code>是让当前线程暂停执行，不涉及到对象类，也不需要获得对象锁</p>
<h1 id="可以直接调用Thread类的run方法吗？"><a href="#可以直接调用Thread类的run方法吗？" class="headerlink" title="可以直接调用Thread类的run方法吗？"></a>可以直接调用Thread类的run方法吗？</h1><p><strong>调用start()方法可启动线程并使线程进入就绪状态，但直接执行run()方法不会以多线程的方式执行</strong>。</p>
<p>new一个Thread，线程进入新建状态。调用<code>start()</code>方法，会启动该线程并进入RUNNABLE状态。<code>start()</code>会执行线程的相应准备工作，然后自动执行<code>run()</code>方法的内容，只是真正的多线程工作。但是直接调用<code>run()</code>方法，会把<code>run()</code>方法当成一个main线程下的普通方法去执行，并不会在某个线程中执行它，所以并不是多线程工作</p>
<h1 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h1><p><code>volatile</code>关键字作用：</p>
<ol>
<li>保证变量的可见性</li>
<li>防止JVM的指令重排序</li>
</ol>
<h2 id="如何保证变量的可见性？"><a href="#如何保证变量的可见性？" class="headerlink" title="如何保证变量的可见性？"></a>如何保证变量的可见性？</h2><p><code>volatile</code>关键字可以保证变量的可见性，其指示JVM，被该关键字修饰的变量是共享且不稳定的，每次使用它都需要到主存(主内存)中进行读取，即禁止使用缓存</p>
<p><code>volatile</code>关键字能保证数据的可见性，但不能保证数据的原子性，<code>synchronized</code>关键字两者都能保证</p>
<ul>
<li>可见性，一个线程对变量的修改会被实时写回至主存中，对于其他线程来说可以实时得到其修改后的值</li>
<li>原子性，一条指令的所有操作，要么全做，要么全不做</li>
</ul>
<h2 id="如何禁止指令重排序？"><a href="#如何禁止指令重排序？" class="headerlink" title="如何禁止指令重排序？"></a>如何禁止指令重排序？</h2><ul>
<li><p><code>volatile</code>关键字可以防止JVM的指令重排序，如果将变量声明为<code>volatile</code>，在对这个变量进行读写操作的时候，会通过插入特定的 <strong>内存屏障</strong> 的方式来禁止指令重排序</p>
</li>
<li><p>Java中的<code>Unsafe</code>类提供三个内存屏障相关的方法，通过这三个方法也可以实现禁止指令重排序的的效果，但相对麻烦一些</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">loadFence</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">storeFence</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">fullFence</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="volatile可以保证原子性吗？"><a href="#volatile可以保证原子性吗？" class="headerlink" title="volatile可以保证原子性吗？"></a>volatile可以保证原子性吗？</h2><p><code>volatile</code>关键字能保证变量的可见性，但不能保证对变量操作的原子性，可以使用<code>synchronized</code>或者<code>lock</code>。</p>
<h1 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h1><h2 id="什么是悲观锁？使用场景是什么？"><a href="#什么是悲观锁？使用场景是什么？" class="headerlink" title="什么是悲观锁？使用场景是什么？"></a>什么是悲观锁？使用场景是什么？</h2><ul>
<li><p><strong>悲观锁：</strong>总是假设最坏的情况，认为共享资源每次被访问时会发生问题，所以每次获取资源操作时会上锁，其他线程尝试获取该资源时会被阻塞，<strong>即共享资源每次只给一个线程使用，其他线程阻塞，用完后再把资源转让给其他线程。</strong></p>
</li>
<li><p>Java中的<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现</p>
</li>
<li><p><strong>悲观锁通常多用于多写场景，避免频繁失败和重试影响性能</strong></p>
</li>
</ul>
<h2 id="什么是乐观锁？使用场景是什么？"><a href="#什么是乐观锁？使用场景是什么？" class="headerlink" title="什么是乐观锁？使用场景是什么？"></a>什么是乐观锁？使用场景是什么？</h2><ul>
<li><p><strong>乐观锁</strong>：总是假设最好的情况，认为共享资源每次被访问时不会发生问题，线程可以不停地执行，无需加锁也无需等待，只是<strong>在提交修改时验证对应的资源(数据)是否被其他线程修改</strong>（具体可用版本号机制或CAS算法）</p>
</li>
<li><p>Java中<code>java.util.concurrent.atomic</code>包下的原子变量类就是使用乐观锁的一种实现方式CAS实现的</p>
</li>
<li><p><strong>乐观锁通常多用于多读场景，避免频繁加锁影响性能，大大提升系统的吞吐量</strong></p>
</li>
</ul>
<h2 id="如何实现乐观锁？"><a href="#如何实现乐观锁？" class="headerlink" title="如何实现乐观锁？"></a>如何实现乐观锁？</h2><p>乐观锁一般使用<strong>版本号机制</strong>或<strong>CAS算法</strong>实现</p>
<h3 id="版本号机制"><a href="#版本号机制" class="headerlink" title="版本号机制"></a>版本号机制</h3><p>一般是在数据表中加上一个数据版本号<code>version</code>字段，表示数据被修改的次数。当数据被修改时，<code>version</code>值会加一。线程在提交更新时，只有读到的<code>version</code>值和先前的<code>version</code>值相等时才能提交更新后的数据</p>
<h2 id="CAS算法"><a href="#CAS算法" class="headerlink" title="CAS算法"></a>CAS算法</h2><p>CAS的全称是Compare And Swap(比较与交换)，用于实现乐观锁，其思想是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新</p>
<p>CAS是一个原子操作，底层依赖于一条CPU的原子指令</p>
<p>CAS涉及到三个操作数：</p>
<ul>
<li>V：要更新的变量值（Var）</li>
<li>E：预期值（Expected）</li>
<li>N：拟写入的新值（New）</li>
</ul>
<p>当且仅当V的值等于E时，CAS通过原子方式用新值N来更新V的值和E的值，如果不等，说明已经有其他线程更新了V，当前线程放弃更新并重新执行刚才的操作。</p>
<p><img src="https://img-blog.csdnimg.cn/784c23466aef4419a011d86f649f3f40.png" loading="lazy"></p>
<h3 id="CAS存在哪些问题？"><a href="#CAS存在哪些问题？" class="headerlink" title="CAS存在哪些问题？"></a>CAS存在哪些问题？</h3><ol>
<li>ABA问题：数据从A-&gt;B-&gt;A，CAS检查时会发现它的值没有发生改变，可以用版本号机制来解决，<strong>JDK 1.5</strong>以后的<code>AtomicStampedReference</code>类就是用来解决ABA问题的，其中的<code>compareAndSet()</code>方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，就以原子方式将该引用和该标志的值设置为给定的更新值</li>
<li>循环时间长开销大：CAS经常会用到自旋操作来进行重试，如果长时间不成功，会给CPU带来非常大的执行开销</li>
<li>只能保证一个共享变量的原子操作：CAS只对单个共享变量有效，当操作涉及跨多个共享变量时CAS无效。从<strong>JDK 1.5</strong>开始提供<code>AtomicReference</code>类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作</li>
</ol>
<h1 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h1><h2 id="synchronized是什么？有什么用？"><a href="#synchronized是什么？有什么用？" class="headerlink" title="synchronized是什么？有什么用？"></a>synchronized是什么？有什么用？</h2><p><code>synchronized</code>主要解决多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行</p>
<h2 id="如何使用synchronized？"><a href="#如何使用synchronized？" class="headerlink" title="如何使用synchronized？"></a>如何使用synchronized？</h2><ol>
<li><p>修饰实例方法（锁当前类的对象）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修饰静态方法（锁当前类所有对象）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修饰代码块（锁指定对象&#x2F;类）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(object)&#123;&#125;;</span><br><span class="line"><span class="keyword">synchronized</span>(类.class)&#123;&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>*尽量不要使用<code>synchronized(String a)</code>，因为JVM中字符串常量池具有缓存功能。</p>
<h2 id="构造方法可以用synchronized修饰吗？"><a href="#构造方法可以用synchronized修饰吗？" class="headerlink" title="构造方法可以用synchronized修饰吗？"></a>构造方法可以用synchronized修饰吗？</h2><p>不可以，因为构造方法本身就属于线程安全的，不存在同步的构造方法一说。</p>
<h1 id="synchronized和volatile有什么区别"><a href="#synchronized和volatile有什么区别" class="headerlink" title="synchronized和volatile有什么区别"></a>synchronized和volatile有什么区别</h1><ul>
<li><code>volatile</code>是线程同步的轻量级实现，所以性能优于<code>synchronized</code>，但<code>volatile</code>关键字是能用于变量而<code>synchronized</code>可以修饰方法以及代码块</li>
<li><code>volatile</code>能保证数据的可见性，但不能保证数据的原子性，<code>synchronized</code>两者都能保证</li>
<li><code>volatile</code>主要用于解决变量在多个线程之间的可见性，而<code>synchronized</code>解决的是多个线程之间访问资源的同步性</li>
</ul>
<h1 id="synchronized和ReentrantLock有什么区别"><a href="#synchronized和ReentrantLock有什么区别" class="headerlink" title="synchronized和ReentrantLock有什么区别"></a>synchronized和ReentrantLock有什么区别</h1><h2 id="两者都是可重入锁"><a href="#两者都是可重入锁" class="headerlink" title="两者都是可重入锁"></a>两者都是可重入锁</h2><p><strong>可重入锁</strong> 也叫递归锁，指的是线程可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其想要再次获取这个对象的锁的时候还是可以获取的，如果是不可重入锁，就会造成死锁</p>
<h2 id="sychronized依赖于JVM而ReentrantLocl依赖于API"><a href="#sychronized依赖于JVM而ReentrantLocl依赖于API" class="headerlink" title="sychronized依赖于JVM而ReentrantLocl依赖于API"></a>sychronized依赖于JVM而ReentrantLocl依赖于API</h2><ul>
<li><p><code>synchronized</code> 是依赖于 JVM 实现的，虚拟机团队在 JDK1.6 为 <code>synchronized</code> 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们</p>
</li>
<li><p><code>ReentrantLock</code> 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try&#x2F;finally 语句块来完成），所以可以通过查看它的源代码，来看它是如何实现的</p>
</li>
</ul>
<h1 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h1><h2 id="ReentrantLock是什么？"><a href="#ReentrantLock是什么？" class="headerlink" title="ReentrantLock是什么？"></a>ReentrantLock是什么？</h2><p><code>ReentrantLock</code>实现了<code>Lock</code>接口，是一个可重入且独占式的锁，和<code>synchronized</code>关键字类似，但它更灵活、更强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能</p>
<h2 id="公平锁和非公平锁有什么区别？"><a href="#公平锁和非公平锁有什么区别？" class="headerlink" title="公平锁和非公平锁有什么区别？"></a>公平锁和非公平锁有什么区别？</h2><ul>
<li>公平锁：锁被释放后，按照申请顺序将锁给下一个线程。性能较差一些，因为公平锁为保证时间上的绝对顺序，上下文切换更频繁</li>
<li>非公平锁：锁被释放后，随机或者按照其他优先级将锁给下一个进程。性能更好，但可能导致某些线程永远无法获取到锁</li>
</ul>
<h2 id="ReentrantLock-比-synchronized-增加了一些高级功能"><a href="#ReentrantLock-比-synchronized-增加了一些高级功能" class="headerlink" title="ReentrantLock 比 synchronized 增加了一些高级功能"></a>ReentrantLock 比 synchronized 增加了一些高级功能</h2><ul>
<li>等待可中断（等了一半放弃，去做其他事）</li>
<li>可实现公平锁</li>
<li>可实现选择性通知</li>
</ul>
<h2 id="可中断锁和不可中断锁的区别？"><a href="#可中断锁和不可中断锁的区别？" class="headerlink" title="可中断锁和不可中断锁的区别？"></a>可中断锁和不可中断锁的区别？</h2><ul>
<li>可中断锁：获取锁的过程可以被中断，不需要一直等到获取锁后才能进行其他逻辑处理，如<code>ReentrantLock</code></li>
<li>不可中断锁：一旦线程申请了锁，必须拿到锁后才能进行其他的逻辑处理，如<code>synchronized</code></li>
</ul>
]]></content>
      <categories>
        <category>八股</category>
      </categories>
      <tags>
        <tag>Java并发</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义注解+AOP+JWT实现Token拦截验证</title>
    <url>/2023/03/20/JWTandAOPforVerify/</url>
    <content><![CDATA[<h1 id="定义-Authorized注解"><a href="#定义-Authorized注解" class="headerlink" title="定义@Authorized注解"></a>定义@Authorized注解</h1><p>首先定义一个<code>Authorized</code>注解，用于后面对需要鉴权的方法添加该注解，<code>Authorzied</code>注解有<code>Role</code>类型的<code>roles</code>数组变量，表明能够调用被<code>Authorized</code>注解的方法的角色有哪些，其默认值如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Authorized&#123;</span><br><span class="line">  Role[] roles() <span class="keyword">default</span>&#123;</span><br><span class="line">    Role.ADMIN, </span><br><span class="line">    Role.SALE_STAFF, </span><br><span class="line">    Role.INVENTORY_MANAGER,</span><br><span class="line">    Role.FINANCIAL_STAFF, </span><br><span class="line">    Role.HR, Role.GM</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>元注解：注解的注解，如<code>@Retention</code>和<code>@Target</code></li>
</ul>
<h2 id="Retention注解"><a href="#Retention注解" class="headerlink" title="@Retention注解"></a><code>@Retention</code>注解</h2><ul>
<li>生命周期：用来定义该注解在哪个级别可用，可选的有<strong>源代码中(SOURCE)<strong>、</strong>类文件中(CLASS)<strong>或者</strong>运行时(RUNTIME)</strong></li>
<li>从<code>@Retention</code>注解源码可以看到拥有一个<code>RetentionPolicy</code>类型的变量<code>value</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang.annotation;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Indicates how long annotations with the annotated interface are to</span></span><br><span class="line"><span class="comment"> * be retained.  If no Retention annotation is present on</span></span><br><span class="line"><span class="comment"> * an annotation interface declaration, the retention policy defaults to</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> RetentionPolicy.CLASS&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;A Retention meta-annotation has effect only if the</span></span><br><span class="line"><span class="comment"> * meta-annotated interface is used directly for annotation.  It has no</span></span><br><span class="line"><span class="comment"> * effect if the meta-annotated interface is used as a member interface in</span></span><br><span class="line"><span class="comment"> * another annotation interface.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  Joshua Bloch</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@jls</span> 9.6.4.2 <span class="doctag">@Retention</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Retention &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the retention policy.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the retention policy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RetentionPolicy <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>RetentionPolicy源码如下，可以看到它是个枚举类型，有**源代码中(SOURCE)<strong>、</strong>类文件中(CLASS)<strong>或者</strong>运行时(RUNTIME)**，对应的生命周期长度为RUNTIME&gt;CLASS&gt;SOURCE<ol>
<li>一般如果需要在运行时去动态获取注解信息，用生命周期最长的 RUNTIME 标注</li>
<li>如果要在编译时进行一些预处理操作，比如生成一些辅助代码（如 ButterKnife），就用 CLASS注解</li>
<li>如果只是做一些检查性的操作，就用SOURCE标注，比如源码中的 <strong>@Override、@SuppressWarnings、@Native、@Generated</strong> 等</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang.annotation;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Annotation retention policy.  The constants of this enumerated class</span></span><br><span class="line"><span class="comment"> * describe the various policies for retaining annotations.  They are used</span></span><br><span class="line"><span class="comment"> * in conjunction with the &#123;<span class="doctag">@link</span> Retention&#125; meta-annotation interface to</span></span><br><span class="line"><span class="comment"> * specify how long annotations are to be retained.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  Joshua Bloch</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">RetentionPolicy</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Annotations are to be discarded by the compiler.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SOURCE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Annotations are to be recorded in the class file by the compiler</span></span><br><span class="line"><span class="comment">     * but need not be retained by the VM at run time.  This is the default</span></span><br><span class="line"><span class="comment">     * behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    CLASS,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Annotations are to be recorded in the class file by the compiler and</span></span><br><span class="line"><span class="comment">     * retained by the VM at run time, so they may be read reflectively.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> java.lang.reflect.AnnotatedElement</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RUNTIME</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Target"><a href="#Target" class="headerlink" title="@Target"></a><code>@Target</code></h2><ul>
<li>注解目标：用来定义你的注解将应用于什么地方(例如是一个方法或者一个域)</li>
<li>从<code>@Target</code>注解源码可以看到拥有一个<code>ElementType</code>类型的数组变量<code>value</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Target &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns an array of the kinds of elements an annotation interface</span></span><br><span class="line"><span class="comment">     * can be applied to.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> an array of the kinds of elements an annotation interface</span></span><br><span class="line"><span class="comment">     * can be applied to</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ElementType[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ElementType</code>源码如下，可以看到它是个枚举类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ElementType</span> &#123;</span><br><span class="line">    <span class="comment">/** Class, interface (including annotation interface), enum, or record</span></span><br><span class="line"><span class="comment">     * declaration */</span></span><br><span class="line">    TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Field declaration (includes enum constants) */</span></span><br><span class="line">    FIELD,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Method declaration */</span></span><br><span class="line">    METHOD,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Formal parameter declaration */</span></span><br><span class="line">    PARAMETER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Constructor declaration */</span></span><br><span class="line">    CONSTRUCTOR,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Local variable declaration */</span></span><br><span class="line">    LOCAL_VARIABLE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Annotation interface declaration (Formerly known as an annotation type.) */</span></span><br><span class="line">    ANNOTATION_TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Package declaration */</span></span><br><span class="line">    PACKAGE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Type parameter declaration</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TYPE_PARAMETER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Use of a type</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TYPE_USE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Module declaration.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 9</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    MODULE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Record component</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@jls</span> 8.10.3 Record Members</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@jls</span> 9.7.4 Where Annotations May Appear</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 16</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RECORD_COMPONENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="实现JwtConfig类"><a href="#实现JwtConfig类" class="headerlink" title="实现JwtConfig类"></a>实现JwtConfig类</h1><p><code>JwtCOnfig</code>类用来签发Jwt和解析Jwt，它的源码如下：</p>
<ul>
<li><code>UserService.login</code>登录和数据库校验成功后调用<code>createJwt()</code>，并把这个JWT返回给前端，以后前端每次请求都需要带上这个JWT</li>
<li>切面获取前端发来的http请求，调用<code>parseJwt</code>解析JWT，验证是否拥有对应方法的权限</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String secret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> expire;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Key key;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jwt.secret&#125;&quot;)</span> <span class="comment">//value在application.yml中配置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setJwtSecret</span><span class="params">(String jwtSecret)</span> &#123; <span class="comment">//通过set让static方法读取配置文件中的值</span></span><br><span class="line">        JwtConfig.secret = jwtSecret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jwt.expire&#125;&quot;)</span> <span class="comment">//value在application.yml中配置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setExpire</span><span class="params">(<span class="type">long</span> expire)</span> &#123; <span class="comment">//通过set让static方法读取配置文件中的值</span></span><br><span class="line">        JwtConfig.expire = expire;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//签发Jwt</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">createJWT</span><span class="params">(UserPO userPO)</span> &#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="type">Date</span> <span class="variable">expireDate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(date.getTime() + expire);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">jwt</span> <span class="operator">=</span> JWT.create()</span><br><span class="line">                <span class="comment">//可以将基本信息放到claims中</span></span><br><span class="line">                .withClaim(<span class="string">&quot;name&quot;</span>, userPO.getName())</span><br><span class="line">                <span class="comment">//name</span></span><br><span class="line">                .withClaim(<span class="string">&quot;role&quot;</span>, userPO.getRole().name())</span><br><span class="line">                <span class="comment">//超时设置,设置过期的日期</span></span><br><span class="line">                .withExpiresAt(expireDate)</span><br><span class="line">                <span class="comment">//签发时间</span></span><br><span class="line">                .withIssuedAt(<span class="keyword">new</span> <span class="title class_">Date</span>())</span><br><span class="line">                <span class="comment">//SECRET加密</span></span><br><span class="line">                .sign(Algorithm.HMAC256(secret));</span><br><span class="line">        <span class="keyword">return</span> jwt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析Jwt</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Claim&gt; <span class="title function_">parseJwt</span><span class="params">(String token)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">JWTVerifier</span> <span class="variable">verifier</span> <span class="operator">=</span> JWT.require(Algorithm.HMAC256(secret)).build();</span><br><span class="line">            <span class="type">DecodedJWT</span> <span class="variable">jwt</span> <span class="operator">=</span> verifier.verify(token);</span><br><span class="line">            <span class="keyword">return</span> jwt.getClaims();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TokenExpiredException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyServiceException</span>(<span class="string">&quot;A0230&quot;</span>, <span class="string">&quot;用户登陆已过期&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JWTVerificationException | IllegalArgumentException e) &#123; <span class="comment">//解析错误 或者 token写错</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyServiceException</span>(<span class="string">&quot;A0200&quot;</span>, <span class="string">&quot;登陆失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="实现增强类"><a href="#实现增强类" class="headerlink" title="实现增强类"></a>实现增强类</h1><p>新建一个<code>AuthAspect</code>切面，用于增强需要鉴权的方法，其定义如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Order(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthAspect</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserService userService;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> JwtConfig jwtConfig;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AuthAspect</span><span class="params">(UserService userService, JwtConfig jwtConfig)</span>&#123;</span><br><span class="line">         <span class="built_in">this</span>.userService = userService;</span><br><span class="line">        <span class="built_in">this</span>.jwtConfig = jwtConfig;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Before(value = &quot;execution(public * com.nju.edu.erp.web.controller.*.*(..)) &amp;&amp; @annotation(authorized)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">authCheck</span><span class="params">(JoinPoint joinPoint, Authorized authorized)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>AuthAspect</code>类有三个注解</p>
<ul>
<li><code>@Aspect</code>：把当前类标识为一个切面供容器读取</li>
<li><code>@Configuration</code>：表明它是一个配置类</li>
<li><code>@Order(1)</code>：用于有多个增强类对同一个方法进行增强的时候表明其优先级，越小优先级越高</li>
</ul>
</li>
<li><p>AuthAspect类除去构造方法外只有一个<code>authChech()</code>方法，它有一个@Before注解</p>
<ul>
<li><code>@Before</code>：标识一个前置增强方法，相当于BeforeAdvice的功能</li>
<li>这个注解的值是检查所有<code>com.nju.edu.erp.web.controller</code>包下所有类public并且被Authorized注解所标注的方法</li>
</ul>
</li>
<li><p><code>authCheck()</code>方法代码如下，主要操作包括：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Before(value = &quot;execution(public * com.nju.edu.erp.web.controller.*.*(..)) &amp;&amp; @annotation(authorized)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">authCheck</span><span class="params">(JoinPoint joinPoint, Authorized authorized)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.获取当前http请求</span></span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">httpServletRequest</span> <span class="operator">=</span> ((ServletRequestAttributes) Objects.requireNonNull(RequestContextHolder.getRequestAttributes())).getRequest();</span><br><span class="line">        <span class="comment">//2.获得Authorized标头，没有则抛出异常</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> Optional.ofNullable(httpServletRequest.getHeader(<span class="string">&quot;Authorization&quot;</span>)).</span><br><span class="line">                orElseThrow(() -&gt; <span class="keyword">new</span> <span class="title class_">MyServiceException</span>(<span class="string">&quot;A0002&quot;</span>, <span class="string">&quot;用户未获得第三方登录授权&quot;</span>));</span><br><span class="line">        <span class="comment">//3.auth方法调用jwtConfig.parseJwt解析出UserVO信息</span></span><br><span class="line">        <span class="type">UserVO</span> <span class="variable">user</span> <span class="operator">=</span> userService.auth(token);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.判断切面方法是否包含当前token对应的角色</span></span><br><span class="line">        <span class="keyword">if</span> (!Arrays.stream(authorized.roles()).collect(Collectors.toList()).contains(user.getRole())) &#123;</span><br><span class="line">            <span class="comment">//5.如果不在就抛出访问未授权的异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyServiceException</span>(<span class="string">&quot;A0003&quot;</span>, <span class="string">&quot;访问未授权&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (MyServiceException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyServiceException</span>(<span class="string">&quot;A0004&quot;</span>, <span class="string">&quot;认证失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="需要鉴权的接口添加-Authorized注解"><a href="#需要鉴权的接口添加-Authorized注解" class="headerlink" title="需要鉴权的接口添加@Authorized注解"></a>需要鉴权的接口添加@Authorized注解</h1><p>controller层对前端来的路由添加<code>Authorized</code>注解进行鉴权，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/create&quot;)</span></span><br><span class="line"><span class="meta">@Authorized(roles = &#123;Role.ADMIN, Role.GM, Role.INVENTORY_MANAGER&#125;)</span></span><br><span class="line"><span class="keyword">public</span> Response <span class="title function_">createCategory</span><span class="params">(<span class="meta">@RequestParam(value = &quot;parentId&quot;)</span> <span class="type">int</span> parentId,</span></span><br><span class="line"><span class="params">                           <span class="meta">@RequestParam(value = &quot;name&quot;)</span> String name)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Response.buildSuccess(categoryService.createCategory(parentId, name));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="添加登录方法"><a href="#添加登录方法" class="headerlink" title="添加登录方法"></a>添加登录方法</h1><p><code>UserService.login</code>登录功能，后端从数据库根据用户名和邮箱进行验证，验证成功调用<code>jwtConfig.createJWT</code>生成JWT，并把这个JWT返回给前端，以后前端每次请求都需要带上这个JWT</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JwtConfig jwtConfig;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceImpl</span><span class="params">(UserDao userDao, JwtConfig jwtConfig)</span>;</span><br><span class="line">  </span><br><span class="line">  	<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, String&gt; <span class="title function_">login</span><span class="params">(UserVO userVO)</span> &#123;</span><br><span class="line">        <span class="type">UserPO</span> <span class="variable">userPO</span> <span class="operator">=</span> userDao.findByNameAndPassword(userVO.getName(), userVO.getPassword());</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == userPO) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyServiceException</span>(<span class="string">&quot;A0000&quot;</span>, <span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;String, String&gt; authToken = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> jwtConfig.createJWT(userPO);</span><br><span class="line">        authToken.put(<span class="string">&quot;token&quot;</span>, token);</span><br><span class="line">        <span class="keyword">return</span> authToken;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">updatePassword</span><span class="params">(UserVO userVO,String newPassword)</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserVO <span class="title function_">auth</span><span class="params">(String token)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="自定义注解-AOP-JWT验证流程总结"><a href="#自定义注解-AOP-JWT验证流程总结" class="headerlink" title="自定义注解+AOP+JWT验证流程总结"></a>自定义注解+AOP+JWT验证流程总结</h1><ol>
<li>调用<code>UserService.login</code>登录功能，后端从数据库根据用户名和邮箱进行验证，验证成功调用<code>jwtConfig.createJWT</code>生成JWT，并把这个JWT返回给前端，以后前端每次请求都需要带上这个JWT</li>
<li>controller层对前端来的路由添加<code>@Authorized</code>注解进行鉴权</li>
<li><code>AuthAspect</code>类对<code>Authorized</code>注解进行增强，<code>@Order</code>注解用于有多个增强类对同一个方法进行增强的时候表明其优先级，越小优先级越高</li>
<li>添加<code>Before</code>方法，用于拦截controller包中所有public并且有<code>@Authorized</code>注解的方法</li>
<li>拦截http请求并获得<code>Authorized</code>标头，调用<code>jwtConfig.parseJwt</code>解析出<code>UserVO</code>信息，判断该<code>UserVO</code>的角色是否在<code>Authorized</code>注解的roles集合中，如果不在就抛出访问未授权的异常</li>
</ol>
<h1 id="JoinPoint常用方法"><a href="#JoinPoint常用方法" class="headerlink" title="JoinPoint常用方法"></a>JoinPoint常用方法</h1><ul>
<li>Object[] getArgs：获取目标方法的参数数组</li>
<li>Signature getSignature：获取目标方法的签名</li>
<li>Object getTarget：获取被织入增强处理的目标对象</li>
<li>Object getThis：获取AOP框架为目标对象生成的代理对象</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>AOP</tag>
        <tag>JWT</tag>
        <tag>鉴权</tag>
      </tags>
  </entry>
  <entry>
    <title>questionsAboutProject</title>
    <url>/2023/03/20/questionsAboutProject/</url>
    <content><![CDATA[<h1 id="JWT验证流程总结"><a href="#JWT验证流程总结" class="headerlink" title="JWT验证流程总结"></a>JWT验证流程总结</h1><ol>
<li>调用<code>UserService.login</code>登录功能，后端从数据库根据用户名和邮箱进行验证，验证成功调用<code>jwtConfig.createJWT</code>生成JWT，并把这个JWT返回给前端，以后前端每次请求都需要带上这个JWT</li>
<li>controller层对前端来的路由添加<code>@Authorized</code>注解进行鉴权</li>
<li><code>AuthAspect</code>类对<code>Authorized</code>注解进行增强，<code>@Order</code>注解用于有多个增强类对同一个方法进行增强的时候表明其优先级，越小优先级越高</li>
<li>添加<code>Before</code>方法，用于拦截controller包中所有public并且有<code>@Authorized</code>注解的方法</li>
<li>拦截http请求并获得<code>Authorized</code>标头，调用<code>jwtConfig.parseJwt</code>解析出<code>UserVO</code>信息，判断该<code>UserVO</code>的角色是否在<code>Authorized</code>注解的roles集合中，如果不在就抛出访问未授权的异常</li>
</ol>
<h1 id="项目的并发性怎么样？"><a href="#项目的并发性怎么样？" class="headerlink" title="项目的并发性怎么样？"></a>项目的并发性怎么样？</h1><p>通过在Service层使用Transaction注解和synchronized关键字保证了一定的并发性。一开始想的是直接将<code>@Transcational</code>注解和<code>synchronized</code>一起使用，但是后来验证发现还是线程不安全的，最后找到原因是<strong>加锁的范围没有包括到整个事务</strong>导致的，会出现<code>synchronized</code>代码块执行完但是事务还没有提交，新的线程又进入到<code>synchronized</code>代码块，读取到的数据是还没有提交的旧数据这样的情况。最后是通过对service层的方法添加一个代理方法，对这个代理方法加<code>synchronized</code>关键字，方法内部直接调用<code>service</code>的方法，这样就把锁加到了整个事务上。由此保证了单机下的多线程，但如果是分布式的话后面还的考虑加一些分布式锁</p>
<h1 id="用到了哪些设计模式？"><a href="#用到了哪些设计模式？" class="headerlink" title="用到了哪些设计模式？"></a>用到了哪些设计模式？</h1><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>总经理角色可以制定促销策略，针对不同级别的客户制定促销策略，包括赠品、价格折让或者赠送代金券，这部分我把这三种促销策略抽象成促销这个类，它具体的实现类有赠品、打折和代金券三种，不同级别的客户在一次购买金额达到触发条件后会自动进行判断，PromitionService层根据客户对应的级别和购买金额发放对应的促销策略，客户并不需要关心具体是哪种促销策略，只需要选择他能使用的促销策略就行</p>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>因为每个单据的创建都要设置大量的单据信息，如果把这些创建单据的代码放在业务代码主体中，会降低代码的可读性，所以我把单据的创建都交给工厂来做了，但是由于不同的单据它需要设置的信息基本不相同，所以我没有用抽象工厂，只是用了简单工厂模式，比如对于工资单这个单据，业务代码中只需要给工厂穿进一个staffDao，然后就不需要关心单据的具体创建过程，大大简化了SalarySheetService.makeSalarySheet方法，他只需要获取对应的员工信息，传给工厂，获得单据，存起来，如果有异常，就处理异常，并向前端返回，业务逻辑很清晰</p>
<h1 id="测试部分怎么写的？"><a href="#测试部分怎么写的？" class="headerlink" title="测试部分怎么写的？"></a>测试部分怎么写的？</h1><p>测试部分主要分为单元测试和集成测试</p>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>单元测试部分主要对工资单、员工打卡和用户模块进行测试，比如员工打卡模块，这个Service主要有ClockIn、GetAllInformation和GetMyInformation这三个方法，分别是当日打卡、人力部门查看打卡情况、员工查看今日打卡情况，所以主要测试这三个方法，比如打卡方法，测试打卡前后的员工打卡状态是否更改了，当月打卡次数是不是增加了，因为会用到员工的Dao层，所以先创建一个桩程序，来模拟Dao层返回的信息</p>
<h2 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h2><p>集成测试主要对财务人员部分的付款单和客户这两个模块的整体进行测试，财务人员制定付款单，包括单据编号，操作员，金额，银行账户以及所付款的客户ID，付款单审批成功后会把客户的应收金额减去单据的金额，表明公司向客户付过这些款了，主要测试单据金额大于公司应付的情况、银行账户错误等，这些情况都应该抛出异常。这部分需要实现的桩程序主要有银行账户Dao、客户Dao和付款单Dao</p>
<h1 id="有哪些可以优化的地方"><a href="#有哪些可以优化的地方" class="headerlink" title="有哪些可以优化的地方"></a>有哪些可以优化的地方</h1><h2 id="事务优化"><a href="#事务优化" class="headerlink" title="事务优化"></a>事务优化</h2><p>在创建出库单中，主要是基于Mysql的事务进行的，而基于MySQL事务的创建出库单操作的主要瓶颈是网络延迟和GC（Java垃圾回收机制）。执行一条update语句更新库存情况首先要拿到MySQL的行级锁rowLock，所以要尽量降低update对rowLock的持有时间。</p>
<p>一个简单的优化方式是在创建出库单时，从原来的先update库存再创建单据，优化成先创建单据再update库存，这样一来持有Mysql行级锁的时间会比原来少很多</p>
<h2 id="Redis缓存优化"><a href="#Redis缓存优化" class="headerlink" title="Redis缓存优化"></a>Redis缓存优化</h2><p> 由于员工打卡信息不需要经常变动，但前端接口需要保证员工打卡信息及时显示到前端页面上的，所以对数据库中这个字段的查询会比较频繁，可以采用Redis缓存的方式来减轻DB的压力，选取Bitmap数据接口存储员工打卡信息。内部的key是员工id+年月的形式，执行打卡时去相应的key中把天数对应的bit为置为1就行了</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
</search>
