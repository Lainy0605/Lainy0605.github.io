<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>自定义注解+AOP+JWT实现Token拦截验证</title>
    <url>/2023/03/20/JWTandAOPforVerify/</url>
    <content><![CDATA[<h1 id="定义-Authorized注解"><a href="#定义-Authorized注解" class="headerlink" title="定义@Authorized注解"></a>定义@Authorized注解</h1><p>首先定义一个<code>Authorized</code>注解，用于后面对需要鉴权的方法添加该注解，<code>Authorzied</code>注解有<code>Role</code>类型的<code>roles</code>数组变量，表明能够调用被<code>Authorized</code>注解的方法的角色有哪些，其默认值如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Authorized&#123;</span><br><span class="line">  Role[] roles() <span class="keyword">default</span>&#123;</span><br><span class="line">    Role.ADMIN, </span><br><span class="line">    Role.SALE_STAFF, </span><br><span class="line">    Role.INVENTORY_MANAGER,</span><br><span class="line">    Role.FINANCIAL_STAFF, </span><br><span class="line">    Role.HR, Role.GM</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>元注解：注解的注解，如<code>@Retention</code>和<code>@Target</code></li>
</ul>
<h2 id="Retention注解"><a href="#Retention注解" class="headerlink" title="@Retention注解"></a><code>@Retention</code>注解</h2><ul>
<li>生命周期：用来定义该注解在哪个级别可用，可选的有<strong>源代码中(SOURCE)<strong>、</strong>类文件中(CLASS)<strong>或者</strong>运行时(RUNTIME)</strong></li>
<li>从<code>@Retention</code>注解源码可以看到拥有一个<code>RetentionPolicy</code>类型的变量<code>value</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang.annotation;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Indicates how long annotations with the annotated interface are to</span></span><br><span class="line"><span class="comment"> * be retained.  If no Retention annotation is present on</span></span><br><span class="line"><span class="comment"> * an annotation interface declaration, the retention policy defaults to</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> RetentionPolicy.CLASS&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;A Retention meta-annotation has effect only if the</span></span><br><span class="line"><span class="comment"> * meta-annotated interface is used directly for annotation.  It has no</span></span><br><span class="line"><span class="comment"> * effect if the meta-annotated interface is used as a member interface in</span></span><br><span class="line"><span class="comment"> * another annotation interface.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  Joshua Bloch</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@jls</span> 9.6.4.2 <span class="doctag">@Retention</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Retention &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the retention policy.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the retention policy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RetentionPolicy <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>RetentionPolicy源码如下，可以看到它是个枚举类型，有**源代码中(SOURCE)<strong>、</strong>类文件中(CLASS)<strong>或者</strong>运行时(RUNTIME)**，对应的生命周期长度为RUNTIME&gt;CLASS&gt;SOURCE<ol>
<li>一般如果需要在运行时去动态获取注解信息，用生命周期最长的 RUNTIME 标注</li>
<li>如果要在编译时进行一些预处理操作，比如生成一些辅助代码（如 ButterKnife），就用 CLASS注解</li>
<li>如果只是做一些检查性的操作，就用SOURCE标注，比如源码中的 <strong>@Override、@SuppressWarnings、@Native、@Generated</strong> 等</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang.annotation;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Annotation retention policy.  The constants of this enumerated class</span></span><br><span class="line"><span class="comment"> * describe the various policies for retaining annotations.  They are used</span></span><br><span class="line"><span class="comment"> * in conjunction with the &#123;<span class="doctag">@link</span> Retention&#125; meta-annotation interface to</span></span><br><span class="line"><span class="comment"> * specify how long annotations are to be retained.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  Joshua Bloch</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">RetentionPolicy</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Annotations are to be discarded by the compiler.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SOURCE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Annotations are to be recorded in the class file by the compiler</span></span><br><span class="line"><span class="comment">     * but need not be retained by the VM at run time.  This is the default</span></span><br><span class="line"><span class="comment">     * behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    CLASS,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Annotations are to be recorded in the class file by the compiler and</span></span><br><span class="line"><span class="comment">     * retained by the VM at run time, so they may be read reflectively.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> java.lang.reflect.AnnotatedElement</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RUNTIME</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Target"><a href="#Target" class="headerlink" title="@Target"></a><code>@Target</code></h2><ul>
<li>注解目标：用来定义你的注解将应用于什么地方(例如是一个方法或者一个域)</li>
<li>从<code>@Target</code>注解源码可以看到拥有一个<code>ElementType</code>类型的数组变量<code>value</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Target &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns an array of the kinds of elements an annotation interface</span></span><br><span class="line"><span class="comment">     * can be applied to.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> an array of the kinds of elements an annotation interface</span></span><br><span class="line"><span class="comment">     * can be applied to</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ElementType[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ElementType</code>源码如下，可以看到它是个枚举类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ElementType</span> &#123;</span><br><span class="line">    <span class="comment">/** Class, interface (including annotation interface), enum, or record</span></span><br><span class="line"><span class="comment">     * declaration */</span></span><br><span class="line">    TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Field declaration (includes enum constants) */</span></span><br><span class="line">    FIELD,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Method declaration */</span></span><br><span class="line">    METHOD,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Formal parameter declaration */</span></span><br><span class="line">    PARAMETER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Constructor declaration */</span></span><br><span class="line">    CONSTRUCTOR,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Local variable declaration */</span></span><br><span class="line">    LOCAL_VARIABLE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Annotation interface declaration (Formerly known as an annotation type.) */</span></span><br><span class="line">    ANNOTATION_TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Package declaration */</span></span><br><span class="line">    PACKAGE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Type parameter declaration</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TYPE_PARAMETER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Use of a type</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TYPE_USE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Module declaration.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 9</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    MODULE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Record component</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@jls</span> 8.10.3 Record Members</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@jls</span> 9.7.4 Where Annotations May Appear</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 16</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RECORD_COMPONENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="实现JwtConfig类"><a href="#实现JwtConfig类" class="headerlink" title="实现JwtConfig类"></a>实现JwtConfig类</h1><p><code>JwtCOnfig</code>类用来签发Jwt和解析Jwt，它的源码如下：</p>
<ul>
<li><code>UserService.login</code>登录和数据库校验成功后调用<code>createJwt()</code>，并把这个JWT返回给前端，以后前端每次请求都需要带上这个JWT</li>
<li>切面获取前端发来的http请求，调用<code>parseJwt</code>解析JWT，验证是否拥有对应方法的权限</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String secret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> expire;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Key key;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jwt.secret&#125;&quot;)</span> <span class="comment">//value在application.yml中配置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setJwtSecret</span><span class="params">(String jwtSecret)</span> &#123; <span class="comment">//通过set让static方法读取配置文件中的值</span></span><br><span class="line">        JwtConfig.secret = jwtSecret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jwt.expire&#125;&quot;)</span> <span class="comment">//value在application.yml中配置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setExpire</span><span class="params">(<span class="type">long</span> expire)</span> &#123; <span class="comment">//通过set让static方法读取配置文件中的值</span></span><br><span class="line">        JwtConfig.expire = expire;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//签发Jwt</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">createJWT</span><span class="params">(UserPO userPO)</span> &#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="type">Date</span> <span class="variable">expireDate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(date.getTime() + expire);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">jwt</span> <span class="operator">=</span> JWT.create()</span><br><span class="line">                <span class="comment">//可以将基本信息放到claims中</span></span><br><span class="line">                .withClaim(<span class="string">&quot;name&quot;</span>, userPO.getName())</span><br><span class="line">                <span class="comment">//name</span></span><br><span class="line">                .withClaim(<span class="string">&quot;role&quot;</span>, userPO.getRole().name())</span><br><span class="line">                <span class="comment">//超时设置,设置过期的日期</span></span><br><span class="line">                .withExpiresAt(expireDate)</span><br><span class="line">                <span class="comment">//签发时间</span></span><br><span class="line">                .withIssuedAt(<span class="keyword">new</span> <span class="title class_">Date</span>())</span><br><span class="line">                <span class="comment">//SECRET加密</span></span><br><span class="line">                .sign(Algorithm.HMAC256(secret));</span><br><span class="line">        <span class="keyword">return</span> jwt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析Jwt</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Claim&gt; <span class="title function_">parseJwt</span><span class="params">(String token)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">JWTVerifier</span> <span class="variable">verifier</span> <span class="operator">=</span> JWT.require(Algorithm.HMAC256(secret)).build();</span><br><span class="line">            <span class="type">DecodedJWT</span> <span class="variable">jwt</span> <span class="operator">=</span> verifier.verify(token);</span><br><span class="line">            <span class="keyword">return</span> jwt.getClaims();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TokenExpiredException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyServiceException</span>(<span class="string">&quot;A0230&quot;</span>, <span class="string">&quot;用户登陆已过期&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JWTVerificationException | IllegalArgumentException e) &#123; <span class="comment">//解析错误 或者 token写错</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyServiceException</span>(<span class="string">&quot;A0200&quot;</span>, <span class="string">&quot;登陆失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="实现增强类"><a href="#实现增强类" class="headerlink" title="实现增强类"></a>实现增强类</h1><p>新建一个<code>AuthAspect</code>切面，用于增强需要鉴权的方法，其定义如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Order(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthAspect</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserService userService;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> JwtConfig jwtConfig;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AuthAspect</span><span class="params">(UserService userService, JwtConfig jwtConfig)</span>&#123;</span><br><span class="line">         <span class="built_in">this</span>.userService = userService;</span><br><span class="line">        <span class="built_in">this</span>.jwtConfig = jwtConfig;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Before(value = &quot;execution(public * com.nju.edu.erp.web.controller.*.*(..)) &amp;&amp; @annotation(authorized)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">authCheck</span><span class="params">(JoinPoint joinPoint, Authorized authorized)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>AuthAspect</code>类有三个注解</p>
<ul>
<li><code>@Aspect</code>：把当前类标识为一个切面供容器读取</li>
<li><code>@Configuration</code>：表明它是一个配置类</li>
<li><code>@Order(1)</code>：用于有多个增强类对同一个方法进行增强的时候表明其优先级，越小优先级越高</li>
</ul>
</li>
<li><p>AuthAspect类除去构造方法外只有一个<code>authChech()</code>方法，它有一个@Before注解</p>
<ul>
<li><code>@Before</code>：标识一个前置增强方法，相当于BeforeAdvice的功能</li>
<li>这个注解的值是检查所有<code>com.nju.edu.erp.web.controller</code>包下所有类public并且被Authorized注解所标注的方法</li>
</ul>
</li>
<li><p><code>authCheck()</code>方法代码如下，主要操作包括：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Before(value = &quot;execution(public * com.nju.edu.erp.web.controller.*.*(..)) &amp;&amp; @annotation(authorized)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">authCheck</span><span class="params">(JoinPoint joinPoint, Authorized authorized)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.获取当前http请求</span></span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">httpServletRequest</span> <span class="operator">=</span> ((ServletRequestAttributes) Objects.requireNonNull(RequestContextHolder.getRequestAttributes())).getRequest();</span><br><span class="line">        <span class="comment">//2.获得Authorized标头，没有则抛出异常</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> Optional.ofNullable(httpServletRequest.getHeader(<span class="string">&quot;Authorization&quot;</span>)).</span><br><span class="line">                orElseThrow(() -&gt; <span class="keyword">new</span> <span class="title class_">MyServiceException</span>(<span class="string">&quot;A0002&quot;</span>, <span class="string">&quot;用户未获得第三方登录授权&quot;</span>));</span><br><span class="line">        <span class="comment">//3.auth方法调用jwtConfig.parseJwt解析出UserVO信息</span></span><br><span class="line">        <span class="type">UserVO</span> <span class="variable">user</span> <span class="operator">=</span> userService.auth(token);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.判断切面方法是否包含当前token对应的角色</span></span><br><span class="line">        <span class="keyword">if</span> (!Arrays.stream(authorized.roles()).collect(Collectors.toList()).contains(user.getRole())) &#123;</span><br><span class="line">            <span class="comment">//5.如果不在就抛出访问未授权的异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyServiceException</span>(<span class="string">&quot;A0003&quot;</span>, <span class="string">&quot;访问未授权&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (MyServiceException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyServiceException</span>(<span class="string">&quot;A0004&quot;</span>, <span class="string">&quot;认证失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="需要鉴权的接口添加-Authorized注解"><a href="#需要鉴权的接口添加-Authorized注解" class="headerlink" title="需要鉴权的接口添加@Authorized注解"></a>需要鉴权的接口添加@Authorized注解</h1><p>controller层对前端来的路由添加<code>Authorized</code>注解进行鉴权，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/create&quot;)</span></span><br><span class="line"><span class="meta">@Authorized(roles = &#123;Role.ADMIN, Role.GM, Role.INVENTORY_MANAGER&#125;)</span></span><br><span class="line"><span class="keyword">public</span> Response <span class="title function_">createCategory</span><span class="params">(<span class="meta">@RequestParam(value = &quot;parentId&quot;)</span> <span class="type">int</span> parentId,</span></span><br><span class="line"><span class="params">                           <span class="meta">@RequestParam(value = &quot;name&quot;)</span> String name)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Response.buildSuccess(categoryService.createCategory(parentId, name));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="添加登录方法"><a href="#添加登录方法" class="headerlink" title="添加登录方法"></a>添加登录方法</h1><p><code>UserService.login</code>登录功能，后端从数据库根据用户名和邮箱进行验证，验证成功调用<code>jwtConfig.createJWT</code>生成JWT，并把这个JWT返回给前端，以后前端每次请求都需要带上这个JWT</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JwtConfig jwtConfig;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceImpl</span><span class="params">(UserDao userDao, JwtConfig jwtConfig)</span>;</span><br><span class="line">  </span><br><span class="line">  	<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, String&gt; <span class="title function_">login</span><span class="params">(UserVO userVO)</span> &#123;</span><br><span class="line">        <span class="type">UserPO</span> <span class="variable">userPO</span> <span class="operator">=</span> userDao.findByNameAndPassword(userVO.getName(), userVO.getPassword());</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == userPO) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyServiceException</span>(<span class="string">&quot;A0000&quot;</span>, <span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;String, String&gt; authToken = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> jwtConfig.createJWT(userPO);</span><br><span class="line">        authToken.put(<span class="string">&quot;token&quot;</span>, token);</span><br><span class="line">        <span class="keyword">return</span> authToken;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">updatePassword</span><span class="params">(UserVO userVO,String newPassword)</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserVO <span class="title function_">auth</span><span class="params">(String token)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="自定义注解-AOP-JWT验证流程总结"><a href="#自定义注解-AOP-JWT验证流程总结" class="headerlink" title="自定义注解+AOP+JWT验证流程总结"></a>自定义注解+AOP+JWT验证流程总结</h1><ol>
<li>调用<code>UserService.login</code>登录功能，后端从数据库根据用户名和邮箱进行验证，验证成功调用<code>jwtConfig.createJWT</code>生成JWT，并把这个JWT返回给前端，以后前端每次请求都需要带上这个JWT</li>
<li>controller层对前端来的路由添加<code>@Authorized</code>注解进行鉴权</li>
<li><code>AuthAspect</code>类对<code>Authorized</code>注解进行增强，<code>@Order</code>注解用于有多个增强类对同一个方法进行增强的时候表明其优先级，越小优先级越高</li>
<li>添加<code>Before</code>方法，用于拦截controller包中所有public并且有<code>@Authorized</code>注解的方法</li>
<li>拦截http请求并获得<code>Authorized</code>标头，调用<code>jwtConfig.parseJwt</code>解析出<code>UserVO</code>信息，判断该<code>UserVO</code>的角色是否在<code>Authorized</code>注解的roles集合中，如果不在就抛出访问未授权的异常</li>
</ol>
<h1 id="JoinPoint常用方法"><a href="#JoinPoint常用方法" class="headerlink" title="JoinPoint常用方法"></a>JoinPoint常用方法</h1><ul>
<li>Object[] getArgs：获取目标方法的参数数组</li>
<li>Signature getSignature：获取目标方法的签名</li>
<li>Object getTarget：获取被织入增强处理的目标对象</li>
<li>Object getThis：获取AOP框架为目标对象生成的代理对象</li>
</ul>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://www.jianshu.com/p/655145478c22">自定义注解+AOP+JWT实现Token拦截验证</a></p>
<p><a href="https://blog.csdn.net/weixin_44299027/article/details/105918873">@Retention的作用和@Target注解的说明以及使用方法</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>AOP</tag>
        <tag>JWT</tag>
        <tag>鉴权</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合的常用方法</title>
    <url>/2023/03/09/JavaCollection/</url>
    <content><![CDATA[<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/collection/java-collection-hierarchy.png" loading="lazy"></p>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//save without order</span></span><br><span class="line">HashMap&lt;Integer,String&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//put a new key-value entry if not existing before;</span></span><br><span class="line"><span class="comment">//replace the old value if existing such a key;</span></span><br><span class="line"><span class="comment">//return the old value or null if not existing</span></span><br><span class="line">hashMap.put(<span class="number">1</span>,<span class="string">&quot;my value is 1&quot;</span>);</span><br><span class="line"><span class="comment">//put a new entry only if there was no such key before</span></span><br><span class="line">hashMap.putIfAbsent(<span class="number">1</span>,<span class="string">&quot;my value is 1&quot;</span>);</span><br><span class="line">hashMap.remove(<span class="number">1</span>); <span class="comment">//remove the entry whose key is 1</span></span><br><span class="line">hashMap.remove(<span class="number">1</span>,<span class="string">&quot;my value is 2&quot;</span>); <span class="comment">//remove the entry whose key is 1 and value is &quot;my value is 2&quot;</span></span><br><span class="line">hashMap.get(<span class="number">1</span>); <span class="comment">//return the value whose key is 1</span></span><br><span class="line">hashMap.containsKey(<span class="number">1</span>);</span><br><span class="line">hashMap.containsValue(<span class="string">&quot;whose value is 2&quot;</span>);</span><br><span class="line">hashMap.forEach((key1, value1) -&gt; &#123;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//save with order</span></span><br><span class="line">TreeMap&lt;Integer,String&gt; treeMap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;((a,b)-&gt;&#123;</span><br><span class="line">      <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//save without order</span></span><br><span class="line">HashSet&lt;Integer&gt; integerSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"><span class="type">boolean</span> <span class="variable">addReturn</span> <span class="operator">=</span>  integerSet.add(<span class="number">1</span>); <span class="comment">// true if set doesn&#x27;t contain target</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">containReturn</span> <span class="operator">=</span>  integerSet.contains(<span class="number">3</span>); <span class="comment">// true if set contains target</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">removeReturn</span> <span class="operator">=</span> integerSet.remove(<span class="number">4</span>);  <span class="comment">// true if set contains target</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEmptyReturn</span> <span class="operator">=</span>  integerSet.isEmpty();   <span class="comment">// true if set is empty</span></span><br><span class="line"><span class="comment">//save with order, and you can define your specific comparator using lambda expression</span></span><br><span class="line">TreeSet&lt;Integer&gt; integerTreeSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;((a,b)-&gt;&#123;</span><br><span class="line">     <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedList&lt;Integer&gt; linkedList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="type">Integer</span> <span class="variable">temp</span> <span class="operator">=</span> linkedList.indexOf(<span class="number">2</span>); <span class="comment">//return the index of target object if exists else return false</span></span><br><span class="line">linkedList.remove((Object) <span class="number">2</span>); <span class="comment">//remove the object 2</span></span><br><span class="line">linkedList.remove(<span class="number">2</span>);<span class="comment">//remove the element whose index is 2</span></span><br><span class="line"><span class="comment">//Queue operations: add from tail and get from head, FIFO</span></span><br><span class="line">linkedList.offer(<span class="number">1</span>);    <span class="comment">// add target from tail</span></span><br><span class="line">temp = linkedList.peek(); <span class="comment">//simply return the head element of the list</span></span><br><span class="line">temp = linkedList.poll(); <span class="comment">//return the head element of the list and remove it</span></span><br><span class="line"><span class="comment">//Deque operations: add and get from both ends</span></span><br><span class="line">linkedList.offerFirst(<span class="number">1</span>); <span class="comment">//add from first</span></span><br><span class="line">linkedList.offerLast(<span class="number">2</span>);  <span class="comment">//add from last</span></span><br><span class="line">temp = linkedList.peekFirst();  <span class="comment">//peek from first</span></span><br><span class="line">temp = linkedList.peekLast();   <span class="comment">//peek from last</span></span><br><span class="line">temp = linkedList.pollFirst();  <span class="comment">//poll from first</span></span><br><span class="line">temp = linkedList.pollLast();   <span class="comment">//poll from last</span></span><br><span class="line">Collections.sort(linkedList);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Stack operations:add and get from the same end, LIFO</span></span><br><span class="line">Stack&lt;Integer&gt; intStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">intStack.push(<span class="number">1</span>);   <span class="comment">//push the target onto the stack</span></span><br><span class="line">intStack.push(<span class="number">2</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> intStack.pop();  <span class="comment">//return the element at the top of the stack and remove that element</span></span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> intStack.peek(); <span class="comment">//return the element at the top of the stack</span></span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> intStack.search(<span class="number">2</span>);   <span class="comment">//return the index of target object if it&#x27;s in the stack else return -1</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEmpty</span> <span class="operator">=</span> intStack.isEmpty(); <span class="comment">//return true if stack is empty else return false</span></span><br></pre></td></tr></table></figure>

<h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//this is a max heap</span></span><br><span class="line">PriorityQueue&lt;Integer&gt; priorityQueue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b)-&gt;&#123;</span><br><span class="line">      <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;);</span><br><span class="line">priorityQueue.offer(<span class="number">1</span>); <span class="comment">//insert the target</span></span><br><span class="line">priorityQueue.peek(); <span class="comment">//return the max/min element decided by its type</span></span><br><span class="line">priorityQueue.poll(); <span class="comment">//return the max/min element and remove it</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程(2)</title>
    <url>/2023/03/08/JavaConcurrent2/</url>
    <content><![CDATA[<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><h2 id="ThreadLocal有什么用"><a href="#ThreadLocal有什么用" class="headerlink" title="ThreadLocal有什么用"></a>ThreadLocal有什么用</h2><ul>
<li>实现每个线程都有自己的专属本地变量，让每个线程绑定自己的值</li>
</ul>
<h2 id="如何使用ThreadLocal"><a href="#如何使用ThreadLocal" class="headerlink" title="如何使用ThreadLocal"></a>如何使用ThreadLocal</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">            threadLocal.set(<span class="string">&quot;This is in main thread&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread Name: &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;---&quot;</span> + threadLocal.get());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Thread A</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                    threadLocal.set(<span class="string">&quot;This is in A thread&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread Name: &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;---&quot;</span> + threadLocal.get());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Thread B</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                threadLocal.set(<span class="string">&quot;This is in B thread&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread Name: &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;---&quot;</span> + threadLocal.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Thread C</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                threadLocal.set(<span class="string">&quot;This is in C thread&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread Name: &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;---&quot;</span> + threadLocal.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ThreadLocal原理"><a href="#ThreadLocal原理" class="headerlink" title="ThreadLocal原理"></a>ThreadLocal原理</h2><ul>
<li><code>Thread</code>类的源码<ul>
<li>持有<code>threadLocals</code>和<code>inheritableThreadLocals</code>两个变量，它们是<code>ThreadLocalMap</code>类型的</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">  <span class="comment">//用于维护该线程的threadLocal</span></span><br><span class="line">	ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">inheritableThreadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ThreadLocal</code>类的<code>set()</code>方法<ul>
<li>可以看出<code>ThreadLocal</code>类其实是对<code>ThreadLocalMap</code>的封装，传入的值最终会放在<code>Thread</code>类里的<code>threadLocals</code>这个变量里</li>
<li><code>threadLocals</code>这个变量是<code>ThreadLocalMap</code>类型的，其中<code>ThreadLocalMap</code>又是<code>ThreadLocal</code>类的一个静态类（这里比较绕）</li>
<li>最终<code>Thread</code>类的<code>threadLocals</code>里存放的是以<code>&lt;ThreadLocal, Object&gt;</code>的键值对</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span>&#123;</span><br><span class="line">  <span class="comment">//获取当前线程</span></span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">  <span class="comment">//获取当前线程的threadlocals变量</span></span><br><span class="line">  <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">  <span class="keyword">if</span>(map != <span class="literal">null</span>)</span><br><span class="line">    map.set(<span class="built_in">this</span>,value); <span class="comment">//存放进去，这里的this就是这个ThreadLocal对象</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    createMap(t,value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>一个线程可以有多个<code>ThreadLocal</code>实例，声明多个<code>ThreadLocal</code>变量即可，它们都存放在<code>Tread</code>类的<code>threadLocals</code>变量里，并以<code>ThreadLocal</code>的实例为键名取出对应的副本值</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>ThreadLocal</code>实现了对私有变量的封装，我们可以不用直接对<code>Thread</code>的<code>ThreadLocalMap</code>进行操作，而只需像对待共享变量一样操作私有变量即可，因为封装在<code>ThreadLocal</code>里的方法会帮我们从对应的<code>Thread</code>类的<code>threadLocals</code>变量里获取或更改这个变量的值，其中<code>threadLocals</code>变量是<code>ThreadLocalMap</code>类型的，存放的是<code>&lt;ThreadLocal, Object&gt;</code>的键值对，<code>ThreadLocal</code>的实例以自身为键名访问线程的<code>treadLocals</code>变量以获得该私有变量在该线程下的副本值</p>
<h2 id="ThreadLocal内存泄漏问题是怎么导致的"><a href="#ThreadLocal内存泄漏问题是怎么导致的" class="headerlink" title="ThreadLocal内存泄漏问题是怎么导致的"></a>ThreadLocal内存泄漏问题是怎么导致的</h2><ul>
<li><code>ThreadLocalMap</code>中使用的key值为<code>ThreadLocal</code>的弱引用，而value是强引用</li>
<li>如果<code>ThreadLocal</code>没有外部强引用的情况下，在垃圾回收的时候，key会被清理掉而value不会</li>
<li><code>ThreadLocalMap</code>中会出现key为null的Entry，如果我们不做任何措施的话，value就无法被GC回收，因此会产生内存泄漏</li>
<li><code>ThreadLocalMap</code>实现中考虑了该情况，在调用<code>set</code>、<code>get</code>、<code>remove</code>方法时会清理掉key为null的记录，但是用了玩<code>ThreadLocal</code>方法后最好手动调用<code>remove</code>方法</li>
</ul>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="什么是线程池"><a href="#什么是线程池" class="headerlink" title="什么是线程池"></a>什么是线程池</h2><p>线程池是管理一系列线程的资源池。当有任务要处理时，直接从线程池获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务</p>
<h2 id="为什么要用线程池"><a href="#为什么要用线程池" class="headerlink" title="为什么要用线程池"></a>为什么要用线程池</h2><ul>
<li><p>池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率</p>
</li>
<li><p>线程池提供了一种限制和管理资源（包括执行一个任务）的方式，每个线程池还维护一些基本统计信息</p>
</li>
<li><p>使用线程池的好处：</p>
<ul>
<li><p>降低资源消耗</p>
</li>
<li><p>提高响应速度</p>
</li>
<li><p>提高线程的可管理性</p>
</li>
<li><p>提供更多更强大的功能</p>
</li>
</ul>
</li>
</ul>
<h2 id="如何创建线程池"><a href="#如何创建线程池" class="headerlink" title="如何创建线程池"></a>如何创建线程池</h2><ol>
<li>通过<code>ThreadPoolExecutor</code>构造函数来创建（推荐）</li>
<li>通过Java内置<code>Executor</code>框架的工具类<code>Executors</code>来创建（不推荐）<ul>
<li><strong><code>FixedThreadPool</code></strong> ： 该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li>
<li><strong><code>SingleThreadExecutor</code>：</strong> 该方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li>
<li><strong><code>CachedThreadPool</code>：</strong> 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</li>
<li><strong><code>ScheduledThreadPool</code></strong> ：该返回一个用来在给定的延迟后运行任务或者定期执行任务的线程池</li>
</ul>
</li>
</ol>
<h2 id="为什么不推荐使用内置线程池"><a href="#为什么不推荐使用内置线程池" class="headerlink" title="为什么不推荐使用内置线程池"></a>为什么不推荐使用内置线程池</h2><p>《阿里巴巴Java开发手册》中不允许使用<code>Executors</code>创建，而是通过<code>ThreadPoolExecutor</code>构造函数的方式，这样让<strong>写的同学更加明确线程池的运行规则，规避资源耗尽的风险</strong></p>
<p><code>Executors</code>返回的线程池对象的弊端如下：</p>
<ul>
<li><strong><code>FixedThreadPool</code> 和 <code>SingleThreadExecutor</code></strong> ： 使用的是无界的 <code>LinkedBlockingQueue</code>，任务队列最大长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li>
<li><strong><code>CachedThreadPool</code></strong> ：使用的是同步队列 <code>SynchronousQueue</code>, 允许创建的线程数量为 <code>Integer.MAX_VALUE</code> ，可能会创建大量线程，从而导致 OOM。</li>
<li><strong><code>ScheduledThreadPool</code> 和 <code>SingleThreadScheduledExecutor</code></strong> : 使用的无界的延迟阻塞队列<code>DelayedWorkQueue</code>，任务队列最大长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li>
</ul>
<h2 id="线程池常见参数有哪些"><a href="#线程池常见参数有哪些" class="headerlink" title="线程池常见参数有哪些"></a>线程池常见参数有哪些</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用给定的初始参数创建一个新的ThreadPoolExecutor。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,//线程池的核心线程数量</span></span><br><span class="line"><span class="params">                              <span class="type">int</span> maximumPoolSize,//线程池的最大线程数</span></span><br><span class="line"><span class="params">                              <span class="type">long</span> keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span></span><br><span class="line"><span class="params">                              TimeUnit unit,//时间单位</span></span><br><span class="line"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,//任务队列，用来储存等待执行任务的队列</span></span><br><span class="line"><span class="params">                              ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可</span></span><br><span class="line"><span class="params">                              RejectedExecutionHandler handler//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span></span><br><span class="line"><span class="params">                               )</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">            keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        <span class="keyword">if</span> (workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">        <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">        <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">        <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">        <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">        <span class="built_in">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>3个最重要的参数<ul>
<li>corePoolSize：任务队列未达到队列容量时，最大可以同时运行的线程数量</li>
<li>maximumPoolSize：任务队列达到队列容量时，当前可以同时运行的线程数量变为最大线程数</li>
<li>workQueue：新任务来的时候先判断当前运行的线程数量是否达到核心线程数，如果达到则新任务会被存放在队列中</li>
</ul>
</li>
<li>其他常见参数<ul>
<li>keepAliveTime：线程池中的线程数量大于corePoolSize的时候，如果没有新的任务提交，核心线程外的线程不会被立即销毁，待等待时间超过该参数后才会被回收销毁</li>
<li>unit：keepAliveTime参数的时间单位</li>
<li>threadFactory：executor创建新县城的时候用到</li>
<li>handler：饱和策略</li>
</ul>
</li>
</ul>
<h2 id="线程池的饱和策略有哪些"><a href="#线程池的饱和策略有哪些" class="headerlink" title="线程池的饱和策略有哪些"></a>线程池的饱和策略有哪些</h2><p><img src="https://p0.meituan.net/travelcube/9ffb64cc4c64c0cb8d38dac01c89c905178456.png" loading="lazy"></p>
<h2 id="线程池常用的阻塞队列有哪些"><a href="#线程池常用的阻塞队列有哪些" class="headerlink" title="线程池常用的阻塞队列有哪些"></a>线程池常用的阻塞队列有哪些</h2><p>新任务到达时会先判断当前运行的线程数量是否达到核心线程数，如果达到则新任务会被存放在队列中</p>
<p>不同的线程池会选用不同的阻塞队列</p>
<ul>
<li>容量为Intger.MAX_VALUE的LinkedBlockingQueue（无界队列）：FixedThreadPool和SingleThreadExector。由于队列永远不会被放满，因此FixesThreadPool最多只能创建核心线程数的线程</li>
<li>SychronousQueue(同步队列)：CachedThreadPool。SynchronousQueue没有容量，不存储新元素，目的是保证对于提交的任务，如果有空闲线程，则使用空闲线程来处理，否则就新建一个线程来处理任务，也就是说CachedThreadPool的最大线程数是Integer.MAX_VALUE，可以理解为线程数是可以无限扩展的，可能会创建大量线程，从而导致OOM</li>
<li>DelayedWorkQueue（延迟阻塞队列）：ScheduledThreadPool和SIngleThreadScheduledExecutor。DelayedWorkQueue的内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是堆的数据结构，可以保证每次出队的任务是当前队列中执行时间最靠前的。DelayedWorkQueue添加元素满了之后会自动扩容到原来容量的1&#x2F;2，即永远不会阻塞，最大扩容可达Integer.MAX_VALUE，所以最多只能创建核心线程数的线程</li>
</ul>
<p><img src="https://p0.meituan.net/travelcube/725a3db5114d95675f2098c12dc331c3316963.png" loading="lazy"></p>
<h2 id="线程池处理任务的流程"><a href="#线程池处理任务的流程" class="headerlink" title="线程池处理任务的流程"></a>线程池处理任务的流程</h2><p><img src="https://p0.meituan.net/travelcube/31bad766983e212431077ca8da92762050214.png" loading="lazy"></p>
<h2 id="如何给线程池命名"><a href="#如何给线程池命名" class="headerlink" title="如何给线程池命名"></a>如何给线程池命名</h2><p>给线程池命名有利于定位问题</p>
<ol>
<li><p>利用guava的ThreadFactoryBuilder</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ThreadFactory</span> <span class="variable">threadFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadFactoryBuilder</span>().setNameFormat(threadNamePrefix + <span class="string">&quot;-%d&quot;</span>).setDaemon(<span class="literal">true</span>).build();</span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(corePoolSize,maximumPoolSize,KeepAliveTime,TimeUnit.MINUTES,workQueue,threadFactory);</span><br></pre></td></tr></table></figure>
</li>
<li><p>自己实现ThreadFactory</p>
</li>
</ol>
<h2 id="如何设定线程池的大小"><a href="#如何设定线程池的大小" class="headerlink" title="如何设定线程池的大小"></a>如何设定线程池的大小</h2><p>判断是CPU密集型任务（N+1）还是I&#x2F;O密集型任务（2N）</p>
<p>线程数计算方法：N（CPU核数）* （线程运行总时间&#x2F;ST（线程计算时间））</p>
<h2 id="如何动态修改线程池的参数"><a href="#如何动态修改线程池的参数" class="headerlink" title="如何动态修改线程池的参数"></a>如何动态修改线程池的参数</h2><p>配置三个核心参数：</p>
<ul>
<li><p>corePoolSize：调用setCorePoolSize()方法</p>
<p><img src="https://p0.meituan.net/travelcube/9379fe1666818237f842138812bf63bd85645.png" loading="lazy"></p>
</li>
<li><p>maximumPoolSize：调用setMaximumPoolSize()方法</p>
</li>
<li><p>workQueue：美团通过自定义一个ResizableCapacityLinkedBlockIngQueue的队列，主要是为了把LinkedBlockingQueue的capacity字段的final关键字去掉</p>
</li>
</ul>
<h2 id="线程池被创建后里面有线程吗？"><a href="#线程池被创建后里面有线程吗？" class="headerlink" title="线程池被创建后里面有线程吗？"></a>线程池被创建后里面有线程吗？</h2><p>线程池被创建后如果没有任务过来，里面是不会有线程的</p>
<p>如果需要预热的话可以调用下面两个方法：</p>
<ul>
<li><p><code>prestartAllCoreThreads</code>：全部启动	</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/lnCqjsQ6QHfBqOxop3hDOhKCOm6v4MXYvdzS6VCjKicoib5eGJgeW9wPEnt9Zk1YEspKYaVPI5ZEqlibCWQ7Rofdw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" loading="lazy"></p>
</li>
<li><p><code>preastartCoreThread</code>：仅启动一个</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/lnCqjsQ6QHfBqOxop3hDOhKCOm6v4MXYQUPFNiaw7bjF5RsHSkAib2HE9vlNq2R6dN4U5OicOcLJ29ZvotUm3jdGA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" loading="lazy"></p>
</li>
</ul>
<h2 id="核心线程会被回收吗"><a href="#核心线程会被回收吗" class="headerlink" title="核心线程会被回收吗"></a>核心线程会被回收吗</h2><p>核心线程默认是不会被回收的，如果需要回收核心线程数，需要调用：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/lnCqjsQ6QHfBqOxop3hDOhKCOm6v4MXYVTBfSHpeUKaRL64ZwrN6sAMMsPD3XvILspTG405TMIgPtTiaV84fexQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" loading="lazy"></p>
<p>其中<code>allowCoreThreadTimeOut</code>该值默认为false</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/lnCqjsQ6QHfBqOxop3hDOhKCOm6v4MXYOedP5u7d1L7oQpsvCq73M9hII5zoZmEnxZpHgK396mytTY4qEkiaibaw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" loading="lazy"></p>
<h1 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h1><h2 id="Future类有什么用"><a href="#Future类有什么用" class="headerlink" title="Future类有什么用"></a>Future类有什么用</h2><p>当主线程执行某一耗时任务时，可以将该耗时任务交给一个子线程去异步执行，主线程可以继续执行后续的任务，再通过<code>Future</code>类获取到耗时任务的执行结果，使得程序的执行效率获得明显提高</p>
<p>这是多线程中的一种设计模式，即<strong>Future模式</strong>，核心思想是<strong>异步调用</strong></p>
<p>Java中<code>Future</code>类只是一个泛型接口，位于<code>java.util.concurrent</code>包下，定义了5个方法，包括4个功能</p>
<ul>
<li>取消任务</li>
<li>判断任务是否被取消</li>
<li>判断任务是否已经执行完成</li>
<li>获取任务执行结果</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Future</span>&lt;V&gt;&#123;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span>;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">isCancelled</span><span class="params">()</span>;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span>;</span><br><span class="line">  V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line">  V <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException,TimeoutException</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Callable和Future有什么关系"><a href="#Callable和Future有什么关系" class="headerlink" title="Callable和Future有什么关系"></a>Callable和Future有什么关系</h2><h2 id="CompletableFuture类有什么用"><a href="#CompletableFuture类有什么用" class="headerlink" title="CompletableFuture类有什么用"></a>CompletableFuture类有什么用</h2><p><code>CompletableFuture</code>提供函数式编程、异步任务编排组合（可以将多个异步任务串联起来，组成一个完整的链式调用）等能力</p>
<p>人话：CompletableFuture支持添加回掉函数，即子线程执行完成后自行调用后续回掉函数，而不需要像Future类需要主线程去询问其是否执行完</p>
<p><code>CompletableFuture</code>同时实现了<code>Future</code>和<code>CompletionStage</code>接口</p>
<p>CompletionStage接口描述了一个异步计算的阶段，很多计算可以分成多个阶段或步骤，此时可以通过它将所有步骤组合起来，形成异步计算的流水线</p>
<h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><h2 id="AQS是什么"><a href="#AQS是什么" class="headerlink" title="AQS是什么"></a>AQS是什么</h2><p>AQS的全称为AbstarctQueuedSynchronizer，即抽象队列同步器</p>
<p>AQS是一个抽象类，主要用于构建锁和同步器</p>
<h2 id="Semaphore有什么用"><a href="#Semaphore有什么用" class="headerlink" title="Semaphore有什么用"></a>Semaphore有什么用</h2><p><code>synchronized</code>和<code>ReentrantLock</code>都是一次只允许一个线程访问某个资源，而<code>Semaphore</code>可以用来控制同时访问特定资源的线程数量</p>
<p><code>Semaphore</code>有公平模式（FIFO）和非公平模式（抢占式的）</p>
<h2 id="Semaphore的原理是什么"><a href="#Semaphore的原理是什么" class="headerlink" title="Semaphore的原理是什么"></a>Semaphore的原理是什么</h2><p><code>Semaphore</code>是共享锁的一种实现，它默认构造AQS的<code>state</code>值为<code>permits</code></p>
<p>调用semaphore.acquire()，线程尝试获取许可证，如果state-1&gt;&#x3D;0，则表示可以获取，使用CAS操作修改state&#x3D;state-1；如果state-1&lt;0，则获取失败，此时创建一个Node节点加入阻塞队列，挂起当前线程</p>
<p>调用semaphore.release()，线程尝试释放许可证，使用CAS操作修改state&#x3D;state+1。成功释放后会唤醒阻塞队列中的一个线程，被唤醒的线程会重新尝试修改state的值state&#x3D;state-1，如果state&gt;&#x3D;0则获取成功，否则重新进入阻塞队列，挂起线程</p>
<h2 id="CountDownLatch有什么用"><a href="#CountDownLatch有什么用" class="headerlink" title="CountDownLatch有什么用"></a>CountDownLatch有什么用</h2><p><code>CountDownLatch</code>允许<code>count</code>个线程阻塞在一个地方，直至这<code>count</code>个线程都执行完成。</p>
<p><code>CountDownLatch</code>是<strong>一次性的</strong>，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，即当<code>CountDownLatch</code>使用完毕后，<strong>它不能再次被使用</strong></p>
<h2 id="CountDownLatch的原理是什么"><a href="#CountDownLatch的原理是什么" class="headerlink" title="CountDownLatch的原理是什么"></a>CountDownLatch的原理是什么</h2><ol>
<li>线程使用<code>CountDown()</code>方法时，使用了<code>tryReleaseShared</code>方法以CAS的操作来减少<code>state</code>，直至<code>state</code>为0</li>
<li>当调用<code>await()</code>方法时，如果<code>state</code>不为0，说明所有的任务还没有执行完毕，<code>await()</code>方法就会一直阻塞，即<code>await()</code>方法后的语句不会被执行</li>
<li><code>CountDownLatch</code>会自旋CAS判断<code>state==0</code>，如果<code>state==0</code>就会释放所有等待的线程，<code>await()</code>方法之后的语句得到执行</li>
</ol>
<h2 id="CyclicBarrier有什么用"><a href="#CyclicBarrier有什么用" class="headerlink" title="CyclicBarrier有什么用"></a>CyclicBarrier有什么用</h2><p><code>CyclicBarrier</code>，即可循环使用(Cyclic)的屏障(Barrier)让一组线程到达一个屏障时被阻塞，直到最后一个线程到达屏障，屏障才会开门，所有被屏障拦截的线程才会继续执行</p>
<h2 id="CyclicBarrier的原理是什么"><a href="#CyclicBarrier的原理是什么" class="headerlink" title="CyclicBarrier的原理是什么"></a>CyclicBarrier的原理是什么</h2><ol>
<li>CyclicBarrier以一个count变量作为计数器，count的初始值为parties属性的初始化值</li>
<li>每当一个线程到屏障这里，就将计数器减一</li>
<li>如果count的值为0，表示这是这一代最后一个线程到达屏障</li>
<li>然后尝试执行构造方法中输入的任务</li>
</ol>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol>
<li><a href="https://zhuanlan.zhihu.com/p/158033837">https://zhuanlan.zhihu.com/p/158033837</a></li>
<li><a href="https://javaguide.cn/java/concurrent/java-concurrent-questions-03.html#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E6%B1%A0">https://javaguide.cn/java/concurrent/java-concurrent-questions-03.html#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E6%B1%A0</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=Mzg3NjU3NTkwMQ==&mid=2247505103&idx=1&sn=a041dbec689cec4f1bbc99220baa7219&source=41#wechat_redirect">https://mp.weixin.qq.com/s?__biz=Mzg3NjU3NTkwMQ==&amp;mid=2247505103&amp;idx=1&amp;sn=a041dbec689cec4f1bbc99220baa7219&amp;source=41#wechat_redirect</a></li>
<li>《Java并发编程的艺术》</li>
</ol>
]]></content>
      <categories>
        <category>八股</category>
      </categories>
      <tags>
        <tag>Java并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程(1)</title>
    <url>/2023/03/08/JavaConcurrrent1/</url>
    <content><![CDATA[<blockquote>
<p>本文主要摘自JavaGuide面试指南，笔者根据自身的实际情况进行了一定的删改。原文链接：<a href="https://javaguide.cn/java/concurrent/java-concurrent-questions-02.html">https://javaguide.cn/java/concurrent/java-concurrent-questions-02.html</a></p>
</blockquote>
<h1 id="为什么要使用多线程？"><a href="#为什么要使用多线程？" class="headerlink" title="为什么要使用多线程？"></a>为什么要使用多线程？</h1><ul>
<li>线程可以看作是轻量级的进程，是程序执行的最小单位，线程间的切换和调度成本远远小于进程</li>
<li>多线程可以提高进程利用单核&#x2F;多核CPU效率，提高系统整体的并发能力以及性能</li>
</ul>
<h1 id="多线程可能带来的问题？"><a href="#多线程可能带来的问题？" class="headerlink" title="多线程可能带来的问题？"></a>多线程可能带来的问题？</h1><p>并发编程并不总能提高程序运行速度，而且并发编程可能会遇到很多问题，比如：内存泄漏、死锁、线程不安全等</p>
<h1 id="说说线程的生命周期和状态？"><a href="#说说线程的生命周期和状态？" class="headerlink" title="说说线程的生命周期和状态？"></a>说说线程的生命周期和状态？</h1><ul>
<li>NEW：初始状态，线程被创建出来但没有被调用<code>start()</code></li>
<li>RUNNABLE：运行状态，线程被调用了<code>start()</code></li>
<li>BLOCKED：阻塞状态，需要等待锁释放</li>
<li>WAITING：等待状态，表示该线程需要等待其他线程的通知</li>
<li>TIME_WAITING：超时等待状态，在指定时间后回到RUNNABLE状态</li>
<li>TERMINATED：终止状态，表示该线程已经运行完毕</li>
</ul>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/concurrent/640.png" loading="lazy"></p>
<h1 id="什么是上下文切换？其流程是什么"><a href="#什么是上下文切换？其流程是什么" class="headerlink" title="什么是上下文切换？其流程是什么"></a>什么是上下文切换？其流程是什么</h1><p>上下文：线程在执行过程中自己的运行条件和状态，比如程序计数器、栈信息等</p>
<p>上下文切换：保存当前线程的上下文，留待线程下次占用CPU时恢复现场，并加载下一个将要占用CPU的线程上下文</p>
<p>以下情况会发生线程切换：</p>
<ul>
<li>主动让出CPU，比如调用了<code>sleep()</code>，<code>wait()</code>等</li>
<li>时间片用完</li>
<li>调用了阻塞类型的系统中断</li>
</ul>
<h1 id="什么是线程死锁？如何避免死锁？"><a href="#什么是线程死锁？如何避免死锁？" class="headerlink" title="什么是线程死锁？如何避免死锁？"></a>什么是线程死锁？如何避免死锁？</h1><p>线程死锁：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放</p>
<h2 id="产生死锁的四个必要条件"><a href="#产生死锁的四个必要条件" class="headerlink" title="产生死锁的四个必要条件"></a>产生死锁的四个必要条件</h2><ul>
<li>互斥条件：一个资源任意时刻只有一个线程占用</li>
<li>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放</li>
<li>不可剥夺条件：线程已获得的资源在未使用完之前不能被其他线程强行剥夺</li>
<li>循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系</li>
</ul>
<h2 id="如何预防死锁"><a href="#如何预防死锁" class="headerlink" title="如何预防死锁"></a>如何预防死锁</h2><p>破坏死锁的产生的必要条件：</p>
<ul>
<li>破坏请求与保持条件：一次性申请所有的资源</li>
<li>破坏不可剥夺条件：线程如果申请不到其他资源时，可以主动释放其占有的资源</li>
<li>破坏循环等待条件：按某一顺序申请资源，释放时反序释放</li>
</ul>
<h2 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁"></a>如何避免死锁</h2><p>在资源分配时，借助于算法（如银行家算法）对资源分配进行计算评估，使其进入安全状态。</p>
<p>安全状态：系统按照某种线程推进顺序来为每个线程分配所需资源，每个线程都可顺利完成，则为安全状态，该推进顺序为一个安全序列。</p>
<h1 id="sleep-方法和wait-方法的对比？"><a href="#sleep-方法和wait-方法的对比？" class="headerlink" title="sleep()方法和wait()方法的对比？"></a>sleep()方法和wait()方法的对比？</h1><p>相同：两者都可以暂停线程的执行</p>
<p>区别：</p>
<ul>
<li><code>sleep()</code>方法没有释放锁，而<code>wait()</code>方法释放了锁</li>
<li><code>wait()</code>通常用于线程间交互&#x2F;通信，<code>sleep()</code>通常被用于暂停执行</li>
<li><code>wait()</code>方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的<code>notify()</code>或者<code>notifyAll()</code>方法；sleep()方法执行完成后，线程会自动苏醒，或者使用<code>wait(long timeout)</code>超时后线程会自动苏醒</li>
<li><code>sleep()</code>是Thread类的静态本地方法，<code>wait()</code>则是Object类的本地方法</li>
</ul>
<h2 id="为什么wait-方法不定义在Thread中？"><a href="#为什么wait-方法不定义在Thread中？" class="headerlink" title="为什么wait()方法不定义在Thread中？"></a>为什么wait()方法不定义在Thread中？</h2><p><code>wait()</code>是让获得对象锁的线程实现等待，实现进程间的同步，会自动释放当前线程占有的对象锁。每个对象(Object)都拥有对象锁，既然要释放当前线程占有的对象锁并让其进入WAITING状态，因此需要操作对应的对象(Object)而非当前的线程(Thread)</p>
<h2 id="为什么sleep-方法定义在Thread中"><a href="#为什么sleep-方法定义在Thread中" class="headerlink" title="为什么sleep()方法定义在Thread中"></a>为什么sleep()方法定义在Thread中</h2><p><code>sleep()</code>是让当前线程暂停执行，不涉及到对象类，也不需要获得对象锁</p>
<h1 id="可以直接调用Thread类的run方法吗？"><a href="#可以直接调用Thread类的run方法吗？" class="headerlink" title="可以直接调用Thread类的run方法吗？"></a>可以直接调用Thread类的run方法吗？</h1><p><strong>调用start()方法可启动线程并使线程进入就绪状态，但直接执行run()方法不会以多线程的方式执行</strong>。</p>
<p>new一个Thread，线程进入新建状态。调用<code>start()</code>方法，会启动该线程并进入RUNNABLE状态。<code>start()</code>会执行线程的相应准备工作，然后自动执行<code>run()</code>方法的内容，只是真正的多线程工作。但是直接调用<code>run()</code>方法，会把<code>run()</code>方法当成一个main线程下的普通方法去执行，并不会在某个线程中执行它，所以并不是多线程工作</p>
<h1 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h1><p><code>volatile</code>关键字作用：</p>
<ol>
<li>保证变量的可见性</li>
<li>防止JVM的指令重排序</li>
</ol>
<h2 id="如何保证变量的可见性？"><a href="#如何保证变量的可见性？" class="headerlink" title="如何保证变量的可见性？"></a>如何保证变量的可见性？</h2><p><code>volatile</code>关键字可以保证变量的可见性，其指示JVM，被该关键字修饰的变量是共享且不稳定的，每次使用它都需要到主存(主内存)中进行读取，即禁止使用缓存</p>
<p><code>volatile</code>关键字能保证数据的可见性，但不能保证数据的原子性，<code>synchronized</code>关键字两者都能保证</p>
<ul>
<li>可见性，一个线程对变量的修改会被实时写回至主存中，对于其他线程来说可以实时得到其修改后的值</li>
<li>原子性，一条指令的所有操作，要么全做，要么全不做</li>
</ul>
<h2 id="如何禁止指令重排序？"><a href="#如何禁止指令重排序？" class="headerlink" title="如何禁止指令重排序？"></a>如何禁止指令重排序？</h2><ul>
<li><p><code>volatile</code>关键字可以防止JVM的指令重排序，如果将变量声明为<code>volatile</code>，在对这个变量进行读写操作的时候，会通过插入特定的 <strong>内存屏障</strong> 的方式来禁止指令重排序</p>
</li>
<li><p>Java中的<code>Unsafe</code>类提供三个内存屏障相关的方法，通过这三个方法也可以实现禁止指令重排序的的效果，但相对麻烦一些</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">loadFence</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">storeFence</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">fullFence</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="volatile可以保证原子性吗？"><a href="#volatile可以保证原子性吗？" class="headerlink" title="volatile可以保证原子性吗？"></a>volatile可以保证原子性吗？</h2><p><code>volatile</code>关键字能保证变量的可见性，但不能保证对变量操作的原子性，可以使用<code>synchronized</code>或者<code>lock</code>。</p>
<h1 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h1><h2 id="什么是悲观锁？使用场景是什么？"><a href="#什么是悲观锁？使用场景是什么？" class="headerlink" title="什么是悲观锁？使用场景是什么？"></a>什么是悲观锁？使用场景是什么？</h2><ul>
<li><p><strong>悲观锁：</strong>总是假设最坏的情况，认为共享资源每次被访问时会发生问题，所以每次获取资源操作时会上锁，其他线程尝试获取该资源时会被阻塞，<strong>即共享资源每次只给一个线程使用，其他线程阻塞，用完后再把资源转让给其他线程。</strong></p>
</li>
<li><p>Java中的<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现</p>
</li>
<li><p><strong>悲观锁通常多用于多写场景，避免频繁失败和重试影响性能</strong></p>
</li>
</ul>
<h2 id="什么是乐观锁？使用场景是什么？"><a href="#什么是乐观锁？使用场景是什么？" class="headerlink" title="什么是乐观锁？使用场景是什么？"></a>什么是乐观锁？使用场景是什么？</h2><ul>
<li><p><strong>乐观锁</strong>：总是假设最好的情况，认为共享资源每次被访问时不会发生问题，线程可以不停地执行，无需加锁也无需等待，只是<strong>在提交修改时验证对应的资源(数据)是否被其他线程修改</strong>（具体可用版本号机制或CAS算法）</p>
</li>
<li><p>Java中<code>java.util.concurrent.atomic</code>包下的原子变量类就是使用乐观锁的一种实现方式CAS实现的</p>
</li>
<li><p><strong>乐观锁通常多用于多读场景，避免频繁加锁影响性能，大大提升系统的吞吐量</strong></p>
</li>
</ul>
<h2 id="如何实现乐观锁？"><a href="#如何实现乐观锁？" class="headerlink" title="如何实现乐观锁？"></a>如何实现乐观锁？</h2><p>乐观锁一般使用<strong>版本号机制</strong>或<strong>CAS算法</strong>实现</p>
<h3 id="版本号机制"><a href="#版本号机制" class="headerlink" title="版本号机制"></a>版本号机制</h3><p>一般是在数据表中加上一个数据版本号<code>version</code>字段，表示数据被修改的次数。当数据被修改时，<code>version</code>值会加一。线程在提交更新时，只有读到的<code>version</code>值和先前的<code>version</code>值相等时才能提交更新后的数据</p>
<h2 id="CAS算法"><a href="#CAS算法" class="headerlink" title="CAS算法"></a>CAS算法</h2><p>CAS的全称是Compare And Swap(比较与交换)，用于实现乐观锁，其思想是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新</p>
<p>CAS是一个原子操作，底层依赖于一条CPU的原子指令</p>
<p>CAS涉及到三个操作数：</p>
<ul>
<li>V：要更新的变量值（Var）</li>
<li>E：预期值（Expected）</li>
<li>N：拟写入的新值（New）</li>
</ul>
<p>当且仅当V的值等于E时，CAS通过原子方式用新值N来更新V的值和E的值，如果不等，说明已经有其他线程更新了V，当前线程放弃更新并重新执行刚才的操作。</p>
<p><img src="https://img-blog.csdnimg.cn/784c23466aef4419a011d86f649f3f40.png" loading="lazy"></p>
<h3 id="CAS存在哪些问题？"><a href="#CAS存在哪些问题？" class="headerlink" title="CAS存在哪些问题？"></a>CAS存在哪些问题？</h3><ol>
<li>ABA问题：数据从A-&gt;B-&gt;A，CAS检查时会发现它的值没有发生改变，可以用版本号机制来解决，<strong>JDK 1.5</strong>以后的<code>AtomicStampedReference</code>类就是用来解决ABA问题的，其中的<code>compareAndSet()</code>方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，就以原子方式将该引用和该标志的值设置为给定的更新值</li>
<li>循环时间长开销大：CAS经常会用到自旋操作来进行重试，如果长时间不成功，会给CPU带来非常大的执行开销</li>
<li>只能保证一个共享变量的原子操作：CAS只对单个共享变量有效，当操作涉及跨多个共享变量时CAS无效。从<strong>JDK 1.5</strong>开始提供<code>AtomicReference</code>类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作</li>
</ol>
<h1 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h1><h2 id="synchronized是什么？有什么用？"><a href="#synchronized是什么？有什么用？" class="headerlink" title="synchronized是什么？有什么用？"></a>synchronized是什么？有什么用？</h2><p><code>synchronized</code>主要解决多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行</p>
<h2 id="如何使用synchronized？"><a href="#如何使用synchronized？" class="headerlink" title="如何使用synchronized？"></a>如何使用synchronized？</h2><ol>
<li><p>修饰实例方法（锁当前类的对象）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修饰静态方法（锁当前类所有对象）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修饰代码块（锁指定对象&#x2F;类）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(object)&#123;&#125;;</span><br><span class="line"><span class="keyword">synchronized</span>(类.class)&#123;&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>*尽量不要使用<code>synchronized(String a)</code>，因为JVM中字符串常量池具有缓存功能。</p>
<h2 id="构造方法可以用synchronized修饰吗？"><a href="#构造方法可以用synchronized修饰吗？" class="headerlink" title="构造方法可以用synchronized修饰吗？"></a>构造方法可以用synchronized修饰吗？</h2><p>不可以，因为构造方法本身就属于线程安全的，不存在同步的构造方法一说。</p>
<h1 id="synchronized和volatile有什么区别"><a href="#synchronized和volatile有什么区别" class="headerlink" title="synchronized和volatile有什么区别"></a>synchronized和volatile有什么区别</h1><ul>
<li><code>volatile</code>是线程同步的轻量级实现，所以性能优于<code>synchronized</code>，但<code>volatile</code>关键字是能用于变量而<code>synchronized</code>可以修饰方法以及代码块</li>
<li><code>volatile</code>能保证数据的可见性，但不能保证数据的原子性，<code>synchronized</code>两者都能保证</li>
<li><code>volatile</code>主要用于解决变量在多个线程之间的可见性，而<code>synchronized</code>解决的是多个线程之间访问资源的同步性</li>
</ul>
<h1 id="synchronized和ReentrantLock有什么区别"><a href="#synchronized和ReentrantLock有什么区别" class="headerlink" title="synchronized和ReentrantLock有什么区别"></a>synchronized和ReentrantLock有什么区别</h1><h2 id="两者都是可重入锁"><a href="#两者都是可重入锁" class="headerlink" title="两者都是可重入锁"></a>两者都是可重入锁</h2><p><strong>可重入锁</strong> 也叫递归锁，指的是线程可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其想要再次获取这个对象的锁的时候还是可以获取的，如果是不可重入锁，就会造成死锁</p>
<h2 id="sychronized依赖于JVM而ReentrantLocl依赖于API"><a href="#sychronized依赖于JVM而ReentrantLocl依赖于API" class="headerlink" title="sychronized依赖于JVM而ReentrantLocl依赖于API"></a>sychronized依赖于JVM而ReentrantLocl依赖于API</h2><ul>
<li><p><code>synchronized</code> 是依赖于 JVM 实现的，虚拟机团队在 JDK1.6 为 <code>synchronized</code> 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们</p>
</li>
<li><p><code>ReentrantLock</code> 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try&#x2F;finally 语句块来完成），所以可以通过查看它的源代码，来看它是如何实现的</p>
</li>
</ul>
<h1 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h1><h2 id="ReentrantLock是什么？"><a href="#ReentrantLock是什么？" class="headerlink" title="ReentrantLock是什么？"></a>ReentrantLock是什么？</h2><p><code>ReentrantLock</code>实现了<code>Lock</code>接口，是一个可重入且独占式的锁，和<code>synchronized</code>关键字类似，但它更灵活、更强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能</p>
<h2 id="公平锁和非公平锁有什么区别？"><a href="#公平锁和非公平锁有什么区别？" class="headerlink" title="公平锁和非公平锁有什么区别？"></a>公平锁和非公平锁有什么区别？</h2><ul>
<li>公平锁：锁被释放后，按照申请顺序将锁给下一个线程。性能较差一些，因为公平锁为保证时间上的绝对顺序，上下文切换更频繁</li>
<li>非公平锁：锁被释放后，随机或者按照其他优先级将锁给下一个进程。性能更好，但可能导致某些线程永远无法获取到锁</li>
</ul>
<h2 id="ReentrantLock-比-synchronized-增加了一些高级功能"><a href="#ReentrantLock-比-synchronized-增加了一些高级功能" class="headerlink" title="ReentrantLock 比 synchronized 增加了一些高级功能"></a>ReentrantLock 比 synchronized 增加了一些高级功能</h2><ul>
<li>等待可中断（等了一半放弃，去做其他事）</li>
<li>可实现公平锁</li>
<li>可实现选择性通知</li>
</ul>
<h2 id="可中断锁和不可中断锁的区别？"><a href="#可中断锁和不可中断锁的区别？" class="headerlink" title="可中断锁和不可中断锁的区别？"></a>可中断锁和不可中断锁的区别？</h2><ul>
<li>可中断锁：获取锁的过程可以被中断，不需要一直等到获取锁后才能进行其他逻辑处理，如<code>ReentrantLock</code></li>
<li>不可中断锁：一旦线程申请了锁，必须拿到锁后才能进行其他的逻辑处理，如<code>synchronized</code></li>
</ul>
]]></content>
      <categories>
        <category>八股</category>
      </categories>
      <tags>
        <tag>Java并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java的Array和List之间的转换</title>
    <url>/2023/03/10/array2List/</url>
    <content><![CDATA[<h1 id="List2Array"><a href="#List2Array" class="headerlink" title="List2Array"></a>List2Array</h1><h2 id="使用for循环"><a href="#使用for循环" class="headerlink" title="使用for循环"></a>使用for循环</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;bb&quot;</span>,<span class="string">&quot;cc&quot;</span>));</span><br><span class="line">String [] array = <span class="keyword">new</span> <span class="title class_">String</span>[list.size()];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    array[i] = list.get(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用toArray方法"><a href="#使用toArray方法" class="headerlink" title="使用toArray方法"></a>使用toArray方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;bb&quot;</span>,<span class="string">&quot;cc&quot;</span>));</span><br><span class="line"> String [] array = list.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>

<ul>
<li>传入的参数<code>new String[0]</code>仅用于传递array参数类型是什么，因此长度可以为0</li>
<li>如果不传入参数，则转化后的array类型为<code>Object[]</code></li>
</ul>
<h1 id="Array2List"><a href="#Array2List" class="headerlink" title="Array2List"></a>Array2List</h1><h2 id="使用for方法"><a href="#使用for方法" class="headerlink" title="使用for方法"></a>使用for方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String [] array = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;bb&quot;</span>,<span class="string">&quot;cc&quot;</span>&#125;;</span><br><span class="line"> List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">   list.add(array[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用asList方法"><a href="#使用asList方法" class="headerlink" title="使用asList方法"></a>使用asList方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> String [] array = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;bb&quot;</span>,<span class="string">&quot;cc&quot;</span>&#125;;</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(array));</span><br></pre></td></tr></table></figure>

<ul>
<li><p>需要注意<code>Arrays.asList</code>返回的<code>list</code>是大小固定的，是定义在<code>java.util.Arrays</code>中的一个私有静态类，不同于常用的<code>java.util.ArrayList</code>类</p>
</li>
<li><p>阅读其源码发现该私有静态类并并没有<code>add</code>和<code>remove</code>方法，因此不支持增删元素，只支持<code>get</code>和<code>set</code>改查元素</p>
</li>
</ul>
<h2 id="使用Collections-addAll方法"><a href="#使用Collections-addAll方法" class="headerlink" title="使用Collections.addAll方法"></a>使用Collections.addAll方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String [] array = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;bb&quot;</span>,<span class="string">&quot;cc&quot;</span>&#125;;</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(array.length);</span><br><span class="line">Collections.addAll(list,array);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title>关于node的一些报错</title>
    <url>/2022/12/28/nodeError/</url>
    <content><![CDATA[<h1 id="MySQL认证失败"><a href="#MySQL认证失败" class="headerlink" title="MySQL认证失败"></a>MySQL认证失败</h1><ul>
<li><p>报错内容</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;code&quot;</span>:<span class="string">&quot;ER_NOT_SUPPORTED_AUTH_MODE&quot;</span>,<span class="string">&quot;errno&quot;</span>:<span class="number">1251</span>,<span class="string">&quot;sqlMessage&quot;</span>:<span class="string">&quot;Client does not support authentication protocol requested by server; consider upgrading MySQL client&quot;</span>,<span class="string">&quot;sqlState&quot;</span>:<span class="string">&quot;08004&quot;</span>,<span class="string">&quot;fatal&quot;</span>:<span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>报错原因</p>
<ul>
<li>mysql8.0默认密码认证方案是‘caching_sha2_password’，而目前node默认的密码认证方案是’mysql_native_password’，所以无法认证成功</li>
</ul>
</li>
<li><p>解决方案</p>
<ol>
<li><p>终端启动mysql</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改密码认证方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; alter user &#x27;root&#x27;@&#x27;localhost&#x27; identified with mysql_native_password by &#x27;这里填root用户密码&#x27;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; flush privileges;</span><br></pre></td></tr></table></figure>
</li>
<li><p>退出mysql</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; exit;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h1 id="session报错undefined"><a href="#session报错undefined" class="headerlink" title="session报错undefined"></a>session报错undefined</h1><ul>
<li><p>报错原因：先发送了res再设置的req的session</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/captcha&#x27;</span>,<span class="keyword">function</span> (<span class="params">req,res</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> code = <span class="title function_">captcha</span>();</span><br><span class="line">    res.<span class="title function_">type</span>(<span class="string">&quot;svg&quot;</span>).<span class="title function_">send</span>(code.<span class="property">data</span>);</span><br><span class="line">    req.<span class="property">session</span>.<span class="property">captcha</span> = code.<span class="property">text</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>解决方案：交换顺序</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/captcha&#x27;</span>,<span class="keyword">function</span> (<span class="params">req,res</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> code = <span class="title function_">captcha</span>();</span><br><span class="line">    req.<span class="property">session</span>.<span class="property">captcha</span> = code.<span class="property">text</span>;</span><br><span class="line">    res.<span class="title function_">type</span>(<span class="string">&quot;svg&quot;</span>).<span class="title function_">send</span>(code.<span class="property">data</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="MySQL连接失败"><a href="#MySQL连接失败" class="headerlink" title="MySQL连接失败"></a>MySQL连接失败</h1><ul>
<li><p>报错内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Error: connect ECONNREFUSED ::<span class="number">1</span>:<span class="number">3306</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>报错原因</p>
<ul>
<li>localhost没有和127.0.0.1映射</li>
</ul>
</li>
<li><p>解决方案</p>
<ol>
<li><p>将localhost映射为127.0.0.1，具体方法略</p>
</li>
<li><p>将mysql配置中host更改为127.0.0.1</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> mysql <span class="keyword">from</span> <span class="string">&#x27;mysql&#x27;</span></span><br><span class="line"><span class="keyword">let</span> connection = mysql.<span class="title function_">createConnection</span>(&#123;</span><br><span class="line">    host     : <span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">    port     :  <span class="number">3306</span>,</span><br><span class="line">    user     : <span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">    password : <span class="string">&#x27;030605&#x27;</span>,</span><br><span class="line">    database : <span class="string">&#x27;schema_userInfo&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line">connection.<span class="title function_">connect</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connection</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h1 id="dirname报错undefined"><a href="#dirname报错undefined" class="headerlink" title="__dirname报错undefined"></a>__dirname报错undefined</h1><ul>
<li><p>报错内容</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">ReferenceError</span>: __filename is not defined <span class="keyword">in</span> <span class="variable constant_">ES</span> <span class="variable language_">module</span> scope</span><br></pre></td></tr></table></figure>
</li>
<li><p>报错原因</p>
<ul>
<li>在node中使用ES Modules规范时，以下全局对象和变量将不可用<ul>
<li>require</li>
<li>module.exports</li>
<li>exports</li>
<li>__filename</li>
<li>__dirname</li>
<li>NODE_PATH</li>
</ul>
</li>
<li>具体原因可以查看<a href="https://juejin.cn/post/7036744678749765640">这篇博客</a></li>
</ul>
</li>
<li><p>解决方案</p>
<ul>
<li><p>如果要在ES Modules规范中使用__dirname</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// import.meta.url 返回模块的绝对的 `file:` URL。</span></span><br><span class="line"><span class="comment">// url模块中fileURLToPath()函数，返回完全解析的特定于平台的 Node.js 文件路径</span></span><br><span class="line"><span class="comment">// path模块中dirname()函数，返回路径的目录路径</span></span><br><span class="line"><span class="keyword">import</span> &#123; fileURLToPath &#125; <span class="keyword">from</span> <span class="string">&#x27;url&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; dirname &#125; <span class="keyword">from</span> <span class="string">&#x27;path&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> __filename = <span class="title function_">fileURLToPath</span>(<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">url</span>);</span><br><span class="line"><span class="keyword">const</span> __dirname = <span class="title function_">dirname</span>(__filename);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="重复设置请求头"><a href="#重复设置请求头" class="headerlink" title="重复设置请求头"></a>重复设置请求头</h1><ul>
<li><p>报错内容</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Error</span> [<span class="variable constant_">ERR_HTTP_HEADERS_SENT</span>]: <span class="title class_">Cannot</span> set headers after they are sent to the client</span><br></pre></td></tr></table></figure>
</li>
<li><p>报错原因</p>
<ul>
<li>res.send()调用了多次</li>
</ul>
</li>
<li><p>解决方案</p>
<ul>
<li>res.send()后就return</li>
<li>检查是否是异步的问题导致res.send()调用多次</li>
</ul>
</li>
</ul>
<h1 id="Uncaught-SyntaxError-Cannot-use-import-statement-outside-a-module"><a href="#Uncaught-SyntaxError-Cannot-use-import-statement-outside-a-module" class="headerlink" title="Uncaught SyntaxError Cannot use import statement outside a module"></a>Uncaught SyntaxError Cannot use import statement outside a module</h1><ul>
<li><p>报错内容</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Uncaught</span> <span class="title class_">SyntaxError</span> <span class="title class_">Cannot</span> use <span class="keyword">import</span> statement outside a <span class="variable language_">module</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>报错原因</p>
<ul>
<li>使用了es6的语法， 浏览器默认将它作为js解析会出现问题</li>
</ul>
</li>
<li><p>解决方案</p>
<ul>
<li><p><code>script</code>标签默认为<code>type=&quot;text/javascript&quot;</code>，需要改为<code>type=&quot;module&quot;</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;public/js/index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>MySQL</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>ERP管理系统问题总结</title>
    <url>/2023/03/20/questionsAboutProject/</url>
    <content><![CDATA[<h1 id="JWT验证流程总结"><a href="#JWT验证流程总结" class="headerlink" title="JWT验证流程总结"></a>JWT验证流程总结</h1><ol>
<li>调用<code>UserService.login</code>登录功能，后端从数据库根据用户名和邮箱进行验证，验证成功调用<code>jwtConfig.createJWT</code>生成JWT，并把这个JWT返回给前端，以后前端每次请求都需要带上这个JWT</li>
<li>controller层对前端来的路由添加<code>@Authorized</code>注解进行鉴权</li>
<li><code>AuthAspect</code>类对<code>Authorized</code>注解进行增强，<code>@Order</code>注解用于有多个增强类对同一个方法进行增强的时候表明其优先级，越小优先级越高</li>
<li>添加<code>Before</code>方法，用于拦截controller包中所有public并且有<code>@Authorized</code>注解的方法</li>
<li>拦截http请求并获得<code>Authorized</code>标头，调用<code>jwtConfig.parseJwt</code>解析出<code>UserVO</code>信息，判断该<code>UserVO</code>的角色是否在<code>Authorized</code>注解的roles集合中，如果不在就抛出访问未授权的异常</li>
</ol>
<h1 id="项目的并发性怎么样？"><a href="#项目的并发性怎么样？" class="headerlink" title="项目的并发性怎么样？"></a>项目的并发性怎么样？</h1><p>通过在Service层使用Transaction注解和synchronized关键字保证了一定的并发性。一开始想的是直接将<code>@Transcational</code>注解和<code>synchronized</code>一起使用，但是后来验证发现还是线程不安全的，最后找到原因是<strong>加锁的范围没有包括到整个事务</strong>导致的，会出现<code>synchronized</code>代码块执行完但是事务还没有提交，新的线程又进入到<code>synchronized</code>代码块，读取到的数据是还没有提交的旧数据这样的情况。最后是通过对service层的方法添加一个代理方法，对这个代理方法加<code>synchronized</code>关键字，方法内部直接调用<code>service</code>的方法，这样就把锁加到了整个事务上。由此保证了单机下的多线程，但如果是分布式的话后面还的考虑加一些分布式锁</p>
<h1 id="用到了哪些设计模式？"><a href="#用到了哪些设计模式？" class="headerlink" title="用到了哪些设计模式？"></a>用到了哪些设计模式？</h1><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>总经理角色可以制定促销策略，针对不同级别的客户制定促销策略，包括赠品、价格折让或者赠送代金券，这部分我把这三种促销策略抽象成促销这个类，它具体的实现类有赠品、打折和代金券三种，不同级别的客户在一次购买金额达到触发条件后会自动进行判断，PromitionService层根据客户对应的级别和购买金额发放对应的促销策略，客户并不需要关心具体是哪种促销策略，只需要选择他能使用的促销策略就行</p>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>因为每个单据的创建都要设置大量的单据信息，如果把这些创建单据的代码放在业务代码主体中，会降低代码的可读性，所以我把单据的创建都交给工厂来做了，但是由于不同的单据它需要设置的信息基本不相同，所以我没有用抽象工厂，只是用了简单工厂模式，比如对于工资单这个单据，业务代码中只需要给工厂穿进一个staffDao，然后就不需要关心单据的具体创建过程，大大简化了SalarySheetService.makeSalarySheet方法，他只需要获取对应的员工信息，传给工厂，获得单据，存起来，如果有异常，就处理异常，并向前端返回，业务逻辑很清晰</p>
<h1 id="测试部分怎么写的？"><a href="#测试部分怎么写的？" class="headerlink" title="测试部分怎么写的？"></a>测试部分怎么写的？</h1><p>测试部分主要分为单元测试和集成测试</p>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>单元测试部分主要对工资单、员工打卡和用户模块进行测试，比如员工打卡模块，这个Service主要有ClockIn、GetAllInformation和GetMyInformation这三个方法，分别是当日打卡、人力部门查看打卡情况、员工查看今日打卡情况，所以主要测试这三个方法，比如打卡方法，测试打卡前后的员工打卡状态是否更改了，当月打卡次数是不是增加了，因为会用到员工的Dao层，所以先创建一个桩程序，来模拟Dao层返回的信息</p>
<h2 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h2><p>集成测试主要对财务人员部分的付款单和客户这两个模块的整体进行测试，财务人员制定付款单，包括单据编号，操作员，金额，银行账户以及所付款的客户ID，付款单审批成功后会把客户的应收金额减去单据的金额，表明公司向客户付过这些款了，主要测试单据金额大于公司应付的情况、银行账户错误等，这些情况都应该抛出异常。这部分需要实现的桩程序主要有银行账户Dao、客户Dao和付款单Dao</p>
<h1 id="有哪些可以优化的地方"><a href="#有哪些可以优化的地方" class="headerlink" title="有哪些可以优化的地方"></a>有哪些可以优化的地方</h1><h2 id="事务优化"><a href="#事务优化" class="headerlink" title="事务优化"></a>事务优化</h2><p>在创建出库单中，主要是基于Mysql的事务进行的，而基于MySQL事务的创建出库单操作的主要瓶颈是网络延迟和GC（Java垃圾回收机制）。执行一条update语句更新库存情况首先要拿到MySQL的行级锁rowLock，所以要尽量降低update对rowLock的持有时间。</p>
<p>一个简单的优化方式是在创建出库单时，从原来的先update库存再创建单据，优化成先创建单据再update库存，这样一来持有Mysql行级锁的时间会比原来少很多</p>
<h2 id="Redis缓存优化"><a href="#Redis缓存优化" class="headerlink" title="Redis缓存优化"></a>Redis缓存优化</h2><p> 由于员工打卡信息不需要经常变动，但前端接口需要保证员工打卡信息及时显示到前端页面上的，所以对数据库中这个字段的查询会比较频繁，可以采用Redis缓存的方式来减轻DB的压力，选取Bitmap数据接口存储员工打卡信息。内部的key是员工id+年月的形式，执行打卡时去相应的key中把天数对应的bit为置为1就行了</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://zhuanlan.zhihu.com/p/56961571">Synchronized锁在Spring事务管理下，为啥还线程不安全？</a></p>
<p><a href="http://tycoding.cn/2018/10/15/ssm/seckill">SpringBoot实现Java高并发秒杀系统之并发优化（四）</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>需求与商业模式创新复习</title>
    <url>/2023/02/15/demandAndBusinessModelInnovation/</url>
    <content><![CDATA[<h1 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h1><h2 id="什么是软件"><a href="#什么是软件" class="headerlink" title="什么是软件"></a>什么是软件</h2><ul>
<li>从组成成分的角度看软件（“写的对”）<ul>
<li>代码+文档</li>
</ul>
</li>
<li>从问题求解的角度看软件（“写对的”）<ul>
<li>作为一种复杂的信息制品，软件是对客观事物的深度抽象与建模，且同时包含了对复杂客观世界的<strong>问题空间</strong>与<strong>解空间</strong>的具体描述</li>
</ul>
</li>
</ul>
<h2 id="问题域与解系统"><a href="#问题域与解系统" class="headerlink" title="问题域与解系统"></a>问题域与解系统</h2><ul>
<li><p>从<strong>问题域背景</strong>出发，结合<strong>涉众主观意愿</strong>，设定系统<strong>目标</strong>，制定开发<strong>任务</strong>，细分系统<strong>交互</strong></p>
</li>
<li><p>软件系统解决问题的基础：模拟与共享</p>
<ul>
<li>软件系统中的某些部分对问题域中的某些部分具有模拟特性</li>
<li>这些通过映射建立的共同知识，就是问题域和解系统之间的共享现象</li>
<li>最后将解系统的模型操纵与计算结果用于指导现实世界的问题解决</li>
</ul>
</li>
</ul>
<h2 id="需求的两个维度"><a href="#需求的两个维度" class="headerlink" title="需求的两个维度"></a>需求的两个维度</h2><ul>
<li>需求（问题域端）<ul>
<li>直接需求、间接需求</li>
<li>不切实际的期望</li>
<li>![image-20230131155234455](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230131155234455.png)</li>
</ul>
</li>
<li>需求规格说明（解系统端）<ul>
<li>数据：现实世界的模型</li>
<li>功能：对模型的操作，将结果反馈回现实世界，辅助解决问题   </li>
<li>![image-20230131155304159](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230131155304159.png)</li>
</ul>
</li>
</ul>
<h2 id="需求的四个基本概念"><a href="#需求的四个基本概念" class="headerlink" title="需求的四个基本概念"></a>需求的四个基本概念</h2><ul>
<li>问题域、需求、解系统、需求规格说明</li>
</ul>
<p>![image-20230131152939051](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230131152939051.png)</p>
<h2 id="需求的定义"><a href="#需求的定义" class="headerlink" title="需求的定义"></a>需求的定义</h2><ul>
<li>IEEE<ol>
<li>用户为了解决问题或达到某些目标所需要的条件或能力</li>
<li>系统或系统部件为了满足合同、标准、规范或其他正式文档所规定的要求而需要具备的条件或能力</li>
<li>对1或2中的一个条件或能力的一种文档化表述</li>
</ol>
</li>
</ul>
<h2 id="计算器的问题域和解系统各是什么"><a href="#计算器的问题域和解系统各是什么" class="headerlink" title="计算器的问题域和解系统各是什么"></a>计算器的问题域和解系统各是什么</h2><ul>
<li>问题域一般不包括计算机世界的概念，要从明确的应用领域和人性（情感诉求、日常生活等）出发</li>
<li>解系统一般也不是模糊的“宏观”系统目标，而是明确的问题域背景+问题+目标+任务+交互（+设计、实现、测试、部署等其他制品）</li>
<li>纯计算器（没有模拟与共享）可认为是解系统的一个组件、不同类型的计算器（编程语言）有其假设的场景，才有问题域</li>
</ul>
<h1 id="商业模式画布"><a href="#商业模式画布" class="headerlink" title="商业模式画布"></a>商业模式画布</h1><h2 id="商业模式模型"><a href="#商业模式模型" class="headerlink" title="商业模式模型"></a>商业模式模型</h2><ul>
<li>为何需要从商业模式开始：人人互联成本趋零导致的潜在用户群体变化以及已有业务的重组</li>
<li>目标1：人人都能理解，容易达成共识</li>
<li>目标2：易于建模和操作</li>
<li>目标3：依然具有分析复杂情况的能力</li>
</ul>
<p>![image-20230131161642857](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230131161642857.png)</p>
<h2 id="情感端"><a href="#情感端" class="headerlink" title="情感端"></a>情感端</h2><h3 id="客户细分Customer-Segments"><a href="#客户细分Customer-Segments" class="headerlink" title="客户细分Customer Segments"></a>客户细分Customer Segments</h3><ul>
<li><p>一家企业想要获得的和期望服务的不同目标人群和机构</p>
<ul>
<li>细分条件<ul>
<li>需求催生新供给</li>
<li>需要新分销渠道和客户关系类型</li>
<li>产生的利润率不同</li>
<li>愿意为某方面的特殊改进买单</li>
</ul>
</li>
<li>需要谨慎处理客户的细分与取舍</li>
</ul>
</li>
<li><p>划分方式举例</p>
<ul>
<li>大众市场<ul>
<li>消费电子、大型零售商</li>
</ul>
</li>
<li>小众市场<ul>
<li>产业链上的供应商-采购商</li>
</ul>
</li>
<li>求同存异的客户群体<ul>
<li>各类产品线、诺基亚</li>
</ul>
</li>
<li>多元化客户群体<ul>
<li>3M公司，做胶水、口罩</li>
<li>三星</li>
<li>亚马逊&#x2F;阿里</li>
</ul>
</li>
<li>多边平台&#x2F;市场<ul>
<li>大型互联网平台，例如B站、淘宝</li>
</ul>
</li>
</ul>
</li>
<li><p>CS的进一步讨论——尽可能拓宽客户群体</p>
<ul>
<li>华为的成长与客户细分类型（围绕主营业务不断拓宽）<ul>
<li>程控交换机</li>
<li>通讯服务设备、各类业务软件、通信终端、光伏逆变、芯片设计、智能车组件</li>
<li>手机：运营商定制机、P、Mate、荣耀（V、S、Magic）、Nova、X</li>
<li>espace（办公软件）、鸿蒙、华为云</li>
<li>2022：“三年不做车”——重要的车机提供方与联名商</li>
</ul>
</li>
<li>英雄联盟手游的客户细分（客户的细分与取舍）<ul>
<li>王者荣耀难当出海大任</li>
<li>细分：lol宇宙观与竞技赛事背景下的“轻度”玩家</li>
<li>取：海外玩家、女性玩家、云玩家</li>
<li>舍：端游重度玩家、但通过赛事、世界观等内容进行融合（大乱斗、云顶之弈、Valorant、lol世界）、向文化社区转向</li>
<li>2022：英雄联盟电竞经理-选手卡周边（愈发靠拢传统体育）</li>
</ul>
</li>
<li><strong>客户群体拓宽背后的共性——共享内核的价值主张网络</strong></li>
</ul>
</li>
</ul>
<h3 id="价值主张Value-Proposition"><a href="#价值主张Value-Proposition" class="headerlink" title="价值主张Value Proposition"></a>价值主张Value Proposition</h3><ul>
<li><p>为某一客户群体提供能为其创造价值的产品和服务</p>
<ul>
<li>解决客户的问题或满足其需求，<strong>使其选择一家而放弃另一家</strong></li>
<li>一家公司为特定客户群体提供的利益集合或组合</li>
<li>创新性的、革命性的产品或服务 VS 既有产品或服务+新特点或属性</li>
</ul>
</li>
<li><p>有益于价值创造的因素罗列（部分）</p>
<ul>
<li>创新newness：满足客户未曾察觉全新需求，可以是非技术的创新</li>
<li>性能performance：PC机与显卡（摩尔定律，xp与vista，win7与win8）、智能手机</li>
<li>定制customization：大规模定制（众筹，联名款）与客户参与创造（MIUI，UGC，用户社区）</li>
<li>一站式服务getting the job done：飞机引擎维护、咨询公司、BOT工程（总包-交钥匙）</li>
<li>设计design：时尚（施华洛世奇）、消费电子产品（苹果、索尼手机、锤子手机）</li>
<li>品牌&#x2F;地位brand&#x2F;status：奢侈品（机械手表、名牌包）、潮牌（球鞋、Hip- Hop）、游戏等级</li>
<li>价格price：廉价航空、小米、免费经济</li>
<li>缩减成本cost reduction：服务外包（编程、房产销售）</li>
<li>风险控制risk reduction：保险、额外保障服务</li>
<li>可获得性accessibility：共享经济、共同基金（股票与货币基金）</li>
<li>便利性&#x2F;实用性convenience&#x2F;usability：苹果音乐商店、云计算（网盘、服务器、游戏）</li>
</ul>
</li>
<li><p>分类</p>
<ul>
<li>让事情更简单（痛点）：价格、缩减成本、便利性&#x2F;实用性</li>
<li>让事情更复杂（收益）：定制、设计、品牌&#x2F;地位、可获得性</li>
<li>让事情透明（痛点）：风险控制、一站式服务</li>
</ul>
</li>
<li><p>VP的进一步讨论</p>
<ul>
<li>一个产品的VP通常是相互重叠且交错的（价值网络）<ul>
<li>孤独的美食家五郎，他作为一个“个体户”，提供哪些VP？</li>
<li>定制、设计与品牌地位，一站式服务与风险控制，缩减成本、可获得性与便利性等</li>
</ul>
</li>
<li>初创团队如何设计自己的VP<ul>
<li>为了生存，初创团队需以“轻成本”的方式运营，可以多考虑引入“简单”与“透明”式的产品，维持“轻成本”运营<ul>
<li>信息类产品：微信公众号、（短）视频平台</li>
<li>实物类产品：各类生产线的复用（定制JK裙、元气森林）</li>
</ul>
</li>
<li>一般而言，VP以“收益”型为主<ul>
<li>“低价”的VP需要：某领域内的高效率、高覆盖、强竞争</li>
<li>初创团队需要较高定价以形成发展所需的利润空间<ul>
<li>产品成长、渠道开拓、小品牌导致的高价格要素等均使得初创团队的花费更高</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="渠道通路CHannels"><a href="#渠道通路CHannels" class="headerlink" title="渠道通路CHannels"></a>渠道通路CHannels</h3><ul>
<li>一家企业如何同它的客户群体达成沟通并建立联系，以向对方传递自身的价值主张<ul>
<li>企业与客户交互体系：交流、分销、销售渠道（+售后），是用户的交互触点</li>
<li>作用：了解产品与服务、评估价值主张；购买产品与服务、传递价值主张；提供售后支持</li>
</ul>
</li>
<li>渠道的五个阶段与运营方式<ul>
<li><strong>知名度-评价-购买-传递-售后</strong>（三包、评论）<ul>
<li>思考：在教超买个面包当夜宵</li>
</ul>
</li>
<li>一个渠道可包含一个或全部五个阶段</li>
<li>一个组织可选用自有渠道、合作方渠道或混用，以追求获益与成本的平衡以及最佳的客户体验<ul>
<li>自身强渠道：蓝绿大厂线下店面、品牌贴牌与认证授权（日本马桶圈与电饭锅、日化、米家），<strong>能主动引发流量的互联网平台</strong></li>
<li>合作方渠道：各大电商平台（农村电商汇通达），贝业新兄弟，品牌水暖空调门店，小红书（种草拔草社区），视频推广（恰饭视频，B站）</li>
<li>混用：移动运营商直营与加盟店，天猫上的苏宁易购官方店（仓储、物流、售后），网易严选</li>
</ul>
</li>
</ul>
</li>
<li>CH的进一步讨论<ul>
<li><p>渠道通路的重要性</p>
<ul>
<li>商业的本质，人人互联成本为零的最大发力点</li>
<li>与产品设计的关系微妙：渠道对同类产品竞争起核心作用；过度重视容易引发反噬（品质与信任的失配）</li>
<li>产品设计运维一体化：CH承载VP与CS的组合关系，用不断推出的新产品进行营销-强化&#x2F;更新VP，加强&#x2F;拓展CS对系列产品服务的认知。 </li>
<li><strong>（完全）基于渠道的品牌：南极人、三只松鼠——品牌认知与电商渠道</strong></li>
<li>（免费）公开渠道：微信公众号、朋友圈、小程序</li>
</ul>
</li>
<li><p>直播带货：最新涌现的渠道通路</p>
<ul>
<li>手机淘宝-淘宝直播：阿里系电商在移动互联时代渡劫的关键</li>
<li>特点：<strong>模拟线下体验</strong>；信任敏感高；“低价”-“出新”<ul>
<li>线下零售新热点：低价折扣店-类似直播带货（信任：主播-已知品牌）</li>
</ul>
</li>
<li>2021淘宝“双十一”直播：李佳琦106.5亿（佣金20.0亿，触发所得税税率上限45%），薇娅82.5亿（第三名9.3亿，第四名1.6亿）</li>
</ul>
</li>
<li><p>2015年4月，雷军表示：“小米是电商” </p>
<ul>
<li>小米10之前，小米的VP和CS组合、以及红米的出现导致小米本身不赚钱（但有流量-200w圆角与“xiaomi”），小米手机可视作米家生态的“渠道”<ul>
<li>小米4于2014.7月底首发，2021年上半年宣布造车</li>
</ul>
</li>
<li>小米手机+米家生态 &#x3D; 新时代中国“宜家”？<ul>
<li>小米手机定位在调整：“米冲高、关键年“ V.S. “谁还敢买小米旗舰”</li>
<li>MIUI失控的原因：松散组织、加速迭代、需求（可追踪性）失控</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="客户关系-Customer-Relationship"><a href="#客户关系-Customer-Relationship" class="headerlink" title="客户关系 Customer Relationship"></a>客户关系 Customer Relationship</h3><ul>
<li>一家企业针对某一个客户群体所建立的客户关系的类型<ul>
<li>靠人员维护（专属一对一财富管家）VS 自动化设备（24小时自助）</li>
<li>动机：开发新客户、留住原客户、增加销售量或客单价（携程杀熟、杀苹果用户）</li>
</ul>
</li>
<li>客户关系类型<ul>
<li>私人服务personal assistance：商场导购、柜台服务与电渠、销售员</li>
<li>专属私人服务dedicated personal assistance：私人银行服务、华为电信设备、健身&#x2F;培训“私教”</li>
<li>自助服务self-service：话费流量充值、银行普通业务（ATM与大厅内自助服务）</li>
<li>自动化服务automated services：各类平台推荐系统、网站导航设计（活动、凑单、无货推荐、红色与橙色的加入购物车、立即购买）</li>
<li>社区communities：花粉俱乐部、小米之家、小红书、各类网友社区</li>
<li>客户共同创造co-creation：MIUI、UGC（土豆、B站、抖音）、各种评论（电影书籍-豆瓣、旅游住宿-airbnb、普通商品-自发安利与评论区），采纳用户反馈的社区（产品调查问卷、游戏平衡运营）</li>
</ul>
</li>
<li>分类<ul>
<li>成本导向：自助服务、自动化服务</li>
<li>价值导向：私人服务、专属私人服务、客户共同创造</li>
<li>兼顾：社区（社交裂变、私域流量）</li>
</ul>
</li>
</ul>
<h3 id="收入来源-Revenue-Streams"><a href="#收入来源-Revenue-Streams" class="headerlink" title="收入来源 Revenue Streams"></a>收入来源 Revenue Streams</h3><ul>
<li>企业从每一个客户群体获得的现金收益（扣除成本的利益）<ul>
<li>探索用户真正愿意付费的点</li>
<li>两类收益来源：一次性交易收入、持续收入（进一步提供产品服务或售后支持）</li>
<li>定价机制<ul>
<li>固定（基于静态变量）：目录价、基于产品特性（“青春版”，“畅享版”）、基于客户群（教育版）、基于数量</li>
<li>浮动（基于动态变量）：谈判&#x2F;议价、收益管理（库存与发生购买的时间，如生鲜、熟食、酒店、航班等）、实时市场价格、拍卖</li>
</ul>
</li>
</ul>
</li>
<li>收入来源的方式<ul>
<li>资产销售asset sale：实物产品所有权转让、消费者拥有处置的全部权利</li>
<li>使用费usage fee：电信、宾馆、快递、付费网游点卡、公共交通车票</li>
<li>会员费subsrciption fee：健身卡、付费网游月卡、公共交通月票、音乐会员</li>
<li>租赁lending&#x2F;renting&#x2F;leasing：共享单车&#x2F;汽车&#x2F;充电宝，特定资产在特定时间的使用权转移并获益</li>
<li>许可使用费licensing：专利授权、版权（图片、音乐、字体），加盟或特许经营</li>
<li>经纪人佣金brokerage fees：信用卡（交易手续费）、支付平台（交易与提现手续费）、中介</li>
<li>广告费advertising：传媒、品牌策划、软件业与服务业；广告费增长乏力、分蛋糕的太多<ul>
<li>“购买”未来的消费预期-从“形象宣传”到“实际体验”再到“品牌认同”</li>
</ul>
</li>
</ul>
</li>
<li>RS的进一步讨论<ul>
<li>三级价格歧视（差异定价）<ul>
<li>按人（杀价、拍卖、杀熟）</li>
<li>按量（批发、团购、套餐、优惠券、峰谷阶梯定价）</li>
<li>按类（可选择的差异化服务：氪金、VIP、加急、视频会员、精装与典藏、机票折扣、社交裂变和私域流量）</li>
<li>2021年8月27日，网信办《互联网信息服务算法推荐管理规定（征求意见稿）》<ul>
<li>不得根据消费者的偏好，交易习惯等特征，利用算法在交易价格等交易条件上实行不合理的差别待遇等违法行为</li>
<li>2020.10.1出台《在线旅游经营服务管理暂行规定》；2021.11.1实行《个人信息保护法》</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>“双十一盖楼、砍一刀&amp;百亿补贴、私域流量”<ul>
<li>买家盖楼：用个人的精力与社会关系证明你对折扣的“渴望”</li>
<li>卖家入场：通过适度折扣充分发掘消费欲望与潜力，将投入精力与消费行为绑定<ul>
<li>私域流量：适度折扣锁定域内用户后续消费需要-瑞幸、麦当劳、便利蜂</li>
</ul>
</li>
<li>当前最强营销手段：PDD百亿补贴（“人货场”理论）<ul>
<li>人：价格敏感的高渴望群体（学生-B站）；货：有趣好玩但不急需的大牌（品牌消费电子、产品）；场：PDD自身聚集的流量与对应的定价权（成-苹果，败-特斯拉）</li>
</ul>
</li>
<li>永远的真理：“不买立省百分百！”-货、场最终都是为人服务<ul>
<li>标准：（商品）可持续提供（关键）价值&amp;可负担</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="理性端"><a href="#理性端" class="headerlink" title="理性端"></a>理性端</h2><h3 id="核心资源-Key-Resources"><a href="#核心资源-Key-Resources" class="headerlink" title="核心资源 Key Resources"></a>核心资源 Key Resources</h3><ul>
<li>保证一个商业模式顺利运行所需的最重要的资产<ul>
<li>用于：价值主张的创造与提供、开拓市场、维护客户关系并获益</li>
<li>可以“自主拥有”或者“寻求合作”<ul>
<li>“核心”意味着稀缺与不可替代，需要花费巨大的成本维系</li>
<li>“拥有”意味着额外的管理、折旧和风险，“合作”意味着让出的利润空间与颠覆式的生存危机-从“核心”向外扩展：拥有-合作</li>
</ul>
</li>
</ul>
</li>
<li>类型<ul>
<li>实物资源physical：生产设备、房屋、车辆、机器、系统、销售点管理系统、分销渠道（腾讯：流量的“低吸高抛”）</li>
<li>知识性资源intellectual：品牌（可口可乐）、专利（高通与华为）、知识产权与体系（微软、SAP、安卓&#x2F;苹果）</li>
<li>人力资源human：普遍存在，对于创新性和知识密集产业最重要（如IT业），出色的营销团队<ul>
<li>劳动力高价的来源-对个人创造力的依赖&#x2F;“赛道稳定程度”：芯片制造与芯片设计，IT开发&#x2F;算法&#x2F;金融，公司与科研</li>
</ul>
</li>
<li>金融资源financial：<ul>
<li>内部：花呗、车贷、互联网金融 - “润滑”消费与经营，电商标配</li>
<li>外部：风险投资、资本市场（国资）- 助力创新企业快速成长</li>
</ul>
</li>
</ul>
</li>
<li>KR的进一步讨论<ul>
<li>大厂的“屯人”竞争<ul>
<li>2022年以前：挖友商墙角 + 高薪囤积实习生、应届生</li>
<li>表面：大厂“公务员化”；实际：圈养+考核+输送人才<ul>
<li>如何应对：持续知识体系构建下的“肉食者鄙” - 初步能够观察互联网市场的持续变化 + “适当追求赛道风险” - 选择对个人创造力依赖强的业务领域 + “无限进步” - 面向个人长期持续进步（能够应对未知）的学习与工作</li>
</ul>
</li>
</ul>
</li>
<li>风投的利弊<ul>
<li>商业模式初步可行前提下的扶植验证与大规模复制<ul>
<li>互联网+时代创新的关键要素（钱+人+资源+渠道）</li>
<li>流派：赛道 vs. 赛车 vs. 赛手</li>
</ul>
</li>
<li>追求结果性的结果：要么赢，要么毁灭<ul>
<li>天性重“复制”、重“退出”（接盘或上市）导致的“信托化”、“泡沫化”</li>
<li>容易诱发：拔苗助长 + 无序竞争 + 垄断兼并 + 压制创新</li>
<li>“元宇宙”和Web3.0的某种必然性：多项风投技术投资在逻辑上的延伸</li>
</ul>
</li>
<li>这一轮“互联网寒冬”的重要诱因 - 美元回流与美股的脱钩风险<ul>
<li>调整后的各家互联网大厂经营情况并不弱 - 疫情红利与暂停烧钱</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="关键业务-Key-Activities"><a href="#关键业务-Key-Activities" class="headerlink" title="关键业务 Key Activities"></a>关键业务 Key Activities</h3><ul>
<li>保障其商业模式正常运行所需做的最重要的事情<ul>
<li>价值主张、获得市场、客户关系与收益</li>
<li>与价值主张强相关，价值主张的具象化</li>
<li>构建护城河：商业模式创新 - 构建不可替代的关键业务 - 支撑服务升级 - 基础设施投资 - 底层技术突破 - 拥有&#x2F;强化核心资源<ul>
<li>（免交易费换流量）双十一 - 弹性计算 + 阿里云 +OceanBase + 平头哥</li>
<li>盒马“鲜.美.生.活“ - 关键业务 - 核心资源？</li>
</ul>
</li>
</ul>
</li>
<li>类型<ul>
<li>生产production：包含分销网络、渠道等</li>
<li>解决方案problem solving：知识管理与持续的培训</li>
<li>平台&#x2F;网络platform&#x2F;network：XX网、Visa卡、操作系统、应用商店、游戏平台</li>
</ul>
</li>
</ul>
<h3 id="重要合作-Key-Partnership"><a href="#重要合作-Key-Partnership" class="headerlink" title="重要合作 Key Partnership"></a>重要合作 Key Partnership</h3><ul>
<li><p>一个商业模式顺利运行所需的供应商和合作伙伴网络</p>
<ul>
<li>非竞争者之间的战略联盟*<del>康采恩（不同业务之间的利益共同体）</del>*<ul>
<li>微信生态 vs. 苹果生态、Fortnite vs. App Store + Google Play</li>
</ul>
</li>
<li>竞争者之间的战略合作*<del>卡特尔（同产业控制产品产量和价格）</del>*<ul>
<li>红蓝快乐水、微信支付与支付宝、米国两党制</li>
</ul>
</li>
<li>新业务的合资公司*<del>托拉斯（多个巨头通过合资公司组成的利益共同体）</del>*<ul>
<li>大厂“生态”：3q大战之后的腾讯联盟 vs. 阿里直系</li>
</ul>
</li>
<li>稳定供应关系的供应商和采购商*<del>辛迪加（同产业垄断上有供应和下游销售）</del>*<ul>
<li>产业园、苹果认证供应商、闭环的互联网影视平台（传统影视产业：制作、发行、院线）</li>
</ul>
</li>
</ul>
</li>
<li><p>合作动机</p>
<ul>
<li><p>优化与规模效应 - 提供业务效率：降低成本，外包或共享基础设施</p>
</li>
<li><p>特殊资源及活动的获得 - 获得核心资源：高技术产品、销售团队、特许商品、渠道</p>
</li>
<li><p>降低风险和不确定性 - 降低业务风险：某领域内的战略联盟（蓝光，5G）、*<del>台湾省与韩国的面板联盟</del><em>京东方的崛起</em><del>（09-10家电下乡，韩国污点证人）</del>*</p>
</li>
<li><p>“千播”大战的结局：熊猫等倒下、斗鱼虎牙合并失败、企鹅电竞解散</p>
<ul>
<li>传统“文广新”内容的公有制属性不能变</li>
<li>以游戏为核心的直播平台幕后BOSS？ - 热门游戏版本所有者</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="成本结构-Cost-Structrue"><a href="#成本结构-Cost-Structrue" class="headerlink" title="成本结构 Cost Structrue"></a>成本结构 Cost Structrue</h3><ul>
<li>运营一个商业模式所发生的全部成本<ul>
<li>确定核心资源、关键业务和重要合作之后，成本核算将相对容易</li>
<li>也有以低成本结构为核心的商业模式（廉航、红米、Zara）</li>
</ul>
</li>
<li>导向<ul>
<li>成本导向cost-driven：成本最小化，创造并维持极尽精简的成本结构</li>
<li>价值导向value-driven：高端的价值主张与高度的个性化服务</li>
</ul>
</li>
<li>特点<ul>
<li>固定成本：管理员工工资、租金、生产设备</li>
<li>可变成本：加工工人工资，加班费，广告推广费，水电，原材料消耗</li>
<li>规模经济：大宗采购，大规模生产摊薄的固定成本</li>
<li>范围经济：渠道的复用（摊薄部分可变成本）</li>
<li>小米台灯为什么那么便宜？<ul>
<li>范围经济+规模经济的双向红利 - 如何做到：米家生态</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="重视模块之间的联系（以及联系的联系）"><a href="#重视模块之间的联系（以及联系的联系）" class="headerlink" title="重视模块之间的联系（以及联系的联系）"></a>重视模块之间的联系（以及联系的联系）</h2><ul>
<li>纵向联系（从上到下）<ul>
<li>客户关系-&gt;渠道通路-&gt;收入来源</li>
<li>关键业务-&gt;关键资源-&gt;成本支出</li>
</ul>
</li>
<li>跨越的联系<ul>
<li>客户关系选择与成本支出导向（定制化、个人化 - 价值导向 vs 自动化、大众化 - 成本导向）</li>
<li>除了价值主张与关键业务，关注建设渠道通路所需的核心资源与重要合作</li>
<li>细分的客户群体是否认同上游的重要合作方与引入的外部关键资源？</li>
</ul>
</li>
<li>联系的联系<ul>
<li>平台：多个“价值主张-客户细分”对的组合才能构成完整的收入来源<ul>
<li>吸引用户的主张与用户愿意付费的主张</li>
<li>促进多种不同用户群体的交易：补贴谁？收费谁？</li>
<li>如何运维平台并促进不同用户群体加入</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="完整商业模式举例：从iPod-x2F-iTunes商业模式到“网易云”"><a href="#完整商业模式举例：从iPod-x2F-iTunes商业模式到“网易云”" class="headerlink" title="完整商业模式举例：从iPod&#x2F;iTunes商业模式到“网易云”"></a>完整商业模式举例：从iPod&#x2F;iTunes商业模式到“网易云”</h2><p>![image-20230210202117005](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230210202117005.png)</p>
<ul>
<li><p>让画布动起来</p>
<ul>
<li><p>掌握商业模式画布之后的课程设置</p>
<ul>
<li><p>利用画布分析若干常见的商业模式类型 — 拆分&amp;开放</p>
</li>
<li><p>对新构建或已有的商业模式进行评估，并制定相应的战略</p>
</li>
<li><p>分析互联网时代的代表性商业模式类型 - 多边平台，免费，<strong>长尾</strong></p>
</li>
<li><p>利用画布构建或改进新的商业模式</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="商业模式类型"><a href="#商业模式类型" class="headerlink" title="商业模式类型"></a>商业模式类型</h1><ul>
<li><p>（讨论）建筑风格的意义在于捕获建筑设计的理念，将其作为典型的、可重复使用的描述</p>
</li>
<li><p>本课程关注的五类商业模式</p>
<ul>
<li>分拆商业模式（Unbundled）</li>
<li>长尾商业模式（Long-tail）</li>
<li>开放的商业模式（Open）</li>
<li>多边商业模式（Multisided）</li>
<li>免费商业模式（Free）</li>
</ul>
</li>
</ul>
<h2 id="分拆商业模式：商业版的“关注分离”"><a href="#分拆商业模式：商业版的“关注分离”" class="headerlink" title="分拆商业模式：商业版的“关注分离”"></a>分拆商业模式：商业版的“关注分离”</h2><ul>
<li><p>企业内部的三类规则：经济、竞争与文化</p>
<ul>
<li>由此可以区分三种活动：客户关系管理、新产品开发、基础设施管理</li>
<li>活动对应三种价值信条：亲近顾客、产品领先、运营卓越</li>
</ul>
</li>
<li><p>三类活动驱动因素不同，彼此之间冲突，企业内部消长（难共赢）</p>
<ul>
<li>解决方案：分拆！各自独立</li>
<li>![image-20230210203240215](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230210203240215.png)</li>
</ul>
</li>
<li><p>书上的例子![image-20230210203532124](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230210203532124.png)</p>
</li>
<li><p>补充例子：可口可乐</p>
<ul>
<li>新产品 - 适应无糖趋势<ul>
<li>茶、运动饮料、纯悦纯净水、罐装Costa咖啡（英国上市，减糖）、纤维 + 可乐（原产日本）、咖啡可乐（原产巴西）、爽椰派雪碧、无糖芬达</li>
</ul>
</li>
<li>客户关系 - 品牌矩阵与营销<ul>
<li>大量收购各国知名饮料品牌（尼日利亚Chi，收购汇源失败，约500+产品）</li>
<li>从diet coke到zero：配方基本不变，摆脱女性专属形象</li>
<li>外包装营销：与你的“女神&#x2F;闺蜜”共享 - 电视剧名台词 - 小瓶、时尚罐与小罐</li>
</ul>
</li>
<li>基础运营 - 调节风险与收益<ul>
<li>外包灌装 - 收购灌装厂 - 再次外包灌装（国内为太古和中粮）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="长尾商业模式"><a href="#长尾商业模式" class="headerlink" title="长尾商业模式"></a>长尾商业模式</h2><ul>
<li>进一步的、极致的客户细分<ul>
<li>支撑原理：长尾商业模式</li>
</ul>
</li>
<li>专注于多种类产品销售<ul>
<li>提供相当多种类的小众产品，每类卖出量相对很少，但汇总的销售收入可以与传统模式销售媲美<ul>
<li>在高效的互联网渠道加持下，专注于某领域的部分单品销售也能构成长尾</li>
</ul>
</li>
</ul>
</li>
<li>例子：图书出版、乐高数字在线</li>
</ul>
<h2 id="多边平台商业模式"><a href="#多边平台商业模式" class="headerlink" title="多边平台商业模式"></a>多边平台商业模式</h2><ul>
<li>价值主张一般体现在如下三方面<ul>
<li>吸引用户、群体配对、利用平台交易渠道降低交易成本</li>
</ul>
</li>
<li>客户群体相互依存，无法独立</li>
<li>核心资源是平台、成本主要来自于平台的维护和开发<ul>
<li>三项关键活动：平台管理、服务实现、平台升级</li>
<li>轻资产 vs. 重资产</li>
</ul>
</li>
<li>多个收益流，补贴正确的客户群是定价决策的关键<ul>
<li>如何设计收益流补贴？如何定价</li>
</ul>
</li>
</ul>
<p>![image-20230214115903077](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230214115903077.png)</p>
<h2 id="免费的商业模式"><a href="#免费的商业模式" class="headerlink" title="免费的商业模式"></a>免费的商业模式</h2><ul>
<li>三种可行的免费商业模式<ul>
<li>共同点：至少一个群体将得到免费的商品</li>
<li>广告模式：基于多边平台的免费商品</li>
<li>免费增值：免费的基本服务，可选的增值服务</li>
<li>诱饵&amp;陷阱：以免费或很便宜的初始价格吸引客户，并引导其重复购买</li>
</ul>
</li>
</ul>
<h3 id="基于广告的免费商业模式总结"><a href="#基于广告的免费商业模式总结" class="headerlink" title="基于广告的免费商业模式总结"></a>基于广告的免费商业模式总结</h3><ul>
<li>好的产品和服务以及高流量会吸引广告商，进而补贴产品和服务<ul>
<li>要考虑广告费能90p否支撑起产品服务质量</li>
<li>吞噬广告费的产品太多，流量红利已见底</li>
</ul>
</li>
<li>成本：平台的开发和维护，以及可能的获客与维系成本</li>
</ul>
<p>![image-20230214115843181](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230214115843181.png)</p>
<h3 id="免费增值的免费商业模式"><a href="#免费增值的免费商业模式" class="headerlink" title="免费增值的免费商业模式"></a>免费增值的免费商业模式</h3><ul>
<li>平台是最重要的资产，产生三部分成本<ul>
<li>客观的固定成本、免费账户的低边际成本服务、增值账户成本</li>
</ul>
</li>
<li>客户关系自动且低成本，免费用户向增值用户转化率是重要指标</li>
<li>平台发展新趋势<ul>
<li>需要高水平、差异化的产品与服务（为免费增值提供空间）</li>
<li>反面例子：庆余年与腾讯VIP<ul>
<li>已被放弃，是平台低效的体现</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>![image-20230214115831391](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230214115831391.png)</p>
<h3 id="诱饵-amp-陷阱模式总结"><a href="#诱饵-amp-陷阱模式总结" class="headerlink" title="诱饵&amp;陷阱模式总结"></a>诱饵&amp;陷阱模式总结</h3><ul>
<li>产品与后续产品之间要有紧密连接，从而使得极小收益的初始购买为后续高收益产品或服务的重复购买创造可能</li>
<li>关注后续产品交付，需要强大品牌支撑</li>
<li>重要成本结构<ul>
<li>初始产品补贴与后续产品的成本</li>
</ul>
</li>
<li>慢慢融入平台与免费增值<ul>
<li>新套餐体验 + 自动续费</li>
<li>各类社交裂变式促销（“盖楼”）</li>
<li>游戏本体 + DLC或平衡性无关道具</li>
<li>“又肝又氪”的游戏营销活动</li>
</ul>
</li>
</ul>
<p>![image-20230214115821387](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230214115821387.png)</p>
<h2 id="开放的商业模式"><a href="#开放的商业模式" class="headerlink" title="开放的商业模式"></a>开放的商业模式</h2><ul>
<li>补充：格力电器<ul>
<li>由外到内<ul>
<li>2014年以前，引入并组装丹麦的丹佛斯磁悬浮压缩机</li>
</ul>
</li>
<li>由内到外<ul>
<li>2019年11月向丹麦知名水泵生产商格兰富提供新型无稀土磁阻电机领域3哥系列的专利技术</li>
</ul>
</li>
<li>连接器<ul>
<li>1997年开始设立格力科技进步奖</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="互联网场景"><a href="#互联网场景" class="headerlink" title="互联网场景"></a>互联网场景</h2><ul>
<li><p>补充讨论：信息技术如何改变世界 - 构造场景</p>
<ul>
<li>人类社会的整体视角 - 人人互联的“小小世界”<ul>
<li>“六度分离”现象的背后 - 任何一种人人互动都会形成网络&#x2F;群体，群体的局部行为会导致全局性的结果</li>
<li>移动互联网 - 低成本互联下的“更小世界”</li>
<li>单个网民视角 - 通过<strong>场景</strong>连接到不同群体</li>
</ul>
</li>
<li>场景的定义</li>
<li>场景的连接<ul>
<li>基于场景的（构建产品）思维方式</li>
</ul>
</li>
</ul>
</li>
<li><p>补充讨论：被互联网定义的“新”场景</p>
<ul>
<li>以人为中心的体验细节 - （不同时段的）在线视听、公开社交（真人秀）、线下打造线上种草的网红地、知识获取&amp;分享&amp;玩梗（一显示自己的小团体&#x2F;独特爱好标签）、不同到货时间的购物体验</li>
<li>广泛的连接方式 - 扫一扫（二维码、实物）与商品、私域流量（社区、群聊、朋友圈）与各类活动、O2O、微信与其他APP</li>
<li>价值交换与新生活方式 - 红包&amp;打赏、各种智能设备</li>
<li>场景构成 - 时间、地点、人物、事件、链接方式</li>
<li>事实上，场景本身没有新旧之分，其差异在于能否（通过移动互联网）使场景参与者沟通诠释出新的价值与情感<ul>
<li>结合客户洞察描绘出独特、具体的场景</li>
<li>在这些场景中用户决定选择特定产品而放弃其他产品</li>
</ul>
</li>
</ul>
</li>
<li><p>补充讨论：互联网+软件天然的垄断趋势与后发软件的应对</p>
<ul>
<li>后发软件（产品）的机会何在？<ul>
<li>更加细分、贴合的用户体验 - 形成独特的亚文化、亚群体</li>
<li>结合核心资源、关键业务的深入打造</li>
<li>向新技术、新领域、新应用的创新尝试（“新”是指与典型互联网企业、行业相比，往往是有利可图的“老”行业）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="商业模式设计"><a href="#商业模式设计" class="headerlink" title="商业模式设计"></a>商业模式设计</h1><h2 id="客户洞察"><a href="#客户洞察" class="headerlink" title="客户洞察"></a>客户洞察</h2><ul>
<li><strong>看</strong>：描述该客户在她所处的环境中所看到的东西</li>
<li><strong>听</strong>：描述环境如何影响到这个客户</li>
<li><strong>想&amp;感受</strong>：尝试勾勒你的客户思维的过程</li>
<li><strong>说&amp;做</strong>：想象客户可能的言辞，或公共场合的行为</li>
<li><strong>痛点</strong>：已遭受的挫折、正遇到的阻碍、怕承担的风险</li>
<li><strong>收益</strong>：预期成就、成功衡量标准、实现目标所采用的策略</li>
</ul>
<p>![image-20230214133628911](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230214133628911.png)</p>
<ul>
<li>洞察力是设计思维的关键来源之一<ul>
<li>重视人的行为，而不是judge</li>
</ul>
</li>
<li>客户洞察的核心：换位思考</li>
</ul>
<h2 id="构思"><a href="#构思" class="headerlink" title="构思"></a>构思</h2><ul>
<li><p>一个能够产生大量商业模式创意，并成功识别出其中最佳创意的流程被称为<strong>构思</strong></p>
</li>
<li><p>构思的两个步骤：生成大量创意 -&gt; 对创意进行整合并挑选</p>
</li>
<li><p>提出新创意的两个出发点</p>
<ul>
<li>从画布中寻找创新的焦点</li>
<li>不断提出“如果……会怎样”的问题</li>
</ul>
</li>
<li><p>商业模式创新的焦点</p>
<ul>
<li>资源驱动<ul>
<li>资源驱动的创新来源于组织现有的基础设施或合作伙伴资源。企业由此出发延伸或改变商业模式</li>
</ul>
</li>
<li>供给驱动<ul>
<li>供给驱动的创新会创造全新的价值主张，并影响商业模式的其他模块</li>
</ul>
</li>
<li>客户驱动<ul>
<li>客户驱动的创新是基于客户需求、可获得性或者便利性的提升。和其他类型的创新一样，这种创新也会影响到商业模式的各个模块</li>
</ul>
</li>
<li>财务驱动</li>
<li>多点驱动</li>
</ul>
</li>
<li><p>构思的流程与团队建设</p>
<ol>
<li>团队组建</li>
<li>钻研</li>
<li>开拓</li>
<li>甄选标准</li>
<li>构建模型</li>
</ol>
</li>
<li><p>头脑风暴的原则</p>
<ul>
<li>保持聚焦</li>
<li>执行规则</li>
<li>视觉化思考</li>
<li>准备</li>
</ul>
</li>
</ul>
<h2 id="视觉化思考"><a href="#视觉化思考" class="headerlink" title="视觉化思考"></a>视觉化思考</h2><h2 id="模型构建"><a href="#模型构建" class="headerlink" title="模型构建"></a>模型构建</h2><h2 id="讲故事"><a href="#讲故事" class="headerlink" title="讲故事"></a>讲故事</h2><ul>
<li>两种视角<ul>
<li>公司视角<ol>
<li>观察到的新商业模式所解决的客户问题</li>
<li>新商业模式如何比旧模式更好的利用资源、业务和伙伴关系（降本增效、开源节流）</li>
<li>员工承载了组织内部工作与商业模式，以及转向新模式的原因</li>
</ol>
</li>
<li>客户视角<ol>
<li>客户面临的挑战与必须完成的工作，以及组织如何为其创造价值</li>
<li>描述她得到的东西、这些东西如何融入她的生活、以及她愿意为哪些东西付费</li>
<li>可以添加一些戏剧性和情感因素，描述你的组织如何让她的生活更简单</li>
<li>故事需要真实可信，避免油腔滑调或居高临下的口吻</li>
</ol>
</li>
</ul>
</li>
<li><strong>讲故事的目的是为了引人入胜、栩栩如生地介绍一个新商业模式</strong></li>
<li>讲故事的方法<ul>
<li>图片和旁白</li>
<li>视频</li>
<li>角色扮演</li>
<li>文字和图片</li>
<li>连环图画</li>
</ul>
</li>
</ul>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><ul>
<li>两种场景<ul>
<li>不同的客户结构<ul>
<li>由场景决定选择哪款产品而放弃其他产品</li>
</ul>
</li>
<li>未来可能的竞争环境</li>
</ul>
</li>
<li>场景六个阶段<ul>
<li>了解与评估</li>
<li>购买与传递</li>
<li>交互</li>
<li>售后</li>
<li>评价与复购</li>
</ul>
</li>
</ul>
<h1 id="商业模式战略"><a href="#商业模式战略" class="headerlink" title="商业模式战略"></a>商业模式战略</h1><h2 id="商业模式环境"><a href="#商业模式环境" class="headerlink" title="商业模式环境"></a>商业模式环境</h2><p>![image-20230214164902810](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230214164902810.png)</p>
<h3 id="市场影响力"><a href="#市场影响力" class="headerlink" title="市场影响力"></a>市场影响力</h3><ol>
<li>市场问题：从客户和供给的角度识别出驱动和改变你的市场的关键问题</li>
<li>市场分类：识别主要的市场群体，描述他们的兴趣点，尝试发现新的群体</li>
<li>需求和诉求：列举市场需求并分析这些需求被满足的程度</li>
<li>切换成本：客户转投竞争对手，哪些方面需要改变</li>
<li>收入影响力：识别与收入吸引力和定价能力相关的因素</li>
</ol>
<h3 id="行业影响力"><a href="#行业影响力" class="headerlink" title="行业影响力"></a>行业影响力</h3><ol>
<li>（现有的）竞争对手：识别现有竞争对手和他们的相对优势</li>
<li>新进入者（挑战者）：新出现的玩家以及他们商业模式的不同</li>
<li>替代产品和服务：（包括其他市场和行业在内的）替代产品和服务</li>
<li>供应商与价值链上的其他厂商：当前价值链上的关键玩家与新兴玩家</li>
<li>利益相关者：那些人会影响你的组织和商业模式</li>
</ol>
<h3 id="关键趋势"><a href="#关键趋势" class="headerlink" title="关键趋势"></a>关键趋势</h3><ol>
<li>技术趋势：威胁和推动发展当前商业模式的技术趋势</li>
<li>行业管理趋势：影响（你的）商业模式的管理规定和管理趋势</li>
<li>社会和文化趋势：可能影响（你的）商业模式的社会趋势</li>
<li>社会经济趋势：总结和你的商业模式有关的主要社会经济趋势<ul>
<li>短视频人均用户时长120分钟<ul>
<li>手机使用方式：碎片 &gt; 沉浸</li>
<li><strong>用户追求个人效率的提升 - 日常生活的进一步“外包”</strong></li>
</ul>
</li>
<li>整体经济周期处于萧条期，疫情放开后应该好转</li>
</ul>
</li>
</ol>
<h3 id="宏观经济影响"><a href="#宏观经济影响" class="headerlink" title="宏观经济影响"></a>宏观经济影响</h3><ol>
<li>全球市场情况：从宏观经济角度总结当前整体情况<ul>
<li>全球经济增速放缓</li>
</ul>
</li>
<li>资本市场：与你的资本需求相关的当前资本市场情况</li>
<li>大宗商品和其他资源：关注你的商业模式所需的资源价格与趋势<ul>
<li>人力成本不断上升</li>
</ul>
</li>
<li>经济基础设施：你的业务市场的经济基础设施<ul>
<li>5g + 特高压 + 轨道交通 + 充电桩 + AI + 大数据中心 + 工业互联网 + 元宇宙</li>
</ul>
</li>
</ol>
<h2 id="评估商业模式"><a href="#评估商业模式" class="headerlink" title="评估商业模式"></a>评估商业模式</h2><ul>
<li>商业模式环境 - 由外到内的影响</li>
<li>评估商业模式 - 由内到外</li>
</ul>
<h3 id="总体评估"><a href="#总体评估" class="headerlink" title="总体评估"></a>总体评估</h3><p>![image-20230214172225202](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230214172225202.png)</p>
<p><img src="https://gitee.com/duan-jifeng/code-imgs/raw/master/202211092202311.png" alt="img" loading="lazy"></p>
<h3 id="SWOT"><a href="#SWOT" class="headerlink" title="SWOT"></a>SWOT</h3><p>![image-20230214172656061](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230214172656061.png)</p>
<ul>
<li>优势&amp;劣势<ul>
<li>![image-20230214172904638](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230214172904638.png)</li>
<li>![image-20230214172932968](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230214172932968.png)</li>
<li>![image-20230214172941658](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230214172941658.png)</li>
<li>![image-20230214172950955](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230214172950955.png)</li>
</ul>
</li>
<li>威胁<ul>
<li><img src="/Users/effy/Downloads/IMG_3015.JPG" alt="IMG_3015" style="zoom: 25%;"  loading="lazy"/></li>
<li><img src="/Users/effy/Downloads/IMG_3016.JPG" alt="IMG_3015" loading="lazy"></li>
</ul>
</li>
<li>机会<ul>
<li><img src="/Users/effy/Downloads/IMG_3017.JPG" alt="IMG_3017" style="zoom:25%;"  loading="lazy"/></li>
<li><img src="/Users/effy/Downloads/IMG_3018.JPG" alt="IMG_3018" style="zoom:25%;"  loading="lazy"/></li>
</ul>
</li>
</ul>
<h2 id="蓝海战略"><a href="#蓝海战略" class="headerlink" title="蓝海战略"></a>蓝海战略</h2><ul>
<li><p>商业模式视角下的蓝海战略</p>
<ul>
<li>蓝海战略：通过根本性的差异化来创造全新的行业，而不是模仿现有商业模式在当前行业中竞争<ul>
<li>价值创新：不是在传统的绩效指标下超越对手，而是创造新的、未充分竞争的市场空间</li>
<li>画布的可视化效果为蓝海战略带来“全局化”的视角</li>
<li>通常还与开拓未被开发的客户群体相结合</li>
</ul>
</li>
<li>蓝海战略的“四项行动架构”（增加价值，减少成本）<ul>
<li>行业中哪些理所当然的要素应被删除</li>
<li>哪些要素应被大幅消减至行业标准以下</li>
<li>哪些要素应改被大幅调整到行业标准之上</li>
<li>哪些行业中从未提供的要素是应改被创造出来的</li>
</ul>
</li>
</ul>
</li>
<li><p>![image-20230211211323781](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230211211323781.png)</p>
</li>
<li><p>太阳马戏团</p>
<ul>
<li>![image-20230211205110080](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230211205110080.png)</li>
</ul>
</li>
<li><p>![image-20230211205542226](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230211205542226.png)</p>
</li>
<li><p>辩证地对待蓝海战略：必要性与风险</p>
<ul>
<li>蓝海战略的必要性：逃离“王慧文四杀”</li>
<li>（错误的）蓝海战略的风险：空心化、外部潮流与形势变更<ul>
<li>人类兴趣三年一小变五年一大变（过于探索客户-偏离）</li>
<li>（供应链）经济全球化带来的蝴蝶效应（过于探索成本-外包异常）</li>
<li>在一个有限的时间段内，产品与服务过于聚焦某个明星品类（过于探索客户与价值主张）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="商业模式管理"><a href="#商业模式管理" class="headerlink" title="商业模式管理"></a>商业模式管理</h2><ul>
<li>组织的艰巨任务：如何在实施和管理新商业模式的同时维持现有的商业模式<ul>
<li>将新商业模式剥离成一个独立的实体，或者成立独立的业务单元，或维持现状</li>
<li>拆分商业模式：基础服务、客户关系、新业务</li>
</ul>
</li>
<li>衡量是否拆分的双变量<ul>
<li>两种模式冲突的严重程度</li>
<li>战略上的相似性</li>
</ul>
</li>
<li>例子1：Swatch手表<ul>
<li>垂直整合：生产、研发、供货和HR集中管理，每一个品牌单独管理自己的产品、设计与营销</li>
</ul>
</li>
<li>例子2：雀巢公司的咖啡商业模式组合<ul>
<li>分拆：（由基础设施决定）Nescafe、Dolce Gusto、Nespresso三种产品在价值主张、客户关系、渠道通路、市场细分上完全不同</li>
</ul>
</li>
<li>例子3：戴姆勒的分阶段商业模式创新<ul>
<li>汽车公司开展共享汽车业务</li>
<li>阶段1：戴姆勒创新部门设计商业模式</li>
<li>阶段2：戴姆勒创新部门实地验证概念</li>
<li>阶段3：根据新商业模式与传统核心业务之间的关系决定采取何种组织结构（整合或剥离）</li>
</ul>
</li>
</ul>
<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><h2 id="需求工程的基本活动"><a href="#需求工程的基本活动" class="headerlink" title="需求工程的基本活动"></a>需求工程的基本活动</h2><ol>
<li>需求获取：系统原始需要<ul>
<li>研究应用环境，分析系统涉众，了解已有问题，建立系统目标，获取业务细节，生成用户需求</li>
</ul>
</li>
<li>需求分析：保证需求完整性与一致性（贯穿整个过程）<ul>
<li>将目标、功能与约束映射为系统行为，建立系统模型并分析（信息的细化与隐藏联系、假设的显示化），识别并修复不一致缺陷，发现并弥补遗漏的需求</li>
</ul>
</li>
<li>需求规约：将分析过的需求与系统行为明确并文档化<ul>
<li>自然语言+模型预言（UML）</li>
</ul>
</li>
<li>需求验证：保证需求分析的正确性、一致性、完整性<ul>
<li>最终产物为所有涉众一致同意的需求规约，是后续开发的基础</li>
</ul>
</li>
<li>需求管理：持续（时间、开发活动）管理需求基线<ul>
<li>跟踪后续阶段中的需求实现与变更，确保正确的理解与实现</li>
</ul>
</li>
</ol>
<ul>
<li>需求工程过程的并发和迭代性</li>
<li>实践方法的应用<ul>
<li>个人才智-&gt;实践方法-&gt;知识体系</li>
<li>需求工程师需要为组织或项目选择、定制和应用一些有效的实践方法</li>
</ul>
</li>
</ul>
<h2 id="确定项目前景和范围"><a href="#确定项目前景和范围" class="headerlink" title="确定项目前景和范围"></a>确定项目前景和范围</h2><ul>
<li>确定项目的前景与范围，就是确定项目的问题、目标、特性<ul>
<li>（业务需求）问题：组织的战略目标、利益分配、政策规划、业务流程等高层问题</li>
<li>目标：问题的反面，用户的期望</li>
<li>系统特性</li>
</ul>
</li>
</ul>
<h3 id="目标模型"><a href="#目标模型" class="headerlink" title="目标模型"></a>目标模型</h3><ul>
<li><p>目标的层次</p>
<ul>
<li>高层次：战略性的、全局的、业务相关，抽象的</li>
<li>低层次：技术性的、局部的、产品设计相关，具体的</li>
</ul>
</li>
<li><p>目标的分类</p>
<ul>
<li><p>软目标（云朵）和硬目标（矩形）</p>
<ul>
<li><p>能否利用技术手段确认是否满足</p>
</li>
<li><img src="/Users/effy/Library/Application Support/typora-user-images/image-20230214230840134.png" alt="image-20230214230840134" style="zoom: 50%;"  loading="lazy"/>
</li>
<li><img src="/Users/effy/Library/Application Support/typora-user-images/image-20230214230902387.png" alt="image-20230214230902387" style="zoom: 50%;"  loading="lazy"/></li>
</ul>
</li>
<li><p>目标规格的基本模式</p>
<ul>
<li>实现（Achieve）</li>
<li>终止（Cease）</li>
<li>保持（Maintain）</li>
<li>避免（Avoid）</li>
<li>优化（Optimize）：最大化（Maximize）和最小化（Minimize）</li>
</ul>
</li>
</ul>
</li>
<li><p>目标的关系</p>
<ol>
<li>目标精化<ol>
<li>AND精化关系：一系列子目标{G1,G2,…,Gn}的完成有助于目标G的完成。此时任意两子目标Gi和Gj之间是互补的</li>
<li>完备（Complete）AND精化关系：一系列子目标{G1,G2,…,Gn}的完成能够直接保证G的完成</li>
<li>OR精化关系：任一子目标Gi都是目标G替代方案。此时，任意两子目标Gi与Gj之间是互相替代的</li>
</ol>
</li>
<li>目标阻碍<ul>
<li>子目标O的达成会使得高层目标G失败</li>
<li><img src="/Users/effy/Library/Application Support/typora-user-images/image-20230214231901239.png" alt="image-20230214231901239" style="zoom: 33%;"  loading="lazy"/></li>
</ul>
</li>
<li>目标之间的支持（support）与冲突（conflict）<ol>
<li>Support链接表示一个目标对其他目标的支持作用<ol>
<li>支持关系可以被处理为OR精化关系</li>
</ol>
</li>
<li>Conflict链接表示一个目标的实现对其他目标的实现有阻碍作用</li>
</ol>
</li>
</ol>
</li>
<li><p>目标与主体关系</p>
<ul>
<li>Assignment链接表示为实现目标而需要参与主体<ul>
<li>OR Assignment：多个主体中的一个来完成</li>
<li>AND Assignment：多个主体一起共同完成</li>
<li>![image-20230214232747515](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230214232747515.png)</li>
</ul>
</li>
</ul>
</li>
<li><p>目标与操作关系</p>
<ul>
<li>AND Operationalization<ul>
<li>![image-20230214232947645](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230214232947645.png)</li>
</ul>
</li>
<li>OR Operationalization</li>
</ul>
</li>
<li><p>面向目标方法的处理过程</p>
<ul>
<li>高层目标的获取</li>
<li>低层目标的获取</li>
<li>目标分析：精化与分解<ul>
<li>![image-20230214233701914](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230214233701914.png)</li>
</ul>
</li>
<li>目标实现<ol>
<li>将最底层目标分配给主体（人+系统）<ul>
<li>![image-20230214233622194](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230214233622194.png)</li>
</ul>
</li>
<li>设计实现最底层目标的操作<ul>
<li>![image-20230214233920740](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230214233920740.png)</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="涉众分析"><a href="#涉众分析" class="headerlink" title="涉众分析"></a>涉众分析</h2><ul>
<li><p>涉众识别——主体（圆）依赖模型ADM（Actor Dependency Model）</p>
<ul>
<li>目标依赖（椭圆）：依赖者希望被依赖者满足一个条件，但不会规定怎么样满足该条件</li>
<li>软目标依赖（葫芦）：一类特殊类型的目标依赖，其条件是无法量化描述的</li>
<li>任务依赖（六边形）</li>
<li>资源依赖（正方形）</li>
<li>![image-20230215092536135](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230215092536135.png)</li>
</ul>
</li>
<li><p>涉众评估——Power-Interest模型</p>
<ul>
<li><p>基于特征化解举例：亲子兴趣班</p>
<ul>
<li><p>大人与小朋友一起参与：环境设定者（客户）-&gt; 参与者（用户）</p>
</li>
<li><p>良好的产品体验打造亲子品牌：被影响者（潜在用户&#x2F;客户） -&gt; 参与者</p>
</li>
</ul>
</li>
<li><p>![image-20230215093100042](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230215093100042.png)</p>
</li>
</ul>
</li>
<li><p>涉众共赢——Stakeholder&#x2F;Issue关系图</p>
<ul>
<li>列出系统的所有涉众类别，明确描述他们的兴趣和对系统的期望；</li>
<li>从涉众们的兴趣和期望中发现背后涉及的共同问题（Issue）；</li>
<li>建立涉众类别和问题的关联，如果某个涉众类别对一个Issue存在兴趣，那么该涉众类别和这个Issue就存在关联关系；</li>
<li>对每一个Stakeholder-Issue关系，标明该关系上面所被寄予的期望； </li>
<li>![image-20230215093855841](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230215093855841.png)</li>
</ul>
</li>
</ul>
<h2 id="需求获取方法"><a href="#需求获取方法" class="headerlink" title="需求获取方法"></a>需求获取方法</h2><h3 id="面谈"><a href="#面谈" class="headerlink" title="面谈"></a>面谈</h3><ul>
<li>问题类型<ul>
<li>开放式问题</li>
<li>封闭式问题</li>
</ul>
</li>
<li>问题设计<ul>
<li>前期<ul>
<li>以开放式问题为主</li>
<li>决策层与专家为主</li>
<li>遵循 问题-&gt;目标-&gt;解决方案路线</li>
<li>分析基本的涉众特点</li>
</ul>
</li>
<li>后期<ul>
<li>封闭式问题为主</li>
<li>抓住主体与线索<ul>
<li>如：任务分解、流程图、界面示意</li>
</ul>
</li>
<li>问题针对性</li>
<li>事先准备面谈记录材料</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>![image-20230215094755495](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230215094755495.png)</p>
<h3 id="观察"><a href="#观察" class="headerlink" title="观察"></a>观察</h3><ul>
<li>面谈：用户其实什么都知道，我们需要和他进行有效的沟通；原型：用户和我们都有一些不确定的地方，需要一些原型类的东西帮助我们理解，去消除不确定性；观察：有一些情况、场景、功能是通过面谈和原型方法所不能挖掘的，用户无法主动完成信息的告知</li>
</ul>
<h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><h3 id="概念类图"><a href="#概念类图" class="headerlink" title="概念类图"></a>概念类图</h3><p>![image-20230215100454732](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230215100454732.png)</p>
<h3 id="顺序图"><a href="#顺序图" class="headerlink" title="顺序图"></a>顺序图</h3><p>![image-20230215100527717](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230215100527717.png)</p>
<p>![image-20230215100652004](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230215100652004.png)</p>
<p>![image-20230215100706045](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230215100706045.png)</p>
<h3 id="状态图"><a href="#状态图" class="headerlink" title="状态图"></a>状态图</h3><p>![image-20230215100851111](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230215100851111.png)</p>
<p>![image-20230215101049893](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230215101049893.png)</p>
<h2 id="需求验证与管理"><a href="#需求验证与管理" class="headerlink" title="需求验证与管理"></a>需求验证与管理</h2><h3 id="需求验证"><a href="#需求验证" class="headerlink" title="需求验证"></a>需求验证</h3><ul>
<li><p>需求验证方法</p>
<ul>
<li><p>评审</p>
<ul>
<li>由作者之外的其他人来检查产品问题的方法</li>
<li>是主要的静态分析手段</li>
<li>原则上，每一条需求都应该进行评审</li>
</ul>
</li>
<li><p>原型与模拟</p>
<ul>
<li>涉及到复杂的动态行为时</li>
<li>成本较高</li>
</ul>
</li>
<li><p>开发测试用例</p>
<ul>
<li>![image-20230215101726913](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230215101726913.png)</li>
<li>![image-20230215101714730](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230215101714730.png)</li>
</ul>
</li>
<li><p>用户手册编制</p>
</li>
<li><p>利用跟踪关系</p>
</li>
<li><p>自动化分析</p>
</li>
</ul>
</li>
</ul>
<h3 id="需求管理"><a href="#需求管理" class="headerlink" title="需求管理"></a>需求管理</h3><ul>
<li>任务<ul>
<li>交流涉众需要什么；</li>
<li>将需求应用、实施到解决方案；</li>
<li>驱动设计和实现工作；</li>
<li>控制变更；</li>
<li>将需求分配到子系统；</li>
<li>测试和验证最终产品；</li>
<li>控制迭代式开发中的变化；</li>
<li>辅助项目管理</li>
</ul>
</li>
<li>活动<ul>
<li>![image-20230215101920674](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230215101920674.png)</li>
</ul>
</li>
</ul>
<h3 id="需求变更控制"><a href="#需求变更控制" class="headerlink" title="需求变更控制"></a>需求变更控制</h3><ul>
<li>过程<ul>
<li>![image-20230215102036878](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230215102036878.png)</li>
</ul>
</li>
<li>组织——变更控制委员会（CCB）<ul>
<li><strong>项目或程序管理部门；</strong></li>
<li><strong>产品管理或者需求分析部门；</strong></li>
<li>开发部门；</li>
<li><strong>测试或者质量保障部门；</strong></li>
<li>市场或客户代表；</li>
<li>编写用户文档的部门；</li>
<li>技术支持或帮助部门；</li>
<li><strong>配置管理部门。</strong></li>
</ul>
</li>
<li>注意事项<ol>
<li>认识到变更的必要性，并为之制定计划</li>
<li>维护需求基线，审计变更记录</li>
<li>管理范围蔓延</li>
<li>灵活应对变更请求</li>
<li>使用辅助工具</li>
</ol>
</li>
</ul>
<h1 id="考试重点"><a href="#考试重点" class="headerlink" title="考试重点"></a>考试重点</h1><h2 id="商业模式部分期末考核（50分）"><a href="#商业模式部分期末考核（50分）" class="headerlink" title="商业模式部分期末考核（50分）"></a>商业模式部分期末考核（50分）</h2><ul>
<li><p>商业模式画布绘制+需求类型（20分）</p>
</li>
<li><p>商业模式类型讨论（10分）</p>
<ul>
<li>五种类型都有可能，优先考察与互联网最相关的三个</li>
</ul>
</li>
<li><p>商业模式设计（10分）</p>
<ul>
<li>六种设计手段选一个考核</li>
</ul>
</li>
<li><p>商业模式评估（10分）</p>
<ul>
<li>四种评估手段选一个考核（复杂的手段会被适当地提示和约减）</li>
</ul>
</li>
</ul>
<h2 id="需求部分期末考核（50分）"><a href="#需求部分期末考核（50分）" class="headerlink" title="需求部分期末考核（50分）"></a>需求部分期末考核（50分）</h2><ul>
<li><p>需求获取（30分）</p>
<ul>
<li>需求获取上半段（20分）<ul>
<li>确定项目前景与范围（10分） - 目标模型</li>
<li>涉众分析（10分） - 涉众识别之ADM模型、涉众评估之Power-Interest模型、涉众共赢之Stakeholder-Issue模型</li>
</ul>
</li>
<li>需求获取下半段（10分）<ul>
<li>面谈、原型、观察三大获取手段的联系与区别，面谈问题的设计<ul>
<li>面谈：用户其实什么都知道，我们需要和他进行有效的沟通；原型：用户和我们都有一些不确定的地方，需要一些原型类的东西帮助我们理解，去消除不确定性；观察：有一些情况、场景、功能是通过面谈和原型方法所不能挖掘的，用户无法主动完成信息的告知</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>需求分析（10分）</p>
<ul>
<li>需求分析基本任务（没有能考的）</li>
<li>基于UML软件建模的需求细化 - 概念类图、顺序图、状态图</li>
</ul>
</li>
<li><p>需求验证与管理（10分）</p>
<ul>
<li>需求验证基本活动<ul>
<li>验证的六个手段（除自动化分析）</li>
</ul>
</li>
<li>需求管理任务与活动，需求变更控制过程、组织与注意事项</li>
</ul>
</li>
<li><p>TIPS</p>
<ul>
<li><p>考长尾模式</p>
</li>
<li><p>概念类图和领域模型一样</p>
</li>
</ul>
</li>
</ul>
<h1 id="往年试卷"><a href="#往年试卷" class="headerlink" title="往年试卷"></a>往年试卷</h1><h2 id="2021"><a href="#2021" class="headerlink" title="2021"></a>2021</h2><p>背景材料是蔚来电动车。</p>
<ol>
<li>分析的蔚来电动车商业模式，并画出商业模式画布，写出约束三大来源+本系统的一条约束需求（内容标号，不要直接写在画布里，20分）</li>
<li>对比传统车和用户，分析蔚来电动车体现何种商业模式，该商业模式有什么特点（10分）</li>
<li>App内商城的题面，对客户的讲故事和场景有什么区别？给出一个场景，并阐述为什么适用（10分）</li>
<li>对蔚来电动车的商业模式进行环境评估（不需要打分，概要评估即可，10分）</li>
<li>结合蔚来电动车的车友社区，进行目标分析（尽可能多地使用目标分析的元素，10分）</li>
<li>使用stakeHolder&#x2F;issue模型进行共赢分析（10分）</li>
<li>面谈问题的两大类型，和一个传统燃油车用户面谈，探讨服务和？让这些客户选择电动车，构思一个问题列表（10分）</li>
<li>简述需求管理的三种方法和管理变更的五大原则（10分）</li>
<li>蔚来电动车有一系列的升级（类似）规则，根据规则画出状态图（10分）</li>
</ol>
<h2 id="2020"><a href="#2020" class="headerlink" title="2020"></a>2020</h2><p>规模越来越⼤、投资⼈很多很富、有⾏业⼤佬、⾯向上班族和⼩区居⺠、店⾯⼀线城市在商圈⼆线城市，在社区、提供热⻝、提供个性化产品、与知名 IP 和品牌联动、有数据系统⾃助结账和经营策略制定等</p>
<ol>
<li><p>（ 20 分）根据材料画商业模式画布及各部分元素。写出⼀个“约束”需求</p>
</li>
<li><p>（ 10 分）属于哪个商业模式？这个模式有什么要点？再结合材料谈谈</p>
</li>
<li><p>（ 10 分）从公司和客户的⻆度分别讲⼀个故事</p>
</li>
<li><p>（ 10 分）SWOT 评估包括哪些要点？结合材料和画布⾥的每个元素，简要分析，不需打分</p>
</li>
<li><p>（ 10 分）想要在 2021 年⼤规模扩张，画出⽬标模型</p>
</li>
<li><p>（ 10 分）有店员因为数学不好⽽离职，⽼店⻓认为计算机不能代替⼈类决策；通过实验证明数据模型更有效；⽼店⻓培养新店⻓；减少店员数量，增加店员收⼊。结合材料，⽤ stakeholderissue模型进⾏涉众共赢分析</p>
</li>
<li><p>（ 10 分）想搞社区团购，有个⼈懂，并且还会直播带货。需求获取有哪三个⽅法？结合材料谈如何需求获取</p>
</li>
<li><p>（ 10 分）让你做⼩程序和 APP ，需求管理包括哪些要点？结合着谈谈</p>
</li>
<li><p>（ 10 分）买优惠券包、查看优惠券、优惠券包退款、优惠券包过期换积分。画出⽤例的系统顺序图</p>
</li>
</ol>
<h2 id="2019"><a href="#2019" class="headerlink" title="2019"></a>2019</h2><p>背景材料是新浪微博。</p>
<ol>
<li>分析微博的商业模式，并画出商业模式画布（内容标号，不要直接写在画布里，20分）</li>
<li>分析微博如何体现多边平台商业模式的特点，并指出微博存在的问题（10分）</li>
<li>对微博的普通用户进行客户洞察，主要特点是想要进行社交和追踪时事热点（10分）</li>
<li>对微博的商业模式进行SWOT评估（不需要打分，概要评估即可，10分）</li>
<li>结合微博存在的问题，进行目标分析（尽可能多地使用目标分析的元素，10分）</li>
<li>使用power-interest和power-attitude模型，阐述如何化解微博的涉众风险（10分）</li>
<li>假设你想要开发直播带货，结合三种需求获取方法，简述你将如何进行需求获取（10分）</li>
<li>简述需求管理的三种方法和流程（10分）</li>
<li>微博有一系列的封号规则，根据规则画出状态图（10分）</li>
</ol>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>需求与商业模式创新</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的移位运算</title>
    <url>/2023/03/29/shiftOperands/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java中的移位操作主要包括三种：&lt;&lt;(左移)、&gt;&gt;（有符号右移）、&gt;&gt;&gt;（无符号右移）。这三种移位操作都只能作用于<code>long</code>、<code>int</code>、<code>short</code>、<code>byte</code>、<code>char</code>这五种基本的整型类型上，由于 <code>double</code>，<code>float</code> 在二进制中的表现比较特殊，因此不能来进行移位操作。通常情况下，移位操作比普通运算的效率更高。</p>
<h1 id="左移-lt-lt"><a href="#左移-lt-lt" class="headerlink" title="左移 &lt;&lt;"></a>左移 &lt;&lt;</h1><p>左移运算是将数据的二进制数向左移动若干位，高位丢弃，低位补零，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">a &lt;&lt;= <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a的二进制数：</span></span><br><span class="line"><span class="comment">//11111111 11111111 11111111 11111111</span></span><br><span class="line"><span class="comment">//向左移动10位，高位丢弃，低位补零：</span></span><br><span class="line"><span class="comment">//11111111 11111111 11111100 00000000</span></span><br><span class="line"><span class="comment">//结果是a = -1024</span></span><br></pre></td></tr></table></figure>

<h1 id="有符号右移-gt-gt"><a href="#有符号右移-gt-gt" class="headerlink" title="有符号右移 &gt;&gt;"></a>有符号右移 &gt;&gt;</h1><p>有符号右移是将数据的二进制数向右移动若干位，低位丢弃，高位补符号位，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">a &gt;&gt;= <span class="number">3</span>;</span><br><span class="line"><span class="comment">// a的二进制数：</span></span><br><span class="line"><span class="comment">//00000000 00000000 00000000 00001000</span></span><br><span class="line"><span class="comment">//向右移动10位，低位丢弃，高位补0</span></span><br><span class="line"><span class="comment">//00000000 00000000 00000000 00000001</span></span><br><span class="line"><span class="comment">//结果是a = 1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span>-<span class="number">8</span>;</span><br><span class="line">b &gt;&gt;= <span class="number">3</span>;</span><br><span class="line"><span class="comment">// b的二进制数：</span></span><br><span class="line"><span class="comment">//11111111 11111111 11111111 11111000</span></span><br><span class="line"><span class="comment">//向右移动10位，低位丢弃，高位补1</span></span><br><span class="line"><span class="comment">//11111111 11111111 11111111 11111111</span></span><br><span class="line"><span class="comment">//结果是b = -1</span></span><br></pre></td></tr></table></figure>

<h1 id="无符号右移-gt-gt-gt"><a href="#无符号右移-gt-gt-gt" class="headerlink" title="无符号右移 &gt;&gt;&gt;"></a>无符号右移 &gt;&gt;&gt;</h1><p>无符号右移是将数据的二进制数向右移动若干位，低位丢弃，高位补0，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span>-<span class="number">8</span>;</span><br><span class="line">b &gt;&gt;= <span class="number">3</span>;</span><br><span class="line"><span class="comment">// b的二进制数：</span></span><br><span class="line"><span class="comment">//11111111 11111111 11111111 11111000</span></span><br><span class="line"><span class="comment">//向右移动10位，低位丢弃，高位补0</span></span><br><span class="line"><span class="comment">//00011111 11111111 11111111 11111111</span></span><br><span class="line"><span class="comment">//结果是b = 536870911</span></span><br></pre></td></tr></table></figure>

<p>可以发现正数的&gt;&gt;和&gt;&gt;&gt;是等价的</p>
<h1 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h1><h3 id="对-short、byte、char-的移位操作"><a href="#对-short、byte、char-的移位操作" class="headerlink" title="对 short、byte、char 的移位操作"></a>对 short、byte、char 的移位操作</h3><p>java对short、byte和char的移位操作，首先会将其补成32位的int型，再对其进行移位操作，最后低位截取对应的位数，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">a</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">System.out.println(a &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="comment">//首先将8位的a转成32位</span></span><br><span class="line"><span class="comment">//11111110 -&gt; 11111111 11111111 11111111 11111110</span></span><br><span class="line"><span class="comment">//对这32位int进行移位，此时是无符号右移1位，高位补0</span></span><br><span class="line"><span class="comment">//01111111 11111111 11111111 11111111</span></span><br><span class="line"><span class="comment">//注意此时并没有赋值号，因此直接输出该32位的结果</span></span><br><span class="line"><span class="comment">//输出结果为：2147483647</span></span><br><span class="line">System.out.println(a &gt;&gt;= <span class="number">1</span>);</span><br><span class="line"><span class="comment">//此时有赋值号，将移位后的结果截取低8位，即11111111</span></span><br><span class="line"><span class="comment">//输出结果为：-1</span></span><br></pre></td></tr></table></figure>

<p>注意，如果输出a &gt;&gt; 3，此时不会对结果进行截取。只有a &gt;&gt;&#x3D; 3，即对a赋值的时候才会进行低位截取，比如此时a是byte类型，在java中占8位，就对移位后的结果取低8位赋给a</p>
<h3 id="移位的位数超过数值所占有的位数"><a href="#移位的位数超过数值所占有的位数" class="headerlink" title="移位的位数超过数值所占有的位数"></a>移位的位数超过数值所占有的位数</h3><p>对于要移动的位数i，如果i超过了该类型数值所占位数j，则取i%j的结果作为最终要移动的位数，其中short、byte和char类型总是会先转化为32位int，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">System.out.println(c &gt;&gt;&gt; <span class="number">8</span>);</span><br><span class="line">System.out.println(c &gt;&gt;&gt; <span class="number">32</span>);</span><br><span class="line">System.out.println(c &gt;&gt;&gt; <span class="number">33</span>);</span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>移位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL</title>
    <url>/2023/03/07/somethingAboutDB/</url>
    <content><![CDATA[<h1 id="drop、delete和truncate区别"><a href="#drop、delete和truncate区别" class="headerlink" title="drop、delete和truncate区别"></a>drop、delete和truncate区别</h1><ol>
<li><p>用法不同</p>
<ul>
<li>drop（丢弃数据）：drop table 表名，直接删除整张表，在删除表的时候使用</li>
<li>truncate（清空数据）：truncate table 表名，只删除表中的数据，再插入数据的时候自增长id从1开始，在清空表中数据的时候使用</li>
<li>delete（删除数据）：delete from 表名 where 列名&#x3D;值，删除某一行的数据，如果不加where子句和truncate table 表名作用类似</li>
</ul>
<p>truncate和不带where子句的delete、以及drop都会删除表内的数据，但是truncate和delete只删除数据不删除表的定义，执行drop语句，此表的定义和结构也会删除，即drop之后对应的表不存在。</p>
</li>
</ol>
<h1 id="SQL语句分类"><a href="#SQL语句分类" class="headerlink" title="SQL语句分类"></a>SQL语句分类</h1><h2 id="数据定义语言（DDL）"><a href="#数据定义语言（DDL）" class="headerlink" title="数据定义语言（DDL）"></a>数据定义语言（DDL）</h2><p>数据定义语言（Data Definition Language，DDL）是SQL语言集中负责数据结构定义与数据库对象定义的语言。</p>
<p>DDL的主要功能是定义数据库对象，其核心指令包括CREATE、ALTER、DROP</p>
<h2 id="数据操纵语言（DML）"><a href="#数据操纵语言（DML）" class="headerlink" title="数据操纵语言（DML）"></a>数据操纵语言（DML）</h2><h2 id="事务控制语言（TCL）"><a href="#事务控制语言（TCL）" class="headerlink" title="事务控制语言（TCL）"></a>事务控制语言（TCL）</h2><h2 id="数据控制语言（DCL）"><a href="#数据控制语言（DCL）" class="headerlink" title="数据控制语言（DCL）"></a>数据控制语言（DCL）</h2>]]></content>
      <categories>
        <category>八股</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>一些启动台图标的问题</title>
    <url>/2023/01/16/tipsForMacOS/</url>
    <content><![CDATA[<h1 id="删除启动台的无效图标"><a href="#删除启动台的无效图标" class="headerlink" title="删除启动台的无效图标"></a>删除启动台的无效图标</h1><p>问题描述：安装adobe产品的过程中启动台会添加一大堆图标，卸载后发现启动台会有无效图标残留</p>
<p>解决方法：terminal中输入以下指令，其中的APPNAME是想要删除的图标的名字</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">sqlite3 <span class="variable">$(find /private/var/folders -name com.apple.dock.launchpad 2&gt;/dev/null)</span>/db/db \ <span class="string">&quot;DELETE FROM apps WHERE title=&#x27;APPNAME&#x27;;&quot;</span>&amp;&amp;killall Dock</span><br></pre></td></tr></table></figure>

<h1 id="触控板死亡"><a href="#触控板死亡" class="headerlink" title="触控板死亡"></a>触控板死亡</h1><p>问题描述：触控板突然仿佛猝死一般，只能进行基本的单指操作，多指操作失灵</p>
<p>解决方法：</p>
<ol>
<li>COMMAND + 空格 打开聚焦搜索</li>
<li>输入活动监视器</li>
<li>找到程序坞进程</li>
<li>强制退出程序坞进程</li>
</ol>
<p>原因：TBF</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title>面经总结</title>
    <url>/2023/03/23/zhaoyinInterviewOne/</url>
    <content><![CDATA[<h1 id="操作系统中方法调用的过程"><a href="#操作系统中方法调用的过程" class="headerlink" title="操作系统中方法调用的过程"></a>操作系统中方法调用的过程</h1><h1 id="进程间通信方式"><a href="#进程间通信方式" class="headerlink" title="进程间通信方式"></a>进程间通信方式</h1><ul>
<li>匿名管道：是一种半双工通信方式，数据只能单向流动，常用于具有亲缘关系的进程间通信，主要是父子进程<ul>
<li>缺点<ul>
<li>只支持单向数据流</li>
<li>只能用于具有亲缘关系的进程之间</li>
<li>没有名字</li>
<li>管道的缓冲区是有限的</li>
<li>管道所传送的是无格式字节流，这就要求管道的读出方和写入方必须事先约定好数据的格式，比如多少字节算作一个消息</li>
</ul>
</li>
</ul>
</li>
<li>有名管道：是一种半双工通信方式，允许无亲缘关系进程间的通信</li>
<li>信号（Signal）：信号可以在任何时候发给某一进程，而无需知道该进程的状态<ul>
<li>SIGINT：程序终止信号</li>
<li>SIGQUIT：程序退出信号</li>
<li>SIGKILL：用户终止进程执行信号</li>
</ul>
</li>
<li>信号量（semaphore）：进程间同步</li>
<li>消息队列<ul>
<li>存放在内核中的消息链表</li>
<li>与管道不同的是消息队列放在内核中，只有在内核重启或者显式地删除一个消息队列时，该消息队列才会被真正的删除</li>
</ul>
</li>
<li>共享内存<ul>
<li>多个进程直接读写同一块内存空间，是最快的可用IPC形式</li>
</ul>
</li>
<li>套接字：不同主机之间的进程进行双向通信</li>
</ul>
<h1 id="线程间通信方式"><a href="#线程间通信方式" class="headerlink" title="线程间通信方式"></a>线程间通信方式</h1><ol>
<li>锁机制</li>
<li>信号量</li>
<li>volatile：保证变量可见性，防止指令重排序</li>
<li>wait&#x2F;notify</li>
</ol>
<h1 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h1><ul>
<li>进程是操作系统资源分配的基本单位，线程是CPU调度的基本单位</li>
<li>一个进程可以有一个或多个线程，一个线程只能属于一个进程</li>
<li>线程是轻量级的进程</li>
</ul>
<h1 id="线程和协程的区别"><a href="#线程和协程的区别" class="headerlink" title="线程和协程的区别"></a>线程和协程的区别</h1><ul>
<li>协程是用户态的轻量级线程</li>
<li>协程的切换不需要进入内核态，直接在用户空间切换，开销比线程切换小</li>
<li>多个协程在线程内串行执行</li>
</ul>
<h1 id="三种工厂模式"><a href="#三种工厂模式" class="headerlink" title="三种工厂模式"></a>三种工厂模式</h1><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>![image-20230404133429385](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230404133429385.png)</p>
<ul>
<li>优点：<ul>
<li>实现对责任的分割，提供专门的工厂类用于创建对象</li>
<li>客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可</li>
<li>通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类</li>
</ul>
</li>
<li>缺点：<ul>
<li>工厂类集中了所有产品创建逻辑</li>
<li>增加了系统中类的个数</li>
<li>系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，违反了开闭原则</li>
<li>工厂角色无法形成基于继承的等级结构</li>
</ul>
</li>
<li>适用场景<ul>
<li>工厂类负责创建的对象比较少</li>
<li>客户端只知道传入工厂类的参数，对于如何创建对象不关心</li>
</ul>
</li>
</ul>
<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><ul>
<li><p>模式定义</p>
<ul>
<li>工厂父类负责定义创建产品对象的公共接口，而工厂子类负责生成具体的产品对象</li>
</ul>
</li>
<li><p>模式结构</p>
<p>![image-20230404134634411](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230404134634411.png)</p>
</li>
<li><p>模式优点</p>
<ul>
<li>在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，只要添加一个具体工厂和具体产品即可，完全符合开闭原则</li>
</ul>
</li>
<li><p>模式缺点</p>
<ul>
<li>添加新产品时，需要编写新的具体产品类，还要提供与之对应的具体工厂类，系统中类的个数成对增加，增加了系统复杂度</li>
<li>增加了抽象工厂这一抽象层，增加了系统的抽象性和理解难度</li>
</ul>
</li>
<li><p>适用环境</p>
<ul>
<li>一个类不知道它所需要的对象的类</li>
<li>一个类通过其子类来指定创建哪个对象</li>
<li>将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无需关心是哪个工厂子类创建产品子类，需要时再动态指定</li>
</ul>
</li>
</ul>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><ul>
<li><p>模式结构</p>
<p>![image-20230404140149289](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230404140149289.png)</p>
</li>
<li><p>模式优点</p>
<ul>
<li>保证客户端始终只使用同一个产品族中的对象</li>
<li>增加新的具体工厂和产品族很方便，无须修改已有系统，符合开闭原则</li>
</ul>
</li>
<li><p>模式缺点</p>
<ul>
<li>开闭原则的倾斜性：增加新的产品族容易，增加新的产品等级结构麻烦，难以扩展抽象工厂来生产新种类的产品</li>
</ul>
</li>
<li><p>适用环境</p>
<ul>
<li>一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节</li>
<li>有多于一个的产品族，属于同一个产品族的产品在一起使用</li>
<li>所有的产品以同样的接口出现，客户端不依赖于具体实现</li>
</ul>
</li>
</ul>
<h1 id="面向对象六大设计原则"><a href="#面向对象六大设计原则" class="headerlink" title="面向对象六大设计原则"></a>面向对象六大设计原则</h1><ul>
<li>开闭原则</li>
<li>里氏代换原则</li>
<li>迪米特法则</li>
<li>依赖倒置原则</li>
<li>单一职责原则</li>
<li>接口隔离原则</li>
</ul>
<h1 id="HTTP重定向和转发的区别"><a href="#HTTP重定向和转发的区别" class="headerlink" title="HTTP重定向和转发的区别"></a>HTTP重定向和转发的区别</h1><ul>
<li>重定向：浏览器访问url，服务端返回一个新的url，浏览器重新访问这个新的url</li>
<li>转发：浏览器访问url，服务器进行转发，返回对应的结果</li>
<li>访问次数：重定向需要访问两次，转发只需要访问一次</li>
</ul>
<h1 id="cookie和session的区别"><a href="#cookie和session的区别" class="headerlink" title="cookie和session的区别"></a>cookie和session的区别</h1><ul>
<li>存储位置不同：cookie保存在客户端，session保存在服务器</li>
<li>安全性不同：cookie保存在客户端，所以不安全，考虑到安全应当使用session</li>
<li>有效期不同：cookie可以永久保存，session一般都有时效性</li>
<li>存取值的类型不同：cookie 只支持key-value，session存放的是key-object</li>
<li>存储大小不同： 单个 cookie 保存的数据不能超过 4KB，session 可存储数据远高于 cookie，但是当访问量过多，会占用过多的服务器资源</li>
</ul>
<h2 id="禁用cookie了怎么办"><a href="#禁用cookie了怎么办" class="headerlink" title="禁用cookie了怎么办"></a>禁用cookie了怎么办</h2><ul>
<li>URL重写：直接把sessionId附加在URL路径后面，手机浏览器一般都是如此实现</li>
<li>表单隐藏域：服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把sessionId传回服务器</li>
</ul>
<p>参考：<a href="https://www.cnblogs.com/l199616j/p/11195667.html">https://www.cnblogs.com/l199616j/p/11195667.html</a></p>
<h1 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h1><ul>
<li><strong>是否面向连接</strong>：TCP提供面向连接的服务，UDP无连接</li>
<li><strong>是否是可靠传输</strong>：TCP实现了可靠传输，UDP不可靠</li>
<li><strong>传输效率</strong>： TCP 进行传输的时候多了连接、确认、重传等机制，所以 TCP 的传输效率要比 UDP 低很多</li>
<li><strong>首部开销</strong>：TCP为了保证可靠性传输所以头部开销大（20-60字节），UDP头部开销小（8字节）</li>
<li><strong>是否支持广播</strong>：TCP只支持点对点，UDP支持多播、组播</li>
<li><strong>传输形式</strong> ： TCP 是面向字节流的，UDP 是面向报文的</li>
<li><strong>是否有状态</strong> ：这个和上面的“是否可靠传输”相对应。TCP 传输是有状态的，这个有状态说的是 TCP 会去记录自己发送消息的状态比如消息是否发送了、是否被接收了等等。为此 ，TCP 需要维持复杂的连接状态表。而 UDP 是无状态服务，简单来说就是不管发出去之后的事情了</li>
</ul>
<h1 id="TCP传输可靠性保障"><a href="#TCP传输可靠性保障" class="headerlink" title="TCP传输可靠性保障"></a>TCP传输可靠性保障</h1><h2 id="TCP如何保证可靠性传输"><a href="#TCP如何保证可靠性传输" class="headerlink" title="TCP如何保证可靠性传输"></a>TCP如何保证可靠性传输</h2><ul>
<li>基于数据块传输</li>
<li>数据块重排序和去重</li>
<li>校验和</li>
<li>超时重传</li>
<li>流量控制</li>
<li>拥塞控制</li>
</ul>
<h2 id="TCP如何实现流量控制"><a href="#TCP如何实现流量控制" class="headerlink" title="TCP如何实现流量控制"></a>TCP如何实现流量控制</h2><ul>
<li>滑动窗口</li>
</ul>
<h2 id="TCP如何实现拥塞控制"><a href="#TCP如何实现拥塞控制" class="headerlink" title="TCP如何实现拥塞控制"></a>TCP如何实现拥塞控制</h2><ul>
<li><strong>慢开始</strong>，拥塞窗口初始值为 1，每经过一个传播轮次，拥塞窗口翻倍</li>
<li><strong>拥塞避免</strong>，每经过一个往返时间 RTT 就把发送方的拥塞窗口加 1</li>
<li><strong>快重传与快恢复</strong>，接收方接收到一个不按顺序的数据段，它会立即给发送方发送一个重复确认。如果发送方收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段</li>
</ul>
<h1 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h1><ul>
<li>端口：HTTP默认端口是80，HTTPS默认端口是443</li>
<li>HTTP不安全，HTTPS安全</li>
</ul>
<h1 id="HTTP1-0和HTTP1-1"><a href="#HTTP1-0和HTTP1-1" class="headerlink" title="HTTP1.0和HTTP1.1"></a>HTTP1.0和HTTP1.1</h1><ul>
<li>HTTP1.0短连接，HTTP1.1长连接</li>
<li>状态码：新增状态码，100——请求大资源前的预热请求</li>
<li>带宽优化，可以传输特定范围的数据</li>
<li>Host头处理：HTTP&#x2F;1.1在请求头中加入了Host字段</li>
</ul>
<h1 id="自动拆箱和装箱的底层原理"><a href="#自动拆箱和装箱的底层原理" class="headerlink" title="自动拆箱和装箱的底层原理"></a>自动拆箱和装箱的底层原理</h1><p><strong>自动装箱的底层原理</strong>：自动装箱实际上调用的是Integer中的静态方法valueOf()，将基本数据类型的int数值包装成了一个Integer对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">integerVal</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等效于</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">integerVal</span> <span class="operator">=</span> Integer.valueOf(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p><strong>自动拆箱的底层原理</strong>：自动拆箱的底层实际上调用的是Integer对象的intValue()，得到对象内的int变量的数值，然后给赋值给变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">intVal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//等效于</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">intVal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">0</span>).intValue();</span><br></pre></td></tr></table></figure>

<h1 id="Hash函数的设计"><a href="#Hash函数的设计" class="headerlink" title="Hash函数的设计"></a>Hash函数的设计</h1><ul>
<li>除留取余法</li>
<li>基数转换法</li>
</ul>
<h2 id="HashCode方法"><a href="#HashCode方法" class="headerlink" title="HashCode方法"></a>HashCode方法</h2><ul>
<li>Java的hashcode默认返回对象的内存地址</li>
<li>String的hashcode使用基数转换法，基数是31</li>
<li>规定<ul>
<li>在 Java 应用程序执行期间，在对同一对象多次调用 hashCode 方法时，如果对象进行 equals 比较时所用的信息没有被修改，则必须一致地返回相同的整数</li>
<li>equals相等的对象，hashCode方法返回值必须相同</li>
<li>equals不想等的对象，hashCode方法返回值不一定不同</li>
</ul>
</li>
</ul>
<h1 id="Java异常体系"><a href="#Java异常体系" class="headerlink" title="Java异常体系"></a>Java异常体系</h1><ul>
<li>Throwable类有Error和Exception两个子类</li>
<li>Error常见的有OOMError、StackOverFlowError等</li>
<li>Exception主要分为IOException（checkedException）和RuntimeException（UncheckedEception）</li>
<li>IOException有ClassNotFoundException、NoSuchFieldException等</li>
<li>RuntimeException有ArithmeticException、NullpointerException等</li>
</ul>
<h1 id="Java线程生命周期及转换"><a href="#Java线程生命周期及转换" class="headerlink" title="Java线程生命周期及转换"></a>Java线程生命周期及转换</h1><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ul>
<li><code>NEW</code>：<code>new</code>一个线程后，线程进入该状态</li>
<li><code>RUNNABLE</code>：线程调用<code>start()</code>方法后进入<code>RUNNABLE</code>状态</li>
<li><code>WAITING</code>：线程等待某个事件的发生&#x2F;等待其他线程的通知（同步）</li>
<li><code>TIMED_WAITING</code>：线程等待某个事件一段时间，超过该时间后，自动回到<code>RUNNABLE</code>状态</li>
<li><code>BLOCKED</code>：线程等待获取某个资源的锁（互斥）</li>
<li><code>TERMINATED</code>：线程执行完成后进入终止状态</li>
</ul>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/concurrent/640.png" loading="lazy"></p>
<h2 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h2><ul>
<li>新建一个线程<code>new Thread()</code>后，线程进入<code>NEW</code>状态</li>
<li>线程对象创建成功后，调用该线程的<code>Thread.start()</code>，线程从<code>NEW</code>进入<code>RUNNABLE</code>状态</li>
<li><code>RUNNABLE</code>线程遇到以下方法时，会进入<code>WATING</code>状态<ul>
<li><code>Object.wait()</code>：等待某个对象，<code>JVM</code>把该线程放入<strong>锁等待队列</strong></li>
<li><code>Thread.join()</code>：主线程等待子线程结束，<code>JVM</code>把该线程放入<strong>锁等待队列</strong></li>
<li><code>LockSupport.park()</code>：AQS框架中，阻塞一个线程时调用该方法</li>
</ul>
</li>
<li><code>WAITING</code>线程遇到以下方法时，会回到<code>RUNNABLE</code>状态<ul>
<li><code>Object.notify()</code>：唤醒<strong>锁等待队列</strong>的线程，出队的线程回到就绪状态</li>
<li><code>Object.notifyAll()</code>：唤醒<strong>锁等待队列</strong>的线程，出队的线程回到就绪状态</li>
<li>等待<code>join()</code>的线程执行完毕，唤醒<strong>锁等待队列</strong>的线程，出队的线程回到就绪状态</li>
<li><code>LockSupport.unpark(t)</code>：唤醒指定的线程</li>
<li>注：在调用<code>notify</code>或者<code>notifyAll</code>方法后，等待线程不会立刻从<strong>等待队列</strong>返回，而是<strong>从等待队列移动到同步队列</strong>，竞争对象监视器</li>
</ul>
</li>
<li><code>RUNNABLE</code>线程遇到以下方法时，会进入<code>BLOCKED</code>状态<ul>
<li>获取同步锁失败，<code>JVM</code>还会把该线程放入<strong>锁同步队列</strong></li>
<li>发出<code>I/O</code>请求</li>
</ul>
</li>
<li><code>BLOCKED</code>线程遇到以下情况时，会回到<code>RUNNABLE</code>状态<ul>
<li>同步锁被释放时，<strong>锁同步队列</strong>会出队所有线程</li>
<li><code>I/O</code>处理完毕</li>
</ul>
</li>
<li>线程执行结束或者因异常意外终止都会使线程进入<code>TERMINATED</code>状态</li>
</ul>
<h2 id="WAITING和BLOCKED状态的区别"><a href="#WAITING和BLOCKED状态的区别" class="headerlink" title="WAITING和BLOCKED状态的区别"></a>WAITING和BLOCKED状态的区别</h2><ul>
<li>waiting更像同步，等待其他线程的信号</li>
<li>blocked更像互斥，等待某个资源或者没拿到锁回到blocked状态</li>
</ul>
<h1 id="Java几种内置的线程池"><a href="#Java几种内置的线程池" class="headerlink" title="Java几种内置的线程池"></a>Java几种内置的线程池</h1><table>
<thead>
<tr>
<th>线程池</th>
<th>等待队列</th>
</tr>
</thead>
<tbody><tr>
<td>FixedThreadPool（固定线程数）</td>
<td>LinkedBlockingQueue（队列最大为Integer.MAX_VALUE）</td>
</tr>
<tr>
<td>SingleThreadExcutor（一个线程）</td>
<td>LinkedBlockingQueue（队列最大为Integer.MAX_VALUE）</td>
</tr>
<tr>
<td>CacheThreadPool（最大线程为Integer.MAX_VALUE）</td>
<td>SynchronizedQueue（没有容量，每有一个任务就创建一个线程执行）</td>
</tr>
<tr>
<td>ScheduledThreadPool（按delay时间排序）</td>
<td>DelayedWorkQueue（按delay时间出队）</td>
</tr>
</tbody></table>
<h1 id="Callable和Runnable区别"><a href="#Callable和Runnable区别" class="headerlink" title="Callable和Runnable区别"></a>Callable和Runnable区别</h1><ul>
<li>返回值不同：Runnable方法没有返回值，Callable方法有返回值，调用FutureTask.get()获取返回值</li>
<li>异常处理：Runnable不能抛出异常，所有异常都要在run方法内部捕获并处理，Callable可以向外抛出异常</li>
</ul>
<h1 id="Java的I-x2F-O模型"><a href="#Java的I-x2F-O模型" class="headerlink" title="Java的I&#x2F;O模型"></a>Java的I&#x2F;O模型</h1><ul>
<li>BIO（Blocking IO）：</li>
<li>NIO</li>
<li>AIO</li>
</ul>
<h1 id="JDBC分库分页"><a href="#JDBC分库分页" class="headerlink" title="JDBC分库分页"></a>JDBC分库分页</h1><h1 id="CMS收集器和G1收集器有什么区别"><a href="#CMS收集器和G1收集器有什么区别" class="headerlink" title="CMS收集器和G1收集器有什么区别"></a>CMS收集器和G1收集器有什么区别</h1><ul>
<li>CMS（Concurrent Mark Sweep）<ul>
<li>适用场景：集中在互联网站或B&#x2F;S系统服务端上的java应用</li>
<li>使用算法：“标记-清除”</li>
<li>收集区域：老年代</li>
<li>收集步骤：初始标记、并发标记、重新标记、并发清除</li>
<li>优点：并发收集、低停顿</li>
<li>缺点：<ol>
<li>存在并发标记的阶段，所以不能等到老年代几乎完全被填满再进行收集</li>
<li>并发清除的阶段产生浮动垃圾无法回收</li>
<li>使用“标记-清除”，产生内存碎片</li>
</ol>
</li>
</ul>
</li>
<li>G1（Garbage-First）：<ul>
<li>适用场景：面向服务端应用，针对具有大内存、多处理器的机器</li>
<li>使用算法：整体上基于“标记-整理”，局部上看是基于“标记-复制”</li>
<li>收集区域：整堆收集</li>
<li>收集步骤：初始标记、并发标记、最终标记、筛选回收</li>
<li>优点：<ul>
<li>将Java堆划分为多个大小相等的独立区域（Region）</li>
<li>可预测的停顿时间（有计划地避免在整个Java堆上进行全区域收集，根据允许的收集时间，只优先回收价值最大的Region）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="新生代为什么用标记复制，不用标记整理"><a href="#新生代为什么用标记复制，不用标记整理" class="headerlink" title="新生代为什么用标记复制，不用标记整理"></a>新生代为什么用标记复制，不用标记整理</h1><ul>
<li>使用标记复制是因为新生代的对象大多存活时间较短，不需要移动待回收对象的操作，只需要将存活的直接复制到另一块空闲内存区域中，时间效率较高</li>
<li>不用标记整理是因为将存活的对象整理移动到另一端，需要大量移动操作，时间效率低</li>
</ul>
<h1 id="老年代为什么用标记整理，不用标记复制"><a href="#老年代为什么用标记整理，不用标记复制" class="headerlink" title="老年代为什么用标记整理，不用标记复制"></a>老年代为什么用标记整理，不用标记复制</h1><ul>
<li><p>用标记整理是因为老年代的对象相对较大，使用标记整理能够整合空闲内存、有效减少内存碎片，从而确保尽可能的存放晋升到老年代的对象，如果不进行整理的话会有大量的内存碎片导致放不下新晋升的大对象，从而导致频繁发生FullGC，空间效率高</p>
</li>
<li><p>不用标记复制因为老年代的对象生存时间长，使用标记复制方法会对大量存活对象进行复制，效率比较低，同时标记复制还会浪费空间，有一部分空间不能使用，空间效率低</p>
</li>
</ul>
<h1 id="对象创建过程"><a href="#对象创建过程" class="headerlink" title="对象创建过程"></a>对象创建过程</h1><ul>
<li>类加载检查</li>
<li>分配内存</li>
<li>赋初始值</li>
<li>设置对象头</li>
<li>执行init方法</li>
</ul>
<h1 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h1><ul>
<li>-Xmx和-Xms调整堆内存最大值和最小值，一般设置成相同，可以避免java 垃圾回收机制清理完堆区后重新分隔计算堆区的大小而浪费资源、增加GC次数，-Xmx默认值是物理内存的1&#x2F;4，-Xms默认值是物理内存的1&#x2F;64</li>
<li>-Xmn，新生代大小，过小会增加Minor GC频率，过大会减小老年代的大小，官方推荐新生代占堆空间的3&#x2F;8</li>
<li>-Xss，线程栈空间大小</li>
<li>-XX:NewRatio，设置新生代和老年代的比值，比如设置成4，即新生代：老年代&#x3D;1:4，新生代占整个堆的1&#x2F;5</li>
<li>-XX:SuvivorRatio，设置两个Suvivor区和Eden区的比值，官方推荐8:1:1</li>
<li>-XX:MaxTenuringThreshold：晋升到老年代的阈值</li>
<li>-XX:MaxMetaspaceSize&#x3D;10M：设置元空间大小</li>
</ul>
<h1 id="如何排查内存泄漏"><a href="#如何排查内存泄漏" class="headerlink" title="如何排查内存泄漏"></a>如何排查内存泄漏</h1><ol>
<li><p>配置JVM启动参数</p>
<ul>
<li><p>-XX:+HeapDumpOnOutOfMemoryError：输出Heap Dump文件</p>
</li>
<li><p>-XX:HeapDumpPath&#x3D;路径：输出Heap Dump文件的路径</p>
</li>
</ul>
</li>
<li><p>确定频繁GC的现象</p>
<ul>
<li><p><strong>【jps】虚拟机进程状况工具</strong>：命令格式 jps [ options ] [ hostid ]</p>
<ul>
<li>jps -l查看虚拟机进程号</li>
</ul>
</li>
<li><p><strong>【jstat】虚拟机统计信息监视工具</strong>：命令格式：<code>jstat [ option vmid [interval[s|ms] [count]] ]</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jstat -gcutil 20954 1000</span><br><span class="line">//gcutil指：已使用空间站总空间的百分比。</span><br><span class="line">//20954指：pid</span><br><span class="line">//1000指：每1000毫秒查询一次，一直查</span><br></pre></td></tr></table></figure>

<ul>
<li>S0 S1两个Survivor区使用情况，E是Eden区，O是老年代，M是元空间，YGC是Young GC发生次数，YGCT是Young GC时间，后面同理，GCT是GC总时长</li>
<li>![image-20230420122050808](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230420122050808.png)</li>
</ul>
</li>
</ul>
</li>
<li><p>查看hprof文件找出导致频繁GC的原因，查看哪些占用空间多的类，比如如果一个HashMap的元素有很多个，占用内存过多，明显不正常</p>
</li>
</ol>
<h1 id="JVM和Java进程的关系"><a href="#JVM和Java进程的关系" class="headerlink" title="JVM和Java进程的关系"></a>JVM和Java进程的关系</h1><p>一个JVM实例本身就作为操作系统的一个进程，因此JVM实例由操作系统管理。Java 进程和 JVM 进程是一种包含关系，也就是说，JVM 进程是 Java 进程中的一个子进程。当 Java 程序启动时，操作系统会为 Java 进程分配一块内存空间作为其虚拟地址空间，并在其中创建 JVM 实例。JVM 实例作为 Java 程序的运行时环境，会使用 Java 进程分配的内存空间来管理 Java 程序的执行和资源分配</p>
<p>因此，Java 进程可以被看作是包含 JVM 进程的容器。在 Java 进程中，JVM 进程是负责 Java 程序执行的主要组成部分，负责加载 Java 程序，解释 Java 字节码并生成本地机器代码，管理 Java 程序运行时的内存和资源等。同时，Java 进程也会包含其他组件，如 Java 类库、应用程序配置信息等</p>
<h1 id="为什么线程间不能共享栈"><a href="#为什么线程间不能共享栈" class="headerlink" title="为什么线程间不能共享栈"></a>为什么线程间不能共享栈</h1><p>不同线程可能会调用相同的方法，方法本身并没有状态，根据调用者传进来的参数执行方法。栈帧内有局部变量表，根据这些局部变量表才能实现对方法的不同调用，如果共享栈会导致多线程对方法调用的实效，线程之间的隔离性被破坏。</p>
<h1 id="中断线程有哪些方法"><a href="#中断线程有哪些方法" class="headerlink" title="中断线程有哪些方法"></a>中断线程有哪些方法</h1><ol>
<li>标识位<ul>
<li>设置一个标识位，将线程的运行代码放到这个while循环中</li>
<li>当标识位被设置为false时，线程结束</li>
</ul>
</li>
<li><code>interrupt()</code>+<code>isInterrupted()</code><ul>
<li><code>Thread.interrupt()</code>：在线程受到阻塞时抛出一个中断信号，这样线程就得以退出阻塞的状态</li>
<li><code>Thread.isInterrupted()</code>：判断目标线程是否被中断，不会清除中断标记</li>
</ul>
</li>
<li><code>interrupt()+InterruptException</code><ul>
<li>跟2差不多，接收到中断异常结束线程</li>
</ul>
</li>
</ol>
<h1 id="synchronized底层实现原理"><a href="#synchronized底层实现原理" class="headerlink" title="synchronized底层实现原理"></a>synchronized底层实现原理</h1><p><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</p>
<p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。</p>
<p><strong>不过两者的本质都是对对象监视器 monitor 的获取</strong></p>
<h1 id="synchronized和Lock的区别"><a href="#synchronized和Lock的区别" class="headerlink" title="synchronized和Lock的区别"></a>synchronized和Lock的区别</h1><ul>
<li>synchronized是关键字，其实现依赖于JVM，并没有暴露给我们看</li>
<li>Lock是一个接口，具体有不同的实现类，是在API层面实现的，是直接暴露给我们的，以具体实现类ReetrantLock为例<ul>
<li><strong>等待可中断：</strong><code>ReentrantLock</code>提供了一种能够中断等待锁的线程的机制，通过 <code>lock.lockInterruptibly()</code> 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情</li>
<li><strong>可实现公平锁</strong>：<code>ReentrantLock</code>可以指定是公平锁还是非公平锁，而<code>synchronized</code>只能是非公平锁。<code>ReentrantLock</code>默认情况是非公平的，可以通过 <code>ReentrantLock</code>类的<code>ReentrantLock(boolean fair)</code>构造方法来制定是否是公平的</li>
<li><strong>可实现选择性通知</strong>：<code>synchronized</code>关键字与<code>wait()</code>和<code>notify()</code>&#x2F;<code>notifyAll()</code>方法相结合可以实现等待&#x2F;通知机制。<code>ReentrantLock</code>类当然也可以实现，但是需要借助于<code>Condition</code>接口与<code>newCondition()</code>方法</li>
</ul>
</li>
</ul>
<h1 id="SpringBoot使用三级缓存解决循环依赖"><a href="#SpringBoot使用三级缓存解决循环依赖" class="headerlink" title="SpringBoot使用三级缓存解决循环依赖"></a>SpringBoot使用三级缓存解决循环依赖</h1><ol>
<li>singletonObjects：缓存某个beanName对应的经过了完整生命周期的bean</li>
<li>earlySingletonObjects：缓存提前拿原始对象进行了AOP之后得到的代理对象，原始对象还没有进行属性注入和后续的BeanPostProcessor等生命周期</li>
<li>singletonFactories：缓存的是一个ObjectFactory，主要用来去生成原始对象进行了AOP之后得到的代理对象，在每个Bean的生成过程中，都会提前暴露一个工厂，这个工厂可能用到，也可能用不到，如果没有出现循环依赖依赖本bean，那么这个工厂无用，本bean按照自己的生命周期执行，执行完后直接把本bean放入singletonObjects中即可，如果出现了循环依赖依赖了本bean，则另外那个bean执行ObjectFactory提交得到一个AOP之后的代理对象(如果有AOP的话，如果无需AOP，则直接得到一个原始对象)。</li>
<li>其实还要一个缓存，就是earlyProxyReferences，它用来记录某个原始对象是否进行过AOP了。</li>
</ol>
<h2 id="二级缓存能解决循环依赖吗？"><a href="#二级缓存能解决循环依赖吗？" class="headerlink" title="二级缓存能解决循环依赖吗？"></a>二级缓存能解决循环依赖吗？</h2><p>如果使用二级缓存解决循环依赖，即所有的Bean在实例化后就要完成AOP代理，违背了Spring设计原则。Spring在设计之初就是通过AnnotationAwareAspectJAutoProxyCreator这个后置处理器来在Bean生命周期的最后一步来完成AOP代理，而不是在实例化后就立马进行AOP代理</p>
<p><strong>这个工厂的目的在于延迟对实例化阶段生成的对象的代理，只有真正发生循环依赖的时候，才去提前生成代理对象，否则只会创建一个工厂并将其放入到三级缓存中，但是不会去通过这个工厂去真正创建对象</strong></p>
<h1 id="SpringBoot两种代理方式各自的缺陷"><a href="#SpringBoot两种代理方式各自的缺陷" class="headerlink" title="SpringBoot两种代理方式各自的缺陷"></a>SpringBoot两种代理方式各自的缺陷</h1><h2 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h2><ul>
<li>不支持代理没有实现接口的类</li>
</ul>
<h2 id="CGLIB"><a href="#CGLIB" class="headerlink" title="CGLIB"></a>CGLIB</h2><ul>
<li>不支持代理被声明为<code>final</code>的类</li>
</ul>
<h1 id="Spingboot和Spring的区别"><a href="#Spingboot和Spring的区别" class="headerlink" title="Spingboot和Spring的区别"></a>Spingboot和Spring的区别</h1><h1 id="MySQL慢查询如何优化"><a href="#MySQL慢查询如何优化" class="headerlink" title="MySQL慢查询如何优化"></a>MySQL慢查询如何优化</h1><h1 id="B-树的缺点"><a href="#B-树的缺点" class="headerlink" title="B+树的缺点"></a>B+树的缺点</h1><p>随着叶子节点的分裂，逻辑上连续的叶子节点在物理上往往不连续，甚至分离的很远，但做范围查询时，会产生大量随机IO</p>
<h1 id="MySQL联合索引"><a href="#MySQL联合索引" class="headerlink" title="MySQL联合索引"></a>MySQL联合索引</h1><ul>
<li>假设当前数据库建立联合索引<code>(name,age,class)</code>，索引页内部<strong>先按照name排序、name相同时再按age排序、age相同时再按class排序</strong>，即<code>name</code>全局有序，<code>age</code>和<code>class</code>局部有序</li>
<li>联合索引命中<ul>
<li><code>where name=‘effy’ and age=19 and class=2</code>，那么使用联合索引进行二分查找，先查找到<code>name=‘effy&#39;</code>，再查询<code>age=19</code>，再<code>class=2</code></li>
<li><code>where age=19 and class = 2 and name=‘effy’</code>, 数据库会自动优化查询条件顺序，因此联合索引同样命中</li>
</ul>
</li>
<li>联合索引部分命中<ul>
<li><code>where name &gt; &#39;effy&#39; and name &lt; &#39;lyf&#39; </code>，只有<code>name</code>字段使用到联合索引</li>
<li><code>where name &gt; &#39;effy&#39; and name &lt; &#39;lyf&#39; and age=19</code>，此时只有<code>name</code>字段使用到联合索引，<code>age</code>字段是不会使用的。因为先按照<code>name</code>条件查出来的数据中age不是有序的，比如先按照name条件查出来三条数据<code>(effy,19)</code>，<code>(effy,20)</code>，<code>(lyf,19)</code>,此时age并不有序，因此只能对其进行扫描</li>
<li><code>where name &gt;= &#39;effy&#39; and age=19</code>，<code>name</code>和<code>age</code>都使用到联合索引，因为<code>name=‘effy&#39;时</code>，命中<code>age=19</code>，此时继续对age进行二分查找，从<code>name = &#39;effy&#39; and age=19</code>的第一条数据往后扫描，而不是从<code>name=effy</code>的第一条数据开始</li>
<li><code>where name BETWEEN &#39;effy&#39; and &#39;lyf&#39; and age=19</code>，同上</li>
<li><code>where name LIKE &#39;e%&#39; and age=19</code>，同上上</li>
</ul>
</li>
<li>联合索引失效情况<ul>
<li><code>where name=&#39;effy&#39; or age=19</code>，由于是<code>or</code>连接，联合索引失效</li>
<li><code>where age=19 and class=2</code>，因为联合索引首先按照<code>name</code>进行排序，但查询条件中不存在<code>name</code>字段，所以索引失效</li>
</ul>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>联合索引的最左匹配原则，在遇到范围查询（如 &gt;、&lt;）的时候，就会停止匹配，范围查询的字段可以用到联合索引，但是范围查询字段后的字段无法用到联合索引。（但对于 &gt;&#x3D;、&lt;&#x3D;、BETWEEN、LIKE前缀匹配的范围查询，并不会停止匹配）</strong></p>
<h2 id="联合索引和单列索引查找区别"><a href="#联合索引和单列索引查找区别" class="headerlink" title="联合索引和单列索引查找区别"></a>联合索引和单列索引查找区别</h2><ul>
<li>现有查询条件<code>name=‘effy’ and age=19 and class=2</code><ul>
<li>分别对name、age和class建立单列索引<ul>
<li>当有多个索引命中后，优化器选择最高效的索引。比如是<code>name</code>索引，那么先按照<code>name</code>索引查出所有<code>name=‘effy’</code>的主键，再到主键索引进行回表操作，查出所有数据，再对这些数据进行扫描，丢弃不满足<code>age=19</code>或者<code>class=2</code>的数据</li>
</ul>
</li>
<li>对name，age，class建立联合索引<ul>
<li>直接扫描该联合索引的b+树，首先二分查找找到name&#x3D;’effy‘，然后二分查找找到age&#x3D;19，再二分查找找到class&#x3D;2</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="为什么推荐使用自增id而不推荐使用uid或者身份证号等"><a href="#为什么推荐使用自增id而不推荐使用uid或者身份证号等" class="headerlink" title="为什么推荐使用自增id而不推荐使用uid或者身份证号等"></a>为什么推荐使用自增id而不推荐使用uid或者身份证号等</h2><p>B+Tree是自底向上插入的，我们优先会将数据插入到叶子节点中，然后整个树会根据底部的叶子节点进行分裂或者合并</p>
<ul>
<li>当我们使用的是自增id，叶子节点链表会根据当前最后一条的位置，将最新的一条数据顺序的插入到最后</li>
<li>但是当插入一个uid时，mysql根本不知道他该插入到哪个位置，需要从头开始寻找插入的位置。但是当中间需要插入的页满了时，会造成页的分裂和合并，极大地影响了效率</li>
</ul>
<h2 id="为什么叶子结点存放的是主键id而不是数据"><a href="#为什么叶子结点存放的是主键id而不是数据" class="headerlink" title="为什么叶子结点存放的是主键id而不是数据"></a>为什么叶子结点存放的是主键id而不是数据</h2><ul>
<li><strong>节省存储空间</strong>。叶子结点存数据会导致一份数据存了多份，空间占用翻倍。</li>
<li><strong>维护一致性</strong>。都通过主键索引来找到最终的数据，避免维护多份数据导致不一致的情况</li>
</ul>
<h2 id="Hash索引的缺点"><a href="#Hash索引的缺点" class="headerlink" title="Hash索引的缺点"></a>Hash索引的缺点</h2><ol>
<li><strong>Hash索引仅仅能满足等值查询，不能使用范围查询</strong>。<strong>由于Hash索引存放的是进行Hash运算之后的Hash值</strong> ，经过相应的Hash算法处理之后的Hash值的大小关系，并不能保证和Hash运算前完全一样</li>
<li><strong>Hash索引不能利用部分索引键查询</strong>。 对于联合索引，Hash索引在计算Hash值的时候是联合索引键合并后再一起计算Hash值，而不是单独计算Hash值，所以通过联合索引的前面一个或几个索引键进行查询的时候，Hash索引也无法被利用</li>
<li><strong>Hash索引无法被用来避免数据的排序操作</strong>。由于Hash索引中存放的是经过Hash计算之后的Hash值，而Hash值的大小关系并不一定和Hash运算前的键值完全一样，所以数据库无法利用索引的数据来避免任何排序运算</li>
</ol>
<h1 id="MySQL锁的相关问题"><a href="#MySQL锁的相关问题" class="headerlink" title="MySQL锁的相关问题"></a>MySQL锁的相关问题</h1><h2 id="数据库通过什么方式保证了事务的隔离性"><a href="#数据库通过什么方式保证了事务的隔离性" class="headerlink" title="数据库通过什么方式保证了事务的隔离性"></a>数据库通过什么方式保证了事务的隔离性</h2><p>通过加锁来实现事务的隔离性</p>
<h2 id="锁是基于什么实现的"><a href="#锁是基于什么实现的" class="headerlink" title="锁是基于什么实现的"></a>锁是基于什么实现的</h2><p>数据库里面的锁是基于索引实现的，在Innodb中我们的锁都是作用在索引上面的，当我们的SQL命中索引时，那么锁住的就是命中条件内的索引节点(行锁)，如果没有命中索引的话，那我们锁的就是整个索引树（表锁）</p>
<h2 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h2><ul>
<li>基于锁的属性分类<ul>
<li>共享锁、排他锁</li>
</ul>
</li>
<li>基于锁的粒度分类<ul>
<li>表锁、行锁（记录锁、间隙锁、临键锁）</li>
</ul>
</li>
<li>基于锁的状态分类<ul>
<li>意向共享锁、意向排它锁</li>
</ul>
</li>
</ul>
<h1 id="MySQL三大日志"><a href="#MySQL三大日志" class="headerlink" title="MySQL三大日志"></a>MySQL三大日志</h1><h2 id="redolog"><a href="#redolog" class="headerlink" title="redolog"></a>redolog</h2><ul>
<li>作用：MySQl崩溃或宕机恢复，崩溃恢复能力</li>
<li>三种刷盘策略：<code>InnoDB</code> 存储引擎有一个后台线程，每隔<code>1</code> 秒，就会把 <code>redo log buffer</code> 中的内容写到文件系统缓存（<code>page cache</code>），然后调用 <code>fsync</code> 刷盘<ul>
<li>0：事务提交时不刷盘</li>
<li>1：事务提交时刷盘</li>
<li>2：事务提交时只把 redo log buffer写到page cache里</li>
</ul>
</li>
<li>二阶段提交<ul>
<li>更新数据后，写入redolog，并设为prepare阶段</li>
<li>提交事务阶段，先写入binlog</li>
<li>再将redolog设为commited阶段</li>
</ul>
</li>
</ul>
<h2 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h2><ul>
<li>作用：集群间保证数据一致性</li>
<li>三种日志格式<ul>
<li>statement：记录sql原文</li>
<li>row：不是简单的<code>SQL</code>语句，还包含操作的具体数据，将now（）替换成数据</li>
<li>mixed：<code>MySQL</code>会判断这条<code>SQL</code>语句是否可能引起数据不一致，如果是，就用<code>row</code>格式，否则就用<code>statement</code>格式</li>
</ul>
</li>
<li>写入流程：write，是指把日志写入到文件系统的 page cache，并没有把数据持久化到磁盘：fsync，才是将数据持久化到磁盘的操作</li>
<li>三种刷盘策略：<ul>
<li>0：每次提交事务都只write，系统决定何时fsync</li>
<li>1：每次提交事务都fsync</li>
<li>N：累计N个事务后再fsync</li>
</ul>
</li>
</ul>
<h2 id="undolog"><a href="#undolog" class="headerlink" title="undolog"></a>undolog</h2><ul>
<li>作用：保证事务的原子性，事务回滚</li>
</ul>
<h1 id="MySQL事务隔离级别"><a href="#MySQL事务隔离级别" class="headerlink" title="MySQL事务隔离级别"></a>MySQL事务隔离级别</h1><ul>
<li>脏读</li>
<li>不可重复读</li>
<li>幻读</li>
</ul>
<h1 id="使用Redis实现分布式锁"><a href="#使用Redis实现分布式锁" class="headerlink" title="使用Redis实现分布式锁"></a>使用Redis实现分布式锁</h1><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/mocas_wang/article/details/118407222">Spring中的循环依赖解决详解</a></p>
]]></content>
  </entry>
  <entry>
    <title>How to compile JDK in M1 MacBook——在M1上编译JDK</title>
    <url>/2023/05/15/InsideTheJVM/insideTheJVMOne/</url>
    <content><![CDATA[<h1 id="Introdution"><a href="#Introdution" class="headerlink" title="Introdution"></a>Introdution</h1><p>最近开始看《深入理解Java虚拟机》，出来混果然还是要还的，就从最基础的债开始还起吧。第一部分主要是编译JDK，由于个人是M1芯片，导致编译过程中出现诸多问题，网上又少有相关报错，导致花费了不少时间</p>
<span id="more"></span>

<h1 id="System-Environment"><a href="#System-Environment" class="headerlink" title="System Environment"></a>System Environment</h1><table>
<thead>
<tr>
<th>Workspace Specs</th>
<th><img src="https://img.shields.io/badge/Apple-MacBook%20Pro%2014%202021-lightgrey?&logo=apple&logoColor=white"  loading="lazy"/></th>
</tr>
</thead>
<tbody><tr>
<td>OS</td>
<td><img src='https://img.shields.io/badge/macOS-Ventura%2013.3.1-orange?&logo=apple&logoColor=white' loading="lazy"/></td>
</tr>
<tr>
<td>Chip</td>
<td><img src='https://img.shields.io/badge/Aarch__64-M1%20Pro-9cf'  loading="lazy"/></td>
</tr>
<tr>
<td>Xcode</td>
<td><img src='https://img.shields.io/badge/Xcode-14.3-blue?logo=xcode'  loading="lazy"/></td>
</tr>
<tr>
<td>Xcode Comand Line Tools</td>
<td>If you have installed homebrew before, then homebrew will automatically install it for you, and if not, please refer to <a href="https://mac.install.guide/commandlinetools/index.html">this article</a>.</td>
</tr>
<tr>
<td>Homebrew</td>
<td><img src='https://img.shields.io/badge/Version-3.6.8-green'  loading="lazy"/></td>
</tr>
</tbody></table>
<h1 id="Get-JDK-source-code"><a href="#Get-JDK-source-code" class="headerlink" title="Get JDK source code"></a>Get JDK source code</h1><ol>
<li><p>First, we need to download the source code of openJDK12 from <a href="https://hg.openjdk.java.net/jdk/jdk12/">the openJDK’s official website</a></p>
</li>
<li><p>If the JDK’s version that we want to compile is N , then we need to prepare another JDK whose version has to be N-1 at least. That’s because part of JDK is written by Java, so we need another available JDK in compile time when we compile it,  and such another JDK is officially called ‘<strong>Bootstrap JDK</strong>‘.  So we need to install openJDK 11 with instruction <code>brew install cask adoptopenjdk11</code> had we install homebrew before.</p>
</li>
<li><p>The directory structure is as follows:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openjdk</span><br><span class="line">├── ADDITIONAL_LICENSE_INFO</span><br><span class="line">├── ASSEMBLY_EXCEPTION</span><br><span class="line">├── CONTRIBUTING.md</span><br><span class="line">├── LICENSE</span><br><span class="line">├── Makefile</span><br><span class="line">├── README.md</span><br><span class="line">├── bin</span><br><span class="line">├── build</span><br><span class="line">├── configure</span><br><span class="line">├── doc</span><br><span class="line">├── make</span><br><span class="line">├── src</span><br><span class="line">└── <span class="built_in">test</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="Configure"><a href="#Configure" class="headerlink" title="Configure"></a>Configure</h1><ol>
<li><p>Execute <code>bash configure</code> in the root directory of the JDK you just get, you will get the error message like this If all goes well:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">configure: The tested number of bits <span class="keyword">in</span> the target (64) differs from the number of bits expected to be found <span class="keyword">in</span> the target (32) configure: error: Cannot <span class="built_in">continue</span>.</span><br></pre></td></tr></table></figure>

<p>The reason is clearly clarifed in this <a href="https://stackoverflow.com/questions/68358505/how-to-compile-openjdk-11-on-an-m1-macbook">question</a>:</p>
<blockquote>
<p>Apple Silicon chips M1, M2 are all 64-bits architectures. Do not compiler for 32-bit</p>
</blockquote>
<p>So we have to get openJDK 17, which is a relatively new version and available for M1. We also need to prepare a new Bootstrap JDK which should be Java 16. Use the same instruction <code>brew install cask adoptopenjdk16</code></p>
</li>
<li><p>Rerun <code>bash configure</code>, then you will get a new error like this:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">X <span class="string">&#x27;sprintf&#x27;</span> is deprecated: This <span class="keyword">function</span> is provided <span class="keyword">for</span> compatibility reasons only. Due to security concerns inherent <span class="keyword">in</span> the design of sprintf(3), it is highly recommended that you use snprintf(3) instead.</span><br></pre></td></tr></table></figure>

<p>As you can see from the message, sprintf is considered insecurity, but we can miss it by adding a parameter <code>--disable warnings as errors</code>, so rerun <code>bash configure --disable warnings as errors</code></p>
</li>
<li><p>If you are fortunate enough, you will see success message:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Configuration summary:</span><br><span class="line"></span><br><span class="line">* Name:           macosx-aarch64-server-release</span><br><span class="line">* Debug level:    release</span><br><span class="line">* HS debug level: product</span><br><span class="line">* JVM variants:   server</span><br><span class="line">* JVM features:   server: <span class="string">&#x27;cds compiler1 compiler2 dtrace epsilongc g1gc jfr jni-check jvmci jvmti management nmt parallelgc serialgc services shenandoahgc vm-structs zgc&#x27;</span></span><br><span class="line">* OpenJDK target: OS: macosx, CPU architecture: aarch64, address length: 64</span><br><span class="line">* Version string: 17-internal+0-adhoc.effy.openjdkbackup (17-internal)</span><br><span class="line"></span><br><span class="line">Tools summary:</span><br><span class="line"></span><br><span class="line">* Boot JDK:       openjdk version <span class="string">&quot;16.0.2&quot;</span> 2021-07-20 OpenJDK Runtime Environment Zulu16.32+15-CA (build 16.0.2+7) OpenJDK 64-Bit Server VM Zulu16.32+15-CA (build 16.0.2+7, mixed mode) (at /Users/effy/Library/Java/JavaVirtualMachines/azul-16.0.2/Contents/Home)</span><br><span class="line">* Toolchain:      clang (clang/LLVM from Xcode 14.3)</span><br><span class="line">* C Compiler:     Version 14.0.3 (at /usr/bin/clang)</span><br><span class="line">* C++ Compiler:   Version 14.0.3 (at /usr/bin/clang++)</span><br><span class="line"></span><br><span class="line">Build performance summary:</span><br><span class="line"></span><br><span class="line">* Cores to use:   8</span><br><span class="line">* Memory <span class="built_in">limit</span>:   16384 MB</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="Make-images"><a href="#Make-images" class="headerlink" title="Make images"></a>Make images</h1><ol>
<li><p>Excute <code>make images</code>, then you’ll get an error like this:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">=== Output from failing command(s) repeated here ===</span><br><span class="line">* For target support_interim-jmods_support__create_java.base.jmod_exec:</span><br><span class="line">#</span><br><span class="line"># A fatal error has been detected by the Java Runtime Environment:</span><br><span class="line">#</span><br><span class="line">#  Internal Error (assembler_aarch64.hpp:248), pid=56946, tid=9987</span><br><span class="line">#  guarantee(val &lt; (1ULL &lt;&lt; nbits)) failed: Field too big for insn</span><br><span class="line">#</span><br><span class="line"># JRE version:  (17.0.3) (build )</span><br><span class="line"># Java VM: OpenJDK 64-Bit Server VM (17.0.3+0-jvmci-22.1-b05, mixed mode, emulated-client, sharing, tiered, compressed oops, compressed class ptrs, serial gc, bsd-aarch64)</span><br><span class="line"># No core dump will be written. Core dumps have been disabled. To enable core dumping, try &quot;ulimit -c unlimited&quot; before starting Java again</span><br><span class="line">#</span><br><span class="line"># An error report file with more information is saved as:</span><br><span class="line"># /opt/labs-openjdk-17/make/hs_err_pid56946.log</span><br><span class="line">#</span><br><span class="line">#</span><br><span class="line">* For target support_interim-jmods_support__create_java.logging.jmod_exec:</span><br><span class="line">#</span><br><span class="line"># A fatal error has been detected by the Java Runtime Environment:</span><br><span class="line">#</span><br><span class="line">#  Internal Error (assembler_aarch64.hpp:248), pid=56929, tid=10243</span><br><span class="line">#  guarantee(val &lt; (1ULL &lt;&lt; nbits)) failed: Field too big for insn</span><br><span class="line">#</span><br><span class="line"># JRE version:  (17.0.3) (build )</span><br><span class="line"># Java VM: OpenJDK 64-Bit Server VM (17.0.3+0-jvmci-22.1-b05, mixed mode, emulated-client, sharing, tiered, compressed oops, compressed class ptrs, serial gc, bsd-aarch64)</span><br><span class="line"># No core dump will be written. Core dumps have been disabled. To enable core dumping, try &quot;ulimit -c unlimited&quot; before starting Java again</span><br><span class="line">#</span><br><span class="line"># An error report file with more information is saved as:</span><br><span class="line"># /opt/labs-openjdk-17/make/hs_err_pid56929.log</span><br><span class="line">#</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">* All command lines available in /opt/labs-openjdk-17/build/labsjdk/make-support/failure-logs.</span><br><span class="line">=== End of repeated output ===</span><br><span class="line"></span><br><span class="line">No indication of failed target found.</span><br><span class="line">Hint: Try searching the build log for &#x27;] Error&#x27;.</span><br><span class="line">Hint: See doc/building.html#troubleshooting for assistance.</span><br><span class="line"></span><br><span class="line">gmake[3]: Leaving directory &#x27;/opt/labs-openjdk-17&#x27;</span><br><span class="line">make[2]: *** [/opt/labs-openjdk-17/make/Init.gmk:315: main] Error 2</span><br><span class="line">make[2]: Leaving directory &#x27;/opt/labs-openjdk-17&#x27;</span><br><span class="line">make[1]: *** [/opt/labs-openjdk-17/make/Init.gmk:186: graal-builder-image] Error 2</span><br><span class="line">make[1]: Leaving directory &#x27;/opt/labs-openjdk-17&#x27;</span><br><span class="line">make: *** [labs17.makefile:27: /opt/labs-17/bin/java] Error 2</span><br></pre></td></tr></table></figure>
</li>
<li><p>You need to do like this<a href="https://github.com/openjdk/jdk17u-dev/commit/fbe05ec561e8d2a061be126c969c37c219b594f3"> issue</a> does, and add some codes in <code>src/hotspot/cpu/aarch64/immediate_aarch64.cpp</code>. </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">replicate</span><span class="params">(<span class="type">uint64_t</span> bits, <span class="type">int</span> nbits, <span class="type">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">+  <span class="built_in">assert</span>(count &gt; <span class="number">0</span>, <span class="string">&quot;must be&quot;</span>);</span><br><span class="line">+  <span class="built_in">assert</span>(nbits &gt; <span class="number">0</span>, <span class="string">&quot;must be&quot;</span>);</span><br><span class="line">+  <span class="built_in">assert</span>(count * nbits &lt;= <span class="number">64</span>, <span class="string">&quot;must be&quot;</span>);</span><br><span class="line">+</span><br><span class="line">+  <span class="comment">// Special case nbits == 64 since the shift below with that nbits value</span></span><br><span class="line">+  <span class="comment">// would result in undefined behavior.</span></span><br><span class="line">+  <span class="keyword">if</span> (nbits == <span class="number">64</span>) &#123;</span><br><span class="line">+    <span class="keyword">return</span> bits;</span><br><span class="line">+  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint64_t</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// nbits may be 64 in which case we want mask to be -1</span></span><br><span class="line">  <span class="type">uint64_t</span> mask = <span class="built_in">ones</span>(nbits);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count ; i++) &#123;</span><br><span class="line">    result &lt;&lt;= nbits;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Rerun <code>make images</code>, you will get the last error:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Compiling 56 files <span class="keyword">for</span> java.sql.rowset</span><br><span class="line">Compiling 82 files <span class="keyword">for</span> jdk.jlink</span><br><span class="line">Compiling 95 files <span class="keyword">for</span> jdk.jshell</span><br><span class="line">error: invalid integral value <span class="string">&#x27;16-DMAC_OS_X_VERSION_MIN_REQUIRED=10120&#x27;</span> <span class="keyword">in</span> <span class="string">&#x27;-mstack-alignment=16-DMAC_OS_X_VERSION_MIN_REQUIRED=10120&#x27;</span></span><br><span class="line">make[3]: *** [/Users/jdk/build/macosx-x86_64-server-fastdebug/hotspot/variant-server/libjvm/objs/bsd_x86_64.o] Error 1</span><br><span class="line">make[3]: *** Waiting <span class="keyword">for</span> unfinished <span class="built_in">jobs</span>....</span><br><span class="line">Compiling 229 files <span class="keyword">for</span> jdk.javadoc</span><br><span class="line">make[2]: *** [hotspot-server-libs] Error 2</span><br><span class="line">make[2]: *** Waiting <span class="keyword">for</span> unfinished <span class="built_in">jobs</span>....</span><br><span class="line">Compiling 2736 files <span class="keyword">for</span> java.desktop</span><br><span class="line"></span><br><span class="line">ERROR: Build failed <span class="keyword">for</span> target <span class="string">&#x27;images&#x27;</span> <span class="keyword">in</span> configuration <span class="string">&#x27;macosx-x86_64-server-fastdebug&#x27;</span> (<span class="built_in">exit</span> code 2)</span><br><span class="line">Stopping sjavac server</span><br><span class="line"></span><br><span class="line">make[1]: *** [main] Error 2</span><br><span class="line">=== Output from failing <span class="built_in">command</span>(s) repeated here ===</span><br><span class="line">make: *** [images] Error 2</span><br><span class="line">* For target hotspot_variant-server_libjvm_objs_bsd_x86_64.o:</span><br><span class="line">error: invalid integral value <span class="string">&#x27;16-DMAC_OS_X_VERSION_MIN_REQUIRED=10120&#x27;</span> <span class="keyword">in</span> <span class="string">&#x27;-mstack-alignment=16-DMAC_OS_X_VERSION_MIN_REQUIRED=10120&#x27;</span></span><br><span class="line"></span><br><span class="line">* All <span class="built_in">command</span> lines available <span class="keyword">in</span> /Users/jdk/build/macosx-x86_64-server-fastdebug/make-support/failure-logs.</span><br><span class="line">=== End of repeated output ===</span><br></pre></td></tr></table></figure>
</li>
<li><p>Fortunatelly, you just need to do like this <a href="https://github.com/openjdk/jdk/commit/d007be0952abdc8beb7b68ebf7529a939162307b">issue</a>, add two ‘spaces’ in <code>make/autoconf/flags-other.m4</code>, it’s quite weird right？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">  <span class="comment"># Fix linker warning.</span></span><br><span class="line">  <span class="comment"># Code taken from make/autoconf/flags-cflags.m4 and adapted.</span></span><br><span class="line">-  JVM_BASIC_ASFLAGS+=<span class="string">&quot;-DMAC_OS_X_VERSION_MIN_REQUIRED=<span class="variable">$MACOSX_VERSION_MIN_NODOTS</span> \</span></span><br><span class="line"><span class="string">+  JVM_BASIC_ASFLAGS+=&quot;</span> -DMAC_OS_X_VERSION_MIN_REQUIRED=<span class="variable">$MACOSX_VERSION_MIN_NODOTS</span> \</span><br><span class="line">      -mmacosx-version-min=<span class="variable">$MACOSX_VERSION_MIN</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">  if test -n &quot;</span><span class="variable">$MACOSX_VERSION_MAX</span><span class="string">&quot;; then</span></span><br><span class="line"><span class="string">-      JVM_BASIC_ASFLAGS+=&quot;</span><span class="variable">$OS_CFLAGS</span> \</span><br><span class="line">+      JVM_BASIC_ASFLAGS+=<span class="string">&quot; <span class="variable">$OS_CFLAGS</span> \</span></span><br><span class="line"><span class="string">          -DMAC_OS_X_VERSION_MAX_ALLOWED=<span class="variable">$MACOSX_VERSION_MAX_NODOTS</span>&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://stackoverflow.com/questions/68358505/how-to-compile-openjdk-11-on-an-m1-macbook">1</a>: how-to-compile-openjdk-11-on-an-m1-macbook</p>
<p><a href="https://github.com/openjdk/jdk17u-dev/commit/fbe05ec561e8d2a061be126c969c37c219b594f3">2</a>: hotspot arm64 bug exposed by latest clang</p>
<p><a href="https://github.com/openjdk/jdk/commit/d007be0952abdc8beb7b68ebf7529a939162307b">3</a>: Build failure with Xcode 13.0 after JDK-8264848</p>
<p>4: 深入理解Java虚拟机（第三版），周志明</p>
]]></content>
      <categories>
        <category>Books</category>
      </categories>
      <tags>
        <tag>深入理解Java虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>第二章——Java内存区域与内存溢出异常</title>
    <url>/2023/05/16/InsideTheJVM/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E2%80%94%E2%80%94%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h1><p>![image-20241205134533749](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20241205134533749.png)</p>
<p>![image-20241205113328261](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20241205113328261.png)</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h1><ol>
<li><p>类加载检查：当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过，如果没有，那必须先执行相应的类加载过程</p>
</li>
<li><p>分配内存：类加载检查通过后，虚拟机将为新生对象分配内存。有两种分配方式，选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有空间压缩整理的能力决定：</p>
<ul>
<li>指针碰撞：一个指针用于作为分界点的指示器，空闲内存和被使用过的内存被该指针分开，分配内存时只需将该指针向空闲内存方向移动一段与对象大小相等的距离<ul>
<li>适用：Java堆中内存是绝对规整的，使用标记-复制或者标记-整理的垃圾收集器</li>
</ul>
</li>
<li>空闲列表：虚拟机维护一个列表，记录哪些内存块可用，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录<ul>
<li>适用：Java堆中的内存并不是规整的，使用标记-清除的垃圾收集器</li>
</ul>
</li>
</ul>
<p>保证内存分配时线程安全，线程A正在创建对象a，指针还未被修改时，线程B将指针修改：</p>
<ul>
<li>CAS+失败重试</li>
<li>TLAB：为每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲(Thread local Allocation Buffer, TLAB)，线程先在本地缓冲区分配，该区域用完，分配新的缓冲区时才需要同步锁定。通过-XX:+&#x2F;-UseTLAB参数来设定</li>
</ul>
</li>
<li><p>初始化零值：将分配到的内存空间都初始化为零值，如果使用了TLAB，可以提前至TLAB分配时顺便进行。该操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，使程序能访问到这些字段的数据类型所对应的零值</p>
</li>
<li><p>设置对象头：例如该对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息</p>
</li>
<li><p>执行&lt;init&gt;()构造函数</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Books</category>
      </categories>
      <tags>
        <tag>深入理解Java虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>garbageCollect</title>
    <url>/2023/05/18/InsideTheJVM/%E7%AC%AC%E4%B8%89%E7%AB%A0%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</url>
    <content><![CDATA[<h1 id="如何判断对象应该被回收"><a href="#如何判断对象应该被回收" class="headerlink" title="如何判断对象应该被回收"></a>如何判断对象应该被回收</h1><h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><p>原理：在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数为零的对象就是不可能再被使用的。</p>
<p>缺陷：对象之间相互循环引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceCountingGC</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1MB</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">byte</span>[] bigSize = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testGC</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ReferenceCountingGC</span> <span class="variable">objA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCountingGC</span>();</span><br><span class="line">    <span class="type">ReferenceCountingGC</span> <span class="variable">objB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCountingGC</span>();</span><br><span class="line">    objA.instance = objB;</span><br><span class="line">    objB.instance = objA;</span><br><span class="line">    </span><br><span class="line">    objA = <span class="literal">null</span>;</span><br><span class="line">    objB = <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    System.gc();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主流的Java虚拟机都没有选用引用计数法</p>
<h2 id="可达性分析法"><a href="#可达性分析法" class="headerlink" title="可达性分析法"></a>可达性分析法</h2><p>当前主流的商用程序语言（Java，C#等）都是通过可达性分析算法来判定对象是否存活。</p>
<p>原理：通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，则证明此对象不可能再被使用的。</p>
<p>GC Roots：</p>
<ul>
<li>虚拟机栈中引用的对象</li>
<li>本地方法栈中引用的对象</li>
<li>类静态属性引用的对象</li>
<li>常量引用的对象</li>
<li>所有被同步锁（synchronized关键字）持有的对象</li>
<li>Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointerException、OutOfMemoryError）等，还有系统类加载器</li>
<li>反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等</li>
</ul>
<h2 id="引用的类型"><a href="#引用的类型" class="headerlink" title="引用的类型"></a>引用的类型</h2><p>在JDK 1.2之后，Java对引用的概念进行了扩充：</p>
<ul>
<li>强引用（Strongly reference）：最传统的“引用”的定义，程序代码中普遍存在的引用赋值，即类似“Object obj&#x3D;new Object()”，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象</li>
<li>软引用（Soft reference）：用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。JDK1.2之后提供了SoftReference类来实现软引用</li>
<li>弱引用（Weak reference）：用来描述非必须对象，强度比软引用更弱，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK1.2之后提供了WeakReference类来实现弱引用</li>
<li>虚引用（Phantom reference）：也称为“幽灵引用”或者“幻影引用”，最弱的一种引用关系。一个对象是否有虚引用完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。JDK1.2之后提供了PhantomReference类来实现虚引用</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>羊羊日记其二</title>
    <url>/2022/12/28/life/COVID19DiaryTwo/</url>
    <content><![CDATA[<h1 id="Day-5"><a href="#Day-5" class="headerlink" title="Day 5"></a>Day 5</h1><p>其他症状都无，唯独开始咳嗽</p>
<h1 id="Day-6"><a href="#Day-6" class="headerlink" title="Day 6"></a>Day 6</h1><p>咳咳咳咳</p>
<h1 id="Day-7"><a href="#Day-7" class="headerlink" title="Day 7"></a>Day 7</h1><p>咳咳咳咳咳死了。</p>
<p>网上说咳嗽是一个打扫战场的过程，这只怕是打扫的有亿点点久</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>羊羊日记</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法之二———归并排序</title>
    <url>/2023/04/27/sort/Mergesort/</url>
    <content><![CDATA[<h1 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h1><p>采用分治的思想，步骤可以概括为：</p>
<ol>
<li><p>先将待排序列分成左右两块</p>
</li>
<li><p>递归对左右两块排序</p>
</li>
<li><p>将左右两块合并</p>
</li>
</ol>
<p><img src="https://github.com/Lainy0605/IMGS/raw/main/blog/sort/mergesort.png" alt="重新加载" loading="lazy"></p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mergesort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        sort(array);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            System.out.println(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] array)</span>&#123;</span><br><span class="line">        <span class="comment">//temp用于保存临时合并结果</span></span><br><span class="line">        <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[array.length];</span><br><span class="line">        sort(array,<span class="number">0</span>,array.length-<span class="number">1</span>,temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] array,<span class="type">int</span> start,<span class="type">int</span> end,<span class="type">int</span>[] temp)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &lt; end)&#123;</span><br><span class="line">          	<span class="comment">//先分</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (end - start) / <span class="number">2</span> + start;</span><br><span class="line">            <span class="comment">//递归排序</span></span><br><span class="line">            sort(array,start,mid,temp);</span><br><span class="line">            sort(array,mid + <span class="number">1</span>,end,temp);</span><br><span class="line">            <span class="comment">//再合</span></span><br><span class="line">            merge(array,start,end,temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] array,<span class="type">int</span> start,<span class="type">int</span> end,<span class="type">int</span>[] temp)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (end - start) / <span class="number">2</span> + start;</span><br><span class="line">        <span class="comment">//左半边指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start;</span><br><span class="line">        <span class="comment">//右半边指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> mid + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//temp指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= end)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i] &lt;= array[j])&#123;</span><br><span class="line">                temp[t++] = array[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp[t++] = array[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把左半边剩余的放到temp中</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid)&#123;</span><br><span class="line">            temp[t++] = array[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把右半边剩余的放到temp中</span></span><br><span class="line">        <span class="keyword">while</span>(j &lt;= end)&#123;</span><br><span class="line">            temp[t++] = array[j++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//将temp移到原数组</span></span><br><span class="line">        <span class="keyword">while</span>(start &lt;= end)&#123;</span><br><span class="line">            array[start++] = temp[t++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>无论好坏的情况下合并的时间复杂度都为O(n)（因为对两个待排序列都需要遍历一遍），递归调用深度为O(logn)，因此总的时间复杂度为O(nlogn);</p>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>空间开销主要有两部分，一部分是辅助存储数组n，一部分是递归栈logn，因此总的空间复杂度为O(n + logn)，即O(n)</p>
<h1 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h1><p>归并排序具有稳定性，第33行比较条件为array[i] &lt;&#x3D; array[j]保证了相同元素的相对位置不会发生变化，比如待排序列为[3,2,<strong>2</strong>,1](此时加粗2在不加粗2的右边);归并一层：[3,2,<strong>2</strong>,1]-&gt;[3,2],[<strong>2</strong>,1]-&gt;[2,3],[1,<strong>2</strong>]-&gt;[1,2,<strong>2</strong>,3], 可以发现两个2的相对位置没有发生变化</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><table>
<thead>
<tr>
<th>排序算法</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>稳定性</th>
</tr>
</thead>
<tbody><tr>
<td>归并排序</td>
<td>总为O(nlogn)</td>
<td>O(n)</td>
<td>稳定</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>羊羊日记其一</title>
    <url>/2022/12/22/life/COVID19DiaryOne/</url>
    <content><![CDATA[<p>今天大约已经是进入羊圈的第四天。</p>
<h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h1><p>阳的第一天，嗓子有干涩的感觉，但不痛，发烧也只是象征性地温度涨了涨。本来以为奥密克戎不过如此，谁料竟是象征性地客气一下，来了手先礼后兵</p>
<h1 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h1><p>第二天腰就被偷袭，疼得我猝不及防，那种隐隐作痛的感觉，描述起来就是能够清楚的感觉到两边腰传来阵阵痛感，但却说不出到底是哪处，喉咙也开始轻微痛</p>
<h1 id="Day-3"><a href="#Day-3" class="headerlink" title="Day 3"></a>Day 3</h1><p>开始轻微的流鼻涕还鼻塞，喉咙继续痛痛痛，腰不痛了四肢开始痛</p>
<h1 id="Day-4"><a href="#Day-4" class="headerlink" title="Day 4"></a>Day 4</h1><p>到了今天，也就是阳历四天，最疼疼疼的腰已经不疼了，与此同时也喜提了一个红红的鼻子，没错就是小丑^o^的那个红鼻。因为狂流鼻涕，就需要一直拿纸擤鼻涕。愈流、愈擤、愈红、愈痛，说起来鼻子想必早就习惯这样的事情，毕竟平常感冒鼻子也会遭受这样的苦难</p>
<h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>这次羊和平常感冒最大的不同之处，就个人经历来说是腰遭受了从未有过的折磨。网上传言的小刀剌嗓子其实和平常感冒的咽痛如出一辙，甚至不及感冒，发烧也只是徒有其名而无其实。不知明天症状如何，是否会被打脸😴</p>
<p><em>ps：目前还未嗑过药，全靠免疫力了</em></p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>羊羊日记</tag>
      </tags>
  </entry>
  <entry>
    <title>插入排序之二分插入排序</title>
    <url>/2023/05/10/sort/BinaryInsertsort/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>插入排序的基本方法是：每步将一个待排序的元素，插入到前面已经排好序的一组元素的适当位置上去，直到元素全部插入为止。</p>
<p>插入排序主要有直接插入排序、二分插入排序、希尔排序，本章主要介绍二分插入排序。</p>
<h1 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h1><p>在直接插入排序的基础上改进，将顺序比较改进为二分比较，如序列为1，4，7，2，8，此时遍历至i&#x3D;3，即待排元素为2，直接插入是从已排序列向前逐一比较，2和7比较，2和7交换；2和4比较，2和4交换；二分插入是和已排序列的中间元素元素比较，2和4比较，2和1比较，最终2应该放在索引为1的位置，即元素4所在位置，然后将元素4，7向右移动一位，将2插入索引为1的位置</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinaryInsertsort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">        binaryInsertsort(array);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j : array) &#123;</span><br><span class="line">            System.out.println(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">binaryInsertsort</span><span class="params">(<span class="type">int</span>[] array)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> array[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> i-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (right - left) / <span class="number">2</span> + left;</span><br><span class="line">                <span class="keyword">if</span>(array[mid] == temp)&#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(array[mid] &lt; temp)&#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(array[mid] &gt; temp)&#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i;k&gt;left;k--)&#123;</span><br><span class="line">                array[k] = array[k-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            array[left] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>二分插入排序的比较次数少于直接插入排序，但移动次数和直接插入排序相同，平均为O(n<sup>2</sup>)</p>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>O(1)，使用了一个额外空间存放temp值</p>
<h1 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h1><p>根据<code>array[mid] == temp</code>执行<code>left = mid + 1</code>可以看出插入位置为相等元素的右边，因此稳定</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><table>
<thead>
<tr>
<th>排序算法</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>稳定性</th>
</tr>
</thead>
<tbody><tr>
<td>二分插入排序</td>
<td>平均为O(n<sup>2</sup>)，优于直接插入排序</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>插入排序之希尔排序</title>
    <url>/2023/04/27/sort/Shellsort/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>插入排序的基本方法是：每步将一个待排序的元素，插入到前面已经排好序的一组元素的适当位置上去，直到元素全部插入为止。</p>
<p>插入排序主要有直接插入排序、二分插入排序、希尔排序，本章主要介绍希尔排序。</p>
<h1 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h1><p>希尔排序是第一批突破O(n<sup>2</sup>)的排序算法之一，它是针对直接插入排序的改进，属于插入排序。</p>
<p>从插入排序的特点中可以看出如果<strong>待排序列元素较少</strong>或者<strong>待排序列有序度较高</strong>，那么排序的速度会较快，因此希尔排序的思想是将待排序列按照增量分组（每组元素减少），组内直接插入排序，然后不断缩小这个增量继续排序（每组元素增加但待排序列的有序度变高），当gap为1排序后序列有序，因此希尔排序又称缩小增量排序。</p>
<p>举一个最简单的例子，待排序列为4，3，2，1：</p>
<ol>
<li>初始gap为array.length&#x2F;2为2，即4，2为一组，3，1为一组</li>
<li>组内进行直接插入排序，可以交换或者移动，排序后的序列为2，1，4，3</li>
<li>gap&#x2F;&#x3D;2后gap为1，整个序列都为一组，-&gt;1, 2, 4, 3 -&gt; 1, 2, 4, 3 -&gt; 1, 2, 3, 4</li>
<li>gap&#x2F;&#x3D;2后gap为0，排序结束</li>
</ol>
<p>分析可以看出元素1回到头处比较和移动都为两次，而直接插入排序比较和移动都需要三次，究其原因是直接插入排序的增量都为1，而希尔排序的增量是跳跃式的，相应地也减少了比较和移动的次数</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Shellsort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">        shellsort(array);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j : array) &#123;</span><br><span class="line">            System.out.println(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shellsort</span><span class="params">(<span class="type">int</span>[] array)</span>&#123;</span><br><span class="line">        <span class="comment">//gap从array.length/2开始，gap/=2</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> array.length/<span class="number">2</span>; gap&gt;<span class="number">0</span>; gap/=<span class="number">2</span>)&#123;</span><br><span class="line">          	<span class="comment">//从索引为gap的元素开始遍历</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=gap; i&lt;array.length; i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> array[j];</span><br><span class="line">              	<span class="comment">//同组所有比temp大的元素向右移动</span></span><br><span class="line">              	<span class="comment">//比如5, 2, 4, 3, 6, 1;此时i为5，j也为5，temp为1，gap为2</span></span><br><span class="line">                <span class="comment">//-&gt;5, 2, 4, 3, 6, 3; j为3</span></span><br><span class="line">                <span class="comment">//-&gt;5, 2, 4, 2, 6, 3; j为1</span></span><br><span class="line">                <span class="keyword">while</span>(j - gap &gt;= <span class="number">0</span> &amp;&amp; temp &lt; array[j-gap]) &#123;</span><br><span class="line">                    array[j] = array[j - gap];</span><br><span class="line">                    j -= gap;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//留下的空位放temp</span></span><br><span class="line">                <span class="comment">//-&gt;5, 1, 4, 2, 6, 3; array[j] = temp -&gt; array[1] = 1;</span></span><br><span class="line">                array[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>希尔排序的时间复杂度根据步长序列的不同而不同，总的来说希尔排序的时间复杂度小于O(n<sup>2</sup>)，但没有快速排序(平均为O(nlogn))快；</p>
<p>最好的步长序列为从第0项开始，偶数来自9×4<sup>i</sup>−9×2<sup>i</sup>+1和奇数来自2<sup>i+2</sup>×(2<sup>i+2</sup>−3)+1这两个算式，此时最好的最差时间复杂度为O(nlog<sup>2</sup>n);</p>
<p>通常使用的n&#x2F;2<sup>i</sup>，最差时间复杂度为O(n<sup>2</sup>);</p>
<p>最好时间复杂度为O(n)</p>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>O(1)，额外一个空间用于存放temp值</p>
<h1 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h1><p>当待排序列为2，2*，1，4，gap为2时，排序后为1，2*，2，4，两个2的相对顺序改变，因此希尔排序不稳定</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><table>
<thead>
<tr>
<th>排序算法</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>稳定性</th>
</tr>
</thead>
<tbody><tr>
<td>希尔排序</td>
<td>最好为O(n)，最差和平均根据步长序列不同而不同，最好的最坏复杂度为O(nlog<sup>2</sup>n)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>插入排序之直接插入排序</title>
    <url>/2023/05/10/sort/DirectInsertsort/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>插入排序的基本方法是：每步将一个待排序的元素，插入到前面已经排好序的一组元素的适当位置上去，直到元素全部插入为止。</p>
<p>插入排序主要有直接插入排序、二分插入排序、希尔排序，本章主要介绍直接插入排序。</p>
<h1 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h1><p>将带排序元素插入到有序序列的对应位置</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Insertsort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">        insertsort(array);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j : array) &#123;</span><br><span class="line">            System.out.println(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertsort</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> array[j];</span><br><span class="line">            <span class="keyword">while</span>(j-<span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; temp &lt; array[j-<span class="number">1</span>])&#123;</span><br><span class="line">                array[j] = array[j-<span class="number">1</span>];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            array[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>最好O(n)，最差O(n<sup>2</sup>)，平均O(n<sup>2</sup>)</p>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>O(1)</p>
<h1 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h1><p>相同大小元素之间的相对位置并不会改变，稳定</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><table>
<thead>
<tr>
<th>排序算法</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>稳定性</th>
</tr>
</thead>
<tbody><tr>
<td>直接插入排序</td>
<td>最好O(n)，最差O(n<sup>2</sup>)，平均O(n<sup>2</sup>)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法之一———快速排序</title>
    <url>/2023/04/27/sort/Quicksort/</url>
    <content><![CDATA[<h1 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h1><p>采用分治的思想，步骤可以概括为：</p>
<ol>
<li>选取基准值pivot(一般默认选开始的位置)</li>
<li>将小于pivot的数放在左边，大于pivot的数放在右边(挖坑填补法)</li>
<li>对pivot左边和右边的序列分别递归执行步骤1、2</li>
</ol>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Quicksort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        quicksort(array,<span class="number">0</span>,array.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            System.out.println(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quicksort</span><span class="params">(<span class="type">int</span>[] array,<span class="type">int</span> start, <span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt;= end) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> start;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> end;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> array[start];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="comment">//从右边找小于pivot的数</span></span><br><span class="line">            <span class="keyword">while</span>(right &gt; left &amp;&amp; array[right] &gt;= pivot) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找到交换，right位置的数填到left，right挖坑</span></span><br><span class="line">            array[left] = array[right];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//从左边找大于pivot的数</span></span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; array[left] &lt;= pivot) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找到交换，left位置的数填到right，left挖坑</span></span><br><span class="line">            array[right] = array[left];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//此时left = right，最后一个坑填pivot</span></span><br><span class="line">        array[right] = pivot;</span><br><span class="line"></span><br><span class="line">        quicksort(array, start,left - <span class="number">1</span>);</span><br><span class="line">        quicksort(array, right + <span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>初始main第4行调用quicksort(array, 0, 9);<ul>
<li>left为0，right为9，pivot为5</li>
<li>left为0，right为9，left小于right，进入15行if结构体<ul>
<li>left为0，right为9，left小于right，进入16行while结构体<ul>
<li>17行的while条件中array[right] &#x3D; array[9] &#x3D; 3，小于pivot为5，退出while循环</li>
<li>20行array[left] &#x3D; array[right]，即array[0] &#x3D; array[9]，此时array变成[3,2,4,1,6,8,10,7,9,3];</li>
<li>22行的while循环一直到left &#x3D; 4才停止，此时array[left] &#x3D; array[4] &#x3D; 6，大于pivot为5，退出while循环</li>
<li>25行array[right] &#x3D; array[left], 即array[9] &#x3D; array[4]，此时array变成[3,2,4,1,6,8,10,7,9,6];</li>
</ul>
</li>
<li>此时left为4，right为9，left小于right，再次进入16行while结构体<ul>
<li>17行的while循环一直到left &#x3D; right，都为4，此时不满足right  &gt; left，退出while循环</li>
<li>20行array[left] &#x3D; array[right]，即array[4] &#x3D; array[4]，此时array还是[3,2,4,1,6,8,10,7,9,6];</li>
<li>22行的while循环不满足left &lt; right，退出while循环</li>
<li>25行array[right] &#x3D; array[left]，即array[4] &#x3D; array[4]，此时array还是[3,2,4,1,6,8,10,7,9,6];</li>
</ul>
</li>
<li>此时left &#x3D; right &#x3D; 4，不满足循环条件，退出16行的while</li>
<li>28行array[right] &#x3D; pivot，即array[4] &#x3D; 5，此时array变成[3,2,4,1,5,8,10,7,9,6]，此时小于5的值都在5的左边，大于5的值都在5的右边</li>
<li>30行调用quicksort(array,0,5);</li>
<li>31行调用quicksort(array,7,9);</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ul>
<li>最好情况O(nlogn)：当每次选择的基准值都是待排序列的中值时，总共需要递归O(logn)次，每层花费时间O(n)，即O(nlogn);</li>
<li>最差情况O(n<sup>2</sup>)：当每次选择的基准值都是待排序列的最值时，相当于直接插入排序，总共需要递归O(n)次，每层花费时间O(n)，即O(n<sup>2</sup>);</li>
<li>平均情况O(nlogn)</li>
</ul>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>概括来讲快排的每层都只使用了常数空间(一个空间用于保存pivot的值），因此空间复杂度等于递归调用的深度即最好为O(logn)，最差为O(n);</p>
<h1 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h1><ul>
<li>不稳定：待排序列为[6,1,3,7,<strong>3</strong>](注意原来不加粗3在加粗3的左边)，经过一次排序后(以6为pivot)，序列变成[<strong>3</strong>,1,3,6,7]，最终排序结果为[1,<strong>3</strong>,3,6,7]，可以发现不加粗3到了加粗3的右边，相等元素之间相对位置发生了变化，因此快排是<strong>不稳定的</strong></li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><table>
<thead>
<tr>
<th>排序方式</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>稳定性</th>
</tr>
</thead>
<tbody><tr>
<td>快速排序</td>
<td>最好为O(nlogn)，最差为O(n<sup>2</sup>)，平均为O(nlogn)</td>
<td>最好为O(logn)，最差为O(n)</td>
<td>不稳定</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>背包问题</title>
    <url>/2024/12/05/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="0-1背包"><a href="#0-1背包" class="headerlink" title="0-1背包"></a>0-1背包</h1><p>背包容量为$W$，物品有$N$个且每种物品不可重复使用，物品$n$的重量为$wg[n]$、价值为$val[n]$</p>
<p>问最多能装多少价值？</p>
<ul>
<li><p>dp数组定义<br>$$<br>dp[n][w] &#x3D; 仅使用前n个物品（不可重复使用）、背包容量为w时能装下的最大价值<br>$$</p>
</li>
<li><p>状态转移方程</p>
</li>
</ul>
<p>$$<br>dp[n][w] &#x3D; Max<br>\begin{cases}<br>dp[n-1][w], \quad 不装物品n \[2ex]<br>dp[n-1][w-wg[n]] + val[n], \quad 装入物品n<br>\end{cases}<br>$$</p>
<h2 id="有几种不同的装法"><a href="#有几种不同的装法" class="headerlink" title="有几种不同的装法"></a>有几种不同的装法</h2><ul>
<li><p>额外用一个三维数组path存放装法数量<br>$$<br>path[n][w] &#x3D; 仅使用前n个物品（不可重复使用），背包容量为w时能装下最大价值的装法数量<br>$$</p>
</li>
<li><p>状态转移方程</p>
</li>
</ul>
<p>$$<br>path[n-1][w] \quad 不装物品n \quad ① \<br>path[n-1][w-wg[n]] \quad 装入物品n \quad ②\[2ex]<br>path[n][w] &#x3D;<br>\begin{cases}<br>①, \quad ① &gt; ②\[2ex]<br>②, \quad ①&lt; ②\[2ex]<br>① + ②, \quad ①&#x3D;②<br>\end{cases}<br>$$</p>
<h2 id="怎么装"><a href="#怎么装" class="headerlink" title="怎么装"></a>怎么装</h2><ul>
<li><p>额外用一个三维数组path存放具体装法<br>$$<br>path[n][w] &#x3D; 仅使用前n个物品（不可重复使用），背包容量为w时能装下最大价值的具体装法<br>$$</p>
</li>
<li><p>状态转移方程</p>
</li>
</ul>
<p>$$<br>path[n-1][w] \quad 不装物品n \quad ① \<br>path[n-1][w-wg[n] \quad 装入物品n \quad ② \[2ex]<br>path[n][w] &#x3D;<br>\begin{cases}<br>① \quad①, \quad ①&gt;② \[2ex]<br>②.EachOf().append(物品n) \quad②, \quad ①&lt;②\[2ex]<br>[①, \quad ②.EachOf().append(物品n)], \quad ①&#x3D;② \[2ex]<br>\end{cases}<br>$$</p>
<h2 id="物品可重复使用"><a href="#物品可重复使用" class="headerlink" title="物品可重复使用"></a>物品可重复使用</h2><ol>
<li>修改dp数组定义为 <strong>可重复使用</strong> </li>
<li>由于可以重复使用，状态转移方程 <strong>装入物品n</strong> 分支应该改为 $dp[n][w-wg[n]]+val[n]$</li>
</ol>
<h1 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h1><p>背包容量为$W$，物品有$N$个且每种物品可以重复使用，物品$n$的重量为$wg[n]$</p>
<p>问是否能够正好装满？</p>
<ul>
<li><p>dp数组定义<br>$$<br>dp[n][w] &#x3D; 仅使用前n个物品（可重复使用），背包容量为w时是否能够正好装满<br>$$</p>
</li>
<li><p>状态转移方程<br>$$<br>dp[n][w] &#x3D; ||<br>\begin{cases}<br>dp[n-1][w]，不装物品n \[2ex]<br>dp[n][w-wg[n]]，装入物品n<br>\end{cases}<br>$$</p>
</li>
</ul>
<h2 id="有几种不同的装法-1"><a href="#有几种不同的装法-1" class="headerlink" title="有几种不同的装法"></a>有几种不同的装法</h2><ol>
<li>修改dp数组定义为 <strong>仅使用前n个物品（可重复使用），背包容量为w时正好能装满的装法数量</strong></li>
<li>状态转移方程改为 $dp[n][w] &#x3D; dp[n-1][w] + dp[n][w-wg[n]] $</li>
</ol>
<h2 id="怎么装-1"><a href="#怎么装-1" class="headerlink" title="怎么装"></a>怎么装</h2><ol>
<li>修改dp数组定义为 <strong>仅使用前n个物品（可重复使用），背包容量为w时正好能装满的具体装法</strong>（三维数组）</li>
<li>状态转移方程改为 $dp[n][w] &#x3D; [dp[n-1][w], \quad dp[n][w-wg[n]].EachOf().append(物品n)]$</li>
</ol>
<h2 id="物品不可重复使用"><a href="#物品不可重复使用" class="headerlink" title="物品不可重复使用"></a>物品不可重复使用</h2><ol>
<li>修改dp数组定义为 <strong>不可重复使用</strong></li>
<li>状态转移方程 <strong>装入物品n</strong> 分支应该改为 $dp[n-1][w-wt[n]]$</li>
</ol>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
</search>
